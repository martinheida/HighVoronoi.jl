<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Intentions of use (EXAMPLES) · HighVoronoi.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://martinheida.github.io/HighVoronoi.jl/showcase/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">HighVoronoi.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual Voronoi</span><ul><li><a class="tocitem" href="../man/short/">Examples Voronoi Generation</a></li><li><a class="tocitem" href="../man/workflowmesh/">Workflow</a></li><li><a class="tocitem" href="../man/geometry/">Voronoi: Nodes and Geometry, Integrators</a></li><li><a class="tocitem" href="../man/boundaries/">Boundaries</a></li><li><a class="tocitem" href="../man/advanced/">Advanced Options</a></li><li><a class="tocitem" href="../man/periodic/">Highspeed periodic geometries</a></li><li><a class="tocitem" href="../man/refine/">Refinement and Substitution of Subdomains</a></li><li><a class="tocitem" href="../man/projection/">Projection operators</a></li><li><a class="tocitem" href="../man/metapost/">2D-Output using MetaPost</a></li><li><a class="tocitem" href="../man/errors/">Sources of errors and loss in performance</a></li></ul></li><li><span class="tocitem">Manual Finite Volume</span><ul><li><a class="tocitem" href="../man/finitevolumeexample/">Finite Volume Examples</a></li><li><a class="tocitem" href="../man/workflowfv/">Workflow in FV</a></li><li><a class="tocitem" href="../man/finitevolume/">Finite Volume Tutorial</a></li><li><a class="tocitem" href="../man/functions/">Functions</a></li><li><a class="tocitem" href="../man/integrals/">(More) Integrals</a></li><li><a class="tocitem" href="../man/toyfvfile/">Some code to test and play around</a></li></ul></li><li class="is-active"><a class="tocitem" href>Intentions of use (EXAMPLES)</a><ul class="internal"><li><a class="tocitem" href="#Mesh-generation-and-integration"><span>Mesh generation and integration</span></a></li><li><a class="tocitem" href="#Finite-Volume-problems:-Generating-the-matrix-and-the-right-hand-side-from-data"><span>Finite Volume problems: Generating the matrix and the right hand side from data</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Intentions of use (EXAMPLES)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Intentions of use (EXAMPLES)</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/martinheida/HighVoronoi.jl/blob/main/docs/src/showcase.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="intentions"><a class="docs-heading-anchor" href="#intentions">Using the HighVoronoi Library</a><a id="intentions-1"></a><a class="docs-heading-anchor-permalink" href="#intentions" title="Permalink"></a></h1><p>We collect some examples how the package is meant to be applied.</p><div class="admonition is-success"><header class="admonition-header">SKIP &#39;&#39;Mesh generation&#39;&#39; and study the &#39;&#39;Finite Volume methods&#39;&#39; section first</header><div class="admonition-body"><p>If you are interested in Finite Volume methods but you do not want to go to much into details on mesh generation, you may skipt this first part. However, for setting up several different problems on large dimensions, recycling mesh data and using mesh refinement techniques, it is strongly advised to study the capabilities of the <code>VoronoiGeometry</code> data structure in a second approach.</p></div></div><h2 id="Mesh-generation-and-integration"><a class="docs-heading-anchor" href="#Mesh-generation-and-integration">Mesh generation and integration</a><a id="Mesh-generation-and-integration-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-generation-and-integration" title="Permalink"></a></h2><p>Mesh generation in form of a <code>VoronoiGeometry</code> relies on the following data: A set of points (<code>VoronoiNodes</code>), a boundary (<code>Boundary</code>, <code>cuboid</code>), the choice of an <code>integrator</code> method and the optional choice of a function to be integrated (<code>integrand = x-&gt;...</code>). Points and boundaries can also be retrieved from a formerly calculated <code>VoronoiGeometry</code>.</p><p>The intentions how this is done are demonstrated in the following examples:</p><ol><li><a href="#Mgi1">Example 1: Basics</a></li><li><a href="#Mgi2">Example 2: Integration on fully periodic grid</a></li><li><a href="#Mgi3">Example 3: Non-periodic bounded domain with data storage</a></li><li><a href="#Mgi4">Example 4: Load and integrate new function</a></li><li><a href="#Mgi5">Example 5: Copy and integrate new function</a></li><li><a href="#Mgi6">Example 6: Mesh-Refinement</a></li><li><a href="#Mgi7">Example 7: Mesh-Refinement with locally new integrand</a></li></ol><p>Future extensions imply the fast, efficient generation of large quasi-periodic meshes in high dimensions. These meshes shall then be locally refined according to the user&#39;s needs. </p><h3 id="Mgi1"><a class="docs-heading-anchor" href="#Mgi1">Example 1: Basics</a><a id="Mgi1-1"></a><a class="docs-heading-anchor-permalink" href="#Mgi1" title="Permalink"></a></h3><p>Generate a 3D mesh of 100 Points with no boundary. Calculates only verteces and neighbors.</p><pre><code class="language-julia hljs">xs = VoronoiNodes( rand(3,100) )
vg = VoronoiGeometry(xs, integrator=HighVoronoi.VI_GEOMETRY)
vd = VoronoiData(vg, getverteces=true)   
# vd.neighbors contains for each node `i` a list of all neighbors
# vd.verteces contains for each node `i` a list of all verteces that define the cell.</code></pre><h3 id="Mgi2"><a class="docs-heading-anchor" href="#Mgi2">Example 2: Integration on fully periodic grid</a><a id="Mgi2-1"></a><a class="docs-heading-anchor-permalink" href="#Mgi2" title="Permalink"></a></h3><p>Generate a 5D mesh of 1000 points with periodic boundary conditions on a unit cube <span>$(0,1)^5$</span>. It then uses triangulation integration to integrate the function</p><p class="math-container">\[x\mapsto\left(\begin{array}{c}\|x\| \\ x_1x_2\end{array}\right)\]</p><p>For general polygon domains <a href="../man/boundaries/#createboundary">see here</a>. </p><pre><code class="language-julia hljs">xs2 = VoronoiNodes( rand(5,1000) )
vg2 = VoronoiGeometry(xs2, cuboid(5), integrator=HighVoronoi.VI_POLYGON, integrand = x-&gt;[norm(x),x[1]*x[2]])
vd2 = VoronoiData(vg2)    </code></pre><ul><li><code>vd2.volume[i]</code> and <code>vd2.bulk_integral[i]</code> contain the volume of cell <span>$i$</span> and the integral of <code>integrand</code> over cell <span>$i$</span></li><li><code>vd2.neighbors[i]</code> contains an array of all neighbors of <span>$i$</span>. </li><li>for each <span>$j$</span> the field <code>vd2.area[i][j]</code> contains the interface area between <span>$i$</span> and <code>vd2.neighbors[i][j]</code>.</li><li>for each <span>$j$</span> the field <code>vd2.interface_integral[i][j]</code> contains the integral of <code>integrand</code> over    the interface area between <span>$i$</span> and <code>vd2.neighbors[i][j]</code>.</li></ul><div class="admonition is-info"><header class="admonition-header"></header><div class="admonition-body"><p>If <span>$j\not=k$</span> but <code>vd2.neighbors[i][j]==vd2.neighbors[i][k]</code>  this means that <span>$i$</span> shares two differnt interfaces with <code>n=vd2.neighbors[i][j]</code>.  This happens due to periodicity and low number of nodes in relation to the dimension.</p></div></div><h3 id="Mgi3"><a class="docs-heading-anchor" href="#Mgi3">Example 3: Non-periodic bounded domain with data storage</a><a id="Mgi3-1"></a><a class="docs-heading-anchor-permalink" href="#Mgi3" title="Permalink"></a></h3><p>Like Example 2 but we store and load the data:</p><pre><code class="language-julia hljs">xs3 = VoronoiNodes( rand(5,1000) )
vg3 = VoronoiGeometry(xs3, cuboid(5,periodic=[2]), integrator=HighVoronoi.VI_POLYGON, integrand = x-&gt;[norm(x),x[1]*x[2]])
write_jld(vg3, &quot;my5Dexample.jld&quot;)
vg3_reload_vol = VoronoiGeometry(&quot;my5Dexample.jld&quot;)</code></pre><p>The mesh <code>vg3</code> is periodic only in direction of <span>$e_2=(0,1,0,0,0)$</span>. The variable <code>vg3_reload_vol</code> now contains a copy of nodes, verteces, volumes and areas in <code>vg3</code>. It contains NOT the integral values.</p><pre><code class="language-julia hljs">vg3_a = VoronoiGeometry(&quot;my5Dexample.jld&quot;, bulk=true, interface=true)</code></pre><p>The variable <code>vg3_a</code> contains also the integrated values. However, the method will prompt a warning because no integrand is provided. Hence try the following:</p><pre><code class="language-julia hljs">vg3_modified = VoronoiGeometry(&quot;my5Dexample.jld&quot;, bulk=true, interface=true, integrand = x-&gt;[x[5],sqrt(abs(x[3]))])
vg3_full = VoronoiGeometry(&quot;my5Dexample.jld&quot;, bulk=true, interface=true, integrand = x-&gt;[norm(x),x[1]*x[2]])</code></pre><div class="admonition is-warning"><header class="admonition-header"></header><div class="admonition-body"><p>The method <code>VoronoiGeometry(filename)</code> DOES compare the dimensions of the integrand with the stored data. However, it DOES NOT compare wether the original and the newly provided function are the same.</p></div></div><h3 id="Mgi4"><a class="docs-heading-anchor" href="#Mgi4">Example 4: Load and integrate new function</a><a id="Mgi4-1"></a><a class="docs-heading-anchor-permalink" href="#Mgi4" title="Permalink"></a></h3><p>We can also recycle efficiently the stored geometry by using its volumes and interfaces and integrate another function using the <code>VI_HEURISTIC</code> integrator.</p><pre><code class="language-julia hljs">vg4 = VoronoiGeometry(&quot;my5Dexample.jld&quot;, integrand = x-&gt;[x[1]*x[5],sqrt(abs(x[3])),sum(abs2,x)],integrator=HighVoronoi.VI_HEURISTIC)</code></pre><p>This will cause a warning stating that the new integrator <code>VI_HEURISTIC</code> does not match the original integrator. Just ignore it. You can also use <code>VI_POLYGON</code> or <code>VI_MONTECARLO</code> but this will take much more time for the integration.</p><h3 id="Mgi5"><a class="docs-heading-anchor" href="#Mgi5">Example 5: Copy and integrate new function</a><a id="Mgi5-1"></a><a class="docs-heading-anchor-permalink" href="#Mgi5" title="Permalink"></a></h3><p>Similar to the last example, we may also directly copy <code>vg3</code></p><pre><code class="language-julia hljs">vg5 = VoronoiGeometry(vg3, integrator=HighVoronoi.VI_HEURISTIC, integrand = x-&gt;[sum(abs2,x)])</code></pre><h3 id="Mgi6"><a class="docs-heading-anchor" href="#Mgi6">Example 6: Mesh-Refinement</a><a id="Mgi6-1"></a><a class="docs-heading-anchor-permalink" href="#Mgi6" title="Permalink"></a></h3><p>Say the user has created or loaded a <code>VoronoiGeometry</code> and wants to add some more points. In our case, we create a partially periodic mesh in <span>$3D$</span> with 1000 points in <span>$(0,1)^3$</span> and afterwards add 100 Points in <span>$(0,0.1)^3$</span> for higher resolution in this region.</p><pre><code class="language-julia hljs">vg6 = VoronoiGeometry( VoronoiNodes(rand(3,1000)), cuboid(3,periodic=[2]), 
                      integrand=x-&gt;[sum(abs,x)], integrator=HighVoronoi.VI_POLYGON)
refine!(vg6, VoronoiNodes(0.1.*rand(3,100)))                      </code></pre><p>If, for whatever reason, the user does not want the algorithm to update the volumes, areas, integrals, ... he may add the command <code>update=false</code>.</p><h3 id="Mgi7"><a class="docs-heading-anchor" href="#Mgi7">Example 7: Mesh-Refinement with locally new integrand</a><a id="Mgi7-1"></a><a class="docs-heading-anchor-permalink" href="#Mgi7" title="Permalink"></a></h3><p>We modify Example 6:</p><pre><code class="language-julia hljs">vg7 = VoronoiGeometry( VoronoiNodes(rand(3,1000)), cuboid(3,periodic=[2]), 
                      integrand=x-&gt;[sum(abs,x)], integrator=HighVoronoi.VI_POLYGON)
vg7b = VoronoiGeometry( vg7, bulk=true, interface=true, integrand=x-&gt;[sqrt(sum(abs2,x))])
refine!(vg7b, VoronoiNodes(0.1.*rand(3,100)))                      </code></pre><p>Because <code>bulk=true</code> and <code>interface=true</code>, <code>vg7b</code> simply copies all data from <code>vg7</code>, including the integrated values of <code>f(x)=[sum(abs,x)]</code>. However, when the <code>refine!</code> function is called, the local integral on every modified interface and cell will be recalculated using the new function  <code>f2(x)=[sqrt(sum(abs2,x))]</code>. This means in the new cell we completly have integrated values of <code>f2</code> while on old and non-modified  cells we still have integrated values of <code>f</code>. On cells that have been partially modified, the new integral is an interpolation between the old and the new function.</p><h2 id="Finite-Volume-problems:-Generating-the-matrix-and-the-right-hand-side-from-data"><a class="docs-heading-anchor" href="#Finite-Volume-problems:-Generating-the-matrix-and-the-right-hand-side-from-data">Finite Volume problems: Generating the matrix and the right hand side from data</a><a id="Finite-Volume-problems:-Generating-the-matrix-and-the-right-hand-side-from-data-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-Volume-problems:-Generating-the-matrix-and-the-right-hand-side-from-data" title="Permalink"></a></h2><p>The most simple way to implement a Finite Volume discretization within <code>HighVoronoi</code> is to provide</p><ul><li>a list of nodes</li><li>a domain</li><li>a list of parameter functions to evaluated pointwise or in an averaged sense</li><li>a description of the flux in terms of the Voronoi mesh and the pointwise/averaged data</li><li>a description of right hand side in terms of the Voronoi mesh and the pointwise/averaged data</li><li>a description of the boundary conditions (note that periodic boundary conditions are in fact implemented as a part of the MESH and cannot be modified at this stage)</li></ul><p>We provide the following two examples covering both intentions of use</p><ol><li><a href="#FVex1">Example 1: Most simple way from scratch</a></li><li><a href="#FVex2">Example 2: Relying on preexisting <code>VoronoiGeometry</code></a></li></ol><h3 id="FVex1"><a class="docs-heading-anchor" href="#FVex1">Example 1: Most simple way from scratch</a><a id="FVex1-1"></a><a class="docs-heading-anchor-permalink" href="#FVex1" title="Permalink"></a></h3><p>We create #<code>nop</code> points within <span>$(0,1)^3$</span> and prescribe <span>$(0,1)^3$</span> as our domain for the mesh generation. We define functions <span>$\kappa(x)=1+\|x\|^2$</span> and <span>$f(x)=\sin(2*\pi*x_1)$</span>. Then we make use of <code>VoronoiFVProblem</code> to set up the discrete equation</p><p class="math-container">\[\forall i: \qquad \sum_{j\sim i}p_{ij}u_i-p_{ji}u_j=F_i\]</p><p>where</p><p class="math-container">\[\left(p_{ij},p_{ji}\right)=\mathrm{myflux}=\left(\frac{1}{|x_i-x_j|}m_{ij}*\sqrt{\kappa_i\kappa_j}\,,\;\frac{1}{|x_i-x_j|}m_{ij}*\sqrt{\kappa_i\kappa_j}\right)\,,\qquad F_i=m_i*f(x_i)\,.\]</p><p><a href="../man/finitevolume/#examplefluxes">This is a discretization of</a></p><p class="math-container">\[-\nabla\cdot(\kappa\nabla u)=f\qquad\mathrm{on}\,(0,1)^3\,.\]</p><p>As boundary conditions we implement for <span>$J=-\kappa\nabla u$</span> and outer normal <span>$\nu$</span>:</p><p class="math-container">\[\begin{align*}
1.&amp; &amp; u(x) &amp; =\sin(\pi x_2)\sin(\pi x_3) &amp; \quad\text{on } &amp; \{0,1\}\times(0,1)^2\,,\\
2.&amp; &amp; u(x) &amp; =0 &amp; \quad\text{on } &amp; (0,1)\times\{0,1\}\times(0,1)\,,\\
3.&amp; &amp; j\cdot\nu &amp; =1 &amp; \quad\text{on } &amp; (0,1)^2\times\{0,1\}\,,\\
\end{align*}\]</p><p>Accodring to the internal structure of the cube, BC 1. corresponds to the surface planes <code>[1,2]</code>, BC 2. corresponds to the surface planes <code>[3,4]</code> and BC 3. correpsonds to the surface planes <code>[5,6]</code>. <a href="../man/boundaries/#allonboundaries">More information on boundaries is given here.</a> </p><pre><code class="language-julia hljs">using LinearAlgebra
using SpecialFunctions
using SparseArrays

function myflux(;para_i,para_j,mass_ij,normal,kwargs...) 
    # kwargs... collects all additional parameters which are not used in the current function.
    weight = norm(normal)^(-1) * mass_ij * sqrt(para_i[:kappa]*para_j[:kappa])
    return weight, weight
end

myRHS(;para_i,mass_i,kwargs...) = mass_i * para_i[:f] 


function test_FV_3D(nop)
    vfvp = VoronoiFVProblem( VoronoiNodes( rand(3,nop) ), cuboid(3,periodic=[]), 
                                discretefunctions = (f=x-&gt;sin(2*pi*x[1]),), # evaluate f pointwise
                                integralfunctions = (kappa=x-&gt;1.0+norm(x)^2,), # calculate averages of kappa over cells and interfaces
                                fluxes = ( j1 = myflux, ),
                                rhs_functions = (F = myRHS,) )
    # turn functions that depend on x into the required HighVoronoi-format:
    homogeneous = FVevaluate_boundary(x-&gt;0.0)
    one = FVevaluate_boundary(x-&gt;1.0)
    non_hom = FVevaluate_boundary(x-&gt;sin(pi*x[2])*sin(pi*x[3]))

    r,c,v,f = linearVoronoiFVProblem(   vfvp, flux = :j1, rhs = :F, 
                                    Neumann = ([5,6],one), 
                                    Dirichlet = (([3,4],homogeneous), ([1,2],non_hom),), )
    A = sparse(r,c,v) # a sparse matrix with rows `r`, coloumns `c` and values `v`
    # solution_u = somelinearsolver(A,f)

end

test_FV_3D(100)</code></pre><h3 id="FVex2"><a class="docs-heading-anchor" href="#FVex2">Example 2: Relying on preexisting <code>VoronoiGeometry</code></a><a id="FVex2-1"></a><a class="docs-heading-anchor-permalink" href="#FVex2" title="Permalink"></a></h3><p>We build a 5D-mesh in the unit cube of 5000 points using <code>VoronoiGeometry</code> and store it for later use. Since we have plenty of time, we do it using the exact <code>VI_POLYGON</code> integrator.</p><pre><code class="language-julia hljs">write_jld( VoronoiGeometry( VoronoiNodes(rand(5,5000)), cuboid(5,periodic=[]), integrator=HighVoronoi.VI_POLYGON ), &quot;my5Dmesh.jld&quot; )</code></pre><p>Next, we want to use this stored grid to immplement <a href="#FVex1">the above example</a> in 5D, adding homogeneous Dirichlet conditions in the remaining dimensions. However, we also want <code>:f</code> to be evaluated in an averaged sence, not pointwise. Since we will need their specification in two places, we fix them once and for all:</p><pre><code class="language-julia hljs">my_functions = (f=x-&gt;sin(2*pi*x[1]), kappa=x-&gt;1.0+norm(x)^2,)</code></pre><p>We need to integrate <span>$\kappa$</span> and <span>$f$</span> the moment we load the geometry from file. To make sure the integrated data will match the needs of the Finite Volume algorithm, we use <a href="@ref The-FunctionComposer-struct"><code>FunctionComposer</code></a>:</p><pre><code class="language-julia hljs">composed_function = FunctionComposer(reference_argument=zeros(Float64,5), super_type=Float64; my_functions...).functions</code></pre><p>The definitions of <code>myflux</code> and <code>myRHS</code> are independent from the dimension and can just be taken from above.</p><pre><code class="language-julia hljs">function test_FV_5D_from_file()_
    my_functions = (f=x-&gt;sin(2*pi*x[1]), kappa=x-&gt;1.0+norm(x)^2,)
    composed_function = FunctionComposer(   reference_argument=zeros(Float64,5), 
                                            super_type=Float64; my_functions...).functions

    vg = VoronoiGeometry( &quot;my5Dmesh.jld&quot;,   integrator = HighVoronoi.VI_HEURISTIC, 
                                            integrand = composed_function)

    vfvp = VoronoiFVProblem( vg, integralfunctions = my_functions, 
                                 fluxes = ( j1 = myflux, ),
                                 rhs_functions = (F = myRHS,) )

    homogeneous = FVevaluate_boundary(x-&gt;0.0)
    one = FVevaluate_boundary(x-&gt;1.0)
    non_hom = FVevaluate_boundary(x-&gt;sin(pi*x[2])*sin(pi*x[3]))

    r,c,v,f = linearVoronoiFVProblem(   vfvp, flux = :j1, rhs = :F, Neumann = ([5,6],one), 
                                Dirichlet = (([3,4,7,8,9,10],homogeneous), ([1,2],non_hom),), )
    A = sparse(r,c,v) # a sparse matrix with rows `r`, coloumns `c` and values `v`
    # solution_u = somelinearsolver(A,f)
end</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../man/toyfvfile/">« Some code to test and play around</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Saturday 9 September 2023 05:32">Saturday 9 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
