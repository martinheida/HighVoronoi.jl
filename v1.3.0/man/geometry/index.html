<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Voronoi: Nodes and Geometry, Integrators · HighVoronoi.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://martinheida.github.io/HighVoronoi.jl/man/geometry/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">HighVoronoi.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual Voronoi</span><ul><li><a class="tocitem" href="../short/">Examples Voronoi Generation</a></li><li><a class="tocitem" href="../workflowmesh/">Workflow</a></li><li class="is-active"><a class="tocitem" href>Voronoi: Nodes and Geometry, Integrators</a><ul class="internal"><li><a class="tocitem" href="#differentnodegenerators"><span>Nodes</span></a></li><li><a class="tocitem" href="#Geometry"><span>Geometry</span></a></li><li><a class="tocitem" href="#integratoroverview"><span>Integrators (overview)</span></a></li><li><a class="tocitem" href="#Storage:-JLD2"><span>Storage: JLD2</span></a></li><li><a class="tocitem" href="#Storage:-deprecated-solution"><span>Storage: deprecated solution</span></a></li><li><a class="tocitem" href="#Extraction-of-VoronoiData-data-for-further-processing"><span>Extraction of <code>VoronoiData</code> data for further processing</span></a></li></ul></li><li><a class="tocitem" href="../raycast/">Voronoi: Raycast methods</a></li><li><a class="tocitem" href="../multithread/">Multithreading</a></li><li><a class="tocitem" href="../database/">Voronoi: Database Structure</a></li><li><a class="tocitem" href="../improving/">Improving Voronoi meshes for FV </a></li><li><a class="tocitem" href="../boundaries/">Boundaries</a></li><li><a class="tocitem" href="../advanced/">Advanced Options</a></li><li><a class="tocitem" href="../periodic/">Highspeed periodic geometries</a></li><li><a class="tocitem" href="../refine/">Refinement and Substitution of Subdomains</a></li><li><a class="tocitem" href="../projection/">Projection operators</a></li><li><a class="tocitem" href="../metapost/">Graphical Output in 2D and 3D</a></li><li><a class="tocitem" href="../errors/">Sources of errors and loss in performance</a></li></ul></li><li><span class="tocitem">Manual Finite Volume</span><ul><li><a class="tocitem" href="../finitevolumeexample/">Finite Volume Examples</a></li><li><a class="tocitem" href="../workflowfv/">Workflow in FV</a></li><li><a class="tocitem" href="../finitevolume/">Finite Volume Tutorial</a></li><li><a class="tocitem" href="../functions/">Functions</a></li><li><a class="tocitem" href="../integrals/">(More) Integrals</a></li><li><a class="tocitem" href="../toyfvfile/">Some code to test and play around</a></li></ul></li><li><a class="tocitem" href="../../showcase/">Intentions of use (EXAMPLES)</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual Voronoi</a></li><li class="is-active"><a href>Voronoi: Nodes and Geometry, Integrators</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Voronoi: Nodes and Geometry, Integrators</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/martinheida/HighVoronoi.jl/blob/main/docs/src/man/geometry.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Voronoi:-Nodes-and-Geometry,-Integrators"><a class="docs-heading-anchor" href="#Voronoi:-Nodes-and-Geometry,-Integrators">Voronoi: Nodes and Geometry, Integrators</a><a id="Voronoi:-Nodes-and-Geometry,-Integrators-1"></a><a class="docs-heading-anchor-permalink" href="#Voronoi:-Nodes-and-Geometry,-Integrators" title="Permalink"></a></h1><h2 id="differentnodegenerators"><a class="docs-heading-anchor" href="#differentnodegenerators">Nodes</a><a id="differentnodegenerators-1"></a><a class="docs-heading-anchor-permalink" href="#differentnodegenerators" title="Permalink"></a></h2><p>The most basic thing is the creation of a list of Points. We advise to use the following:</p><article class="docstring"><header><a class="docstring-binding" id="HighVoronoi.VoronoiNodes-Tuple{Matrix}" href="#HighVoronoi.VoronoiNodes-Tuple{Matrix}"><code>HighVoronoi.VoronoiNodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">VoronoiNodes(x::Matrix)</code></pre><p>also available in the forms</p><pre><code class="nohighlight hljs">VoronoiNodes(x::Vector{&lt;:Vector})
VoronoiNodes(x::Vector{&lt;:SVector})</code></pre><p>creates a list of points (as static vectors) from a matrix.</p><p><strong>Example: 100 Points in <span>$(0,1)^3$</span></strong></p><pre><code class="nohighlight hljs">data = rand(3,100)
points = VoronoiNodes(data)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinheida/HighVoronoi.jl/blob/217b7961e185679bfdb1c10cb1a9e77e7c7b4895/src/voronoinodes.jl#L1-L13">source</a></section></article><p>An advanced method is given by the following</p><pre><code class="language-julia hljs">VoronoiNodes(number_of_nodes::Int;density , 
            domain::Boundary=Boundary(), bounding_box::Boundary=Boundary(),
            criterium=x-&gt;true)</code></pre><p>When <code>density = x-&gt;f(x)</code> this will create a cloud of approximately <code>number_of_nodes</code> points inside the intersection of <code>domain</code> and <code>bounding_box</code> with spatial distribution <span>$f(x)$</span>. Note that both exact number and position of points are random.  The variable <code>bounding_box</code> allows to handle also the case when <code>domain</code> is unbounded. The intersection of <code>domain</code> and <code>bounding_box</code>  HAS TO BE bounded!</p><p>The following two pictures show first a distribution <code>density = x-&gt;sin(pi*2*x[1])^2*sin(pi*2*x[2])^2</code> and the second takes the same density squared.</p><p><img src="../../assets/images/voronoisin2.png" alt="sin^2 distribution of nodes"/></p><p><img src="../../assets/images/voronoisin4.png" alt="sin^4 distribution of nodes"/></p><h3 id="Single-Nodes"><a class="docs-heading-anchor" href="#Single-Nodes">Single Nodes</a><a id="Single-Nodes-1"></a><a class="docs-heading-anchor-permalink" href="#Single-Nodes" title="Permalink"></a></h3><p>To instatiate a single node (e.g. if you want to add a specific node to an existing list of nodes) use</p><pre><code class="language-julia hljs"># make [1.0, 0.0, 0.5] a valid Voronoi node
VoronoiNode([1.0, 0.0, 0.5])</code></pre><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><pre><code class="language-julia hljs"># This is an example to illustrate VoronoiNodes(number_of_nodes::Int;density)

## First some plot routine ############################
using Plots

function plot_2d_surface(nodes, values)
    # The following two lines are necessary in order for the plot to look nicely
    func = StepFunction(nodes,values)
    new_nodes = vcat([VoronoiNode([k/10,j*1.0]) for k in 0:10, j in 0:1], [VoronoiNode([j*1.0,k/10]) for k in 1:9, j in 0:1])
    append!(nodes,new_nodes)
    append!(values,[func(n) for n in new_nodes])
    
    x = [node[1] for node in nodes]
    y = [node[2] for node in nodes]
    
    p = Plots.surface(x, y, values, legend=false)
    xlabel!(&quot;X&quot;)
    ylabel!(&quot;Y&quot;)
    zlabel!(&quot;Values&quot;)
    title!(&quot;2D Surface Graph&quot;)
    
    display(p)
end
########################################################

## Now for the main part ################################

my_distribution = x-&gt;(sin(x[1]*π)*sin(x[2]*π))^4
my_nodes = VoronoiNodes(100,density = my_distribution, domain=cuboid(2,periodic=[]))
# you may compare the output to the following:
# my_nodes = VoronoiNodes(100,density = x-&gt;1.0, domain=cuboid(2,periodic=[]))
println(&quot;This generated $(length(my_nodes)) nodes.&quot;)
my_vals = map(x-&gt;sin(x[1]*π)^2*sin(x[2]*π),my_nodes)
plot_2d_surface(my_nodes,my_vals)</code></pre><h3 id="DensityRange"><a class="docs-heading-anchor" href="#DensityRange">DensityRange</a><a id="DensityRange-1"></a><a class="docs-heading-anchor-permalink" href="#DensityRange" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="HighVoronoi.DensityRange" href="#HighVoronoi.DensityRange"><code>HighVoronoi.DensityRange</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DensityRange{S}</code></pre><p>provides a rectangular grid of points in a <code>S</code>-dimensional space. It is initialized as follows:</p><pre><code class="nohighlight hljs">DensityRange(mr::AbstractVector{&lt;:Integer},range)</code></pre><p>Here, <code>range</code> can be of the following types:</p><ul><li><code>AbstractVector{Tuple{&lt;:Real,&lt;:Real}}</code>: It is assumed that each entry of <code>range</code> is a tuple <code>(a_i,b_i)</code> </li></ul><p>so the range is defined in the cuboid <code>(a_1,b_1)	imes...	imes(a_{dim},b_{dim})</code></p><p><code>mr</code> is assumed to have the same dimension as <code>range</code> and the interval <code>(a_i,b_i)</code> will be devided into <code>mr[i]</code> intervalls</p><ul><li><code>AbstractVector{&lt;:Real}</code>: if e.g. <code>range=[1.0,1.0]</code> this will be transferred to <code>range=[(0.0,1.0),(0.0,1.0)]</code> </li></ul><p>and the first instance of the method is called </p><ul><li><code>Float64</code>: <code>range</code> will be set <code>range*ones(Float64,length(mr))</code> and the second instance is called</li><li><code>Tuple{&lt;:Real,&lt;:Real}</code>: range will be set to an array of identical tuple entries and the first version is called</li></ul><p>Alternatively, one may call the following method:</p><pre><code class="nohighlight hljs">DensityRange(mr::Int,range,dimension=length(range))</code></pre><p>it is assumed that <code>range</code> is an array or tuple of correct length and <code>mr</code> is replaced by <code>mr*ones(Int64,dimension)</code>.  If range is not an array, then <code>dimension</code> has to be provided the correct value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinheida/HighVoronoi.jl/blob/217b7961e185679bfdb1c10cb1a9e77e7c7b4895/src/densityrange.jl#L1-L25">source</a></section></article><h2 id="Geometry"><a class="docs-heading-anchor" href="#Geometry">Geometry</a><a id="Geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Geometry" title="Permalink"></a></h2><p>The creation and storage of Voronoi geometry data is handled by the following class. </p><article class="docstring"><header><a class="docstring-binding" id="HighVoronoi.VoronoiGeometry" href="#HighVoronoi.VoronoiGeometry"><code>HighVoronoi.VoronoiGeometry</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VoronoiGeometry{T}</code></pre><p>This is the fundamental struct to store information about the generated Voronoi grid. The geometric data can be accessed using the type <code>VoronoiData</code>.  However, there is always the possibility to access the data also via the following fields:</p><ul><li>Integrator.Integral: stores the integrated values in terms of a <code>Voronoi_Integral</code></li><li>basic_mesh: stores the fundamental data of nodes and verteces. also stored in Integrator.Integral.MESH</li><li>nodes: direct reference to the nodes. Also provided in basic_mesh.nodes</li></ul><div class="admonition is-warning"><header class="admonition-header">Avoid direct access to the data</header><div class="admonition-body"><p>Accessing the data directly, that is without calling <code>VoronoiData</code>, is likely to cause confusion or to provide &quot;wrong&quot; information.  The reason is that particularly for periodic boundary conditions, the mesh is enriched by a periodization of the boundary nodes.  These nodes are lateron dropped by the VoronoiData-Algorithm.       </p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinheida/HighVoronoi.jl/blob/217b7961e185679bfdb1c10cb1a9e77e7c7b4895/src/geometry.jl#L1-L14">source</a></section></article><p>To create a Voronoi mesh it is most convenient to call either of the following methods</p><article class="docstring"><header><a class="docstring-binding" id="HighVoronoi.VoronoiGeometry-Tuple{}" href="#HighVoronoi.VoronoiGeometry-Tuple{}"><code>HighVoronoi.VoronoiGeometry</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">VoronoiGeometry(xs::Points,b::Boundary)</code></pre><p>This creates a Voronoi mesh from the points <code>xs</code> given e.g. as an array of <code>SVector</code> and a boundary <code>b</code> that might be constructed using  the commands in the Boundaries section.</p><p>You have the following optional commands:</p><ul><li><code>silence</code>: Suppresses output to the command line when <code>true</code>. The latter will speed up the algorithm by a few percent. default is <code>false</code>. </li><li><code>integrator</code>: can be either one of the following values:<ul><li><code>VI_GEOMETRY</code>: Only the basic properties of the mesh are provided: the verteces implying a List of neighbors of each node</li><li><code>VI_MONTECARLO</code>: Volumes, interface areas and integrals are calculated using a montecarlo algorithm.    This particular integrator comes up with the following additional paramters:<ul><li><code>mc_accurate=(int1,int2,int3)</code>: Montecarlo integration takes place in <code>int1</code> directions, over <code>int2</code>    volumetric samples (vor volume integrals only). It reuses the same set of directions <code>int3</code>-times to save memory allocation time.   Standard setting is: <code>(1000,100,20)</code>.</li></ul></li><li><code>VI_POLYGON</code>: We use the polygon structure of the mesh to calculate the exact values of interface area and volume. The    integral over functions is calculated using the values at the center, the verteces and linear interpolation between.  </li><li><code>VI_HEURISTIC</code>: When this integrator is chosen, you need to provide a fully computed Geometry including volumes and interface areas.   <code>VI_HEURISTIC</code> will then use this information to derive the integral values.</li><li><code>VI_HEURISTIC_MC</code>: This combines directly <code>VI_MONTECARLO</code> calculations of volumes and interfaces and calculates integral values    of functions based on those volumes and areas. In particular, it also relies on <code>mc_accurate</code>!</li></ul></li><li><code>integrand</code>: This is a function <code>f(x)</code> depending on one spatial variable <code>x</code> returning a <code>Vector{Float64}</code>.    The integrated values will be provided for each cell and for each pair of neighbors, i.e. for each interface</li><li><code>periodic_grid</code>: This will initiate a special internal routine to fastly create a periodic grid. Look up the section in the documentation. </li></ul><p><strong>With density distribution:</strong></p><pre><code class="nohighlight hljs">VoronoiGeometry(number::Int,b=Boundary();density, kwargs...)</code></pre><p>this call genertates a distribution of approsximately <code>number</code> nodes and generates a <code>VoronoiGeometry</code>. It takes as parameters all of the  above mentioned keywords (though <code>periodic_grid</code> makes no sense) and all keywords valid for a call of VoronoiNodes(number;domain=b,density=density, ....)  </p><p>In future versions, there will be an implementation of the parameter <code>cubic=true</code>, where the grid will be generated based on a distribution of &quot;cubic&quot; cells. In the current version there will be a warning that this is not yet implemented.</p><p><strong>Advanced methods</strong></p><pre><code class="nohighlight hljs">VoronoiGeometry(file::String)
VoronoiGeometry(VG::VoronoiGeometry)</code></pre><p>Loads a Voronoi mesh from the <code>file</code> or copies it from the original data <code>VG</code>. If <code>integrator</code> is not provided, it will use the original integrator stored to the file.  In the second case, if integrand is not provided explicitly, it will use <code>integrand = VG.integrand</code> as standard. Additionally it has the following options:</p><ul><li><code>_myopen=jldopen</code>: the method to use to open the file. See the section on <code>write_jld</code>.</li><li><code>vertex_storage</code>: Defines the way data is stored internally. standard is the most recent and most efficient method <code>DatabaseVertexStorage()</code>. Other options are the        <code>ReferencedVertexStorage()</code> which is slower but may be useful in low dimensions and the <code>ClassicVertexStorage()</code> which is fast for integration algorithms in        low dimensions and which was the first database structure underlying the computations. This parameter can of course only be set upon the very first creation of        the geometry and cannot be modified afterwards.</li><li><code>search_settings</code>: a <code>NamedTuple</code> mostly to provide <code>(method = ... ,threading = ...)</code> where <code>method</code> chooses the Raycast method and <code>threading</code> provides information        on the multithreading</li><li><code>offset</code>: See the section on <code>write_jld</code>.</li><li><code>integrate=false</code>: This will or will not call the integration method after loading/copying the data. Makes sense for using <code>VI_HEURISTIC</code> together with       <code>volume=true</code>, <code>area=true</code> and providing values for <code>integrand</code> and <code>integrand</code>. If <code>integrand != nothing</code> but <code>bulk==false</code> or <code>interface==false</code>        this parameter will internally be set <code>true</code>.</li><li><code>volume=true</code>: Load volume data from file</li><li><code>area=true</code>: Load interface area data from file</li><li><code>bulk=false</code>: Load integrated function values on the cell volumes from file. When set <code>true</code> and <code>integrand=f</code> is provided    the method  will compare the dimension of <code>f</code> and of the stored data. </li><li><code>interface=false</code>: Load integrated function values on the interfaces. When set <code>true</code> and <code>integrand=f</code> is provided    the method  will compare the dimension of <code>f</code> and of the stored data.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinheida/HighVoronoi.jl/blob/217b7961e185679bfdb1c10cb1a9e77e7c7b4895/src/geometry.jl#L58-L119">source</a></section></article><h2 id="integratoroverview"><a class="docs-heading-anchor" href="#integratoroverview">Integrators (overview)</a><a id="integratoroverview-1"></a><a class="docs-heading-anchor-permalink" href="#integratoroverview" title="Permalink"></a></h2><p>As discussed above there is a variety of integrators available to the user, plus some internal integrators that we will not discuss in this manual. The important integrators for the user are:</p><ul><li><code>VI_GEOMETRY</code>: Only the basic properties of the mesh are provided: the verteces and an implicit list of neighbors of each node. This is the fastes way to generate a <code>VoronoiGeometry</code></li><li><code>VI_MONTECARLO</code>: Volumes, interface areas and integrals are calculated using a montecarlo algorithm introduced by A. Sikorski in <code>VoronoiGraph.jl</code> and discussed in a forthcoming article by Heida, Sikorski, Weber. This particular integrator comes up with the following additional paramters:<ul><li><code>mc_accurate=(int1,int2,int3)</code>: Montecarlo integration takes place in <code>int1</code> directions, over <code>int2</code>        volumetric samples (vor volume integrals only). It reuses the same set of directions <code>int3</code>-times to save memory allocation time.       Standard setting is: <code>(1000,100,20)</code>.</li></ul></li><li><code>VI_POLYGON</code>: We use the polygon structure of the mesh to calculate the exact values of interface area and volume. The        integral over functions is calculated using the values at the center, the verteces and linear interpolation between. Also this method is to be discussed in the anounced article by Heida, Sikorski, Weber. </li><li><code>VI_FAST_POLYGON</code>: Even more precise than <code>VI_POLYGON</code>, very fast (50 secs for 500 nodes in 6D) but using a lot of memory. It is advised to use this integrator if you insists on accuracy over performance and if you have large RAM (advised &gt;=4GB of FREE RAM). On my personal machine with total 16GB RAM <code>VI_FAST_POLYGON</code> is by factor 15 faster than <code>VI_POLYGON</code> for 500 nodes in 6 dimensions and integrating <span>$x\rightarrow(x_1,x_2^2)$</span>.</li><li><code>VI_HEURISTIC</code>: When this integrator is chosen, you need to provide a fully computed Geometry including volumes and interface areas.       <code>VI_HEURISTIC</code> will then use this information to derive the integral values.</li><li><code>VI_HEURISTIC_MC</code>: This combines directly <code>VI_MONTECARLO</code> calculations of volumes and interfaces and calculates integral values        of functions based on those volumes and areas. In particular, it also relies on <code>mc_accurate</code>!</li></ul><p>It is important to have in mind that the polygon-integrator will be faster in low dimensions, whereas the Montecarlo integrator will outperform from 5 dimensions and higher. However, when volumes and integrals are to be calculated in high dimensions, the <code>VI_HEURISTIC_MC</code> is highly recommended, as it works with much less function evaluations than the <code>VI_MONTECARLO</code>. </p><h2 id="Storage:-JLD2"><a class="docs-heading-anchor" href="#Storage:-JLD2">Storage: JLD2</a><a id="Storage:-JLD2-1"></a><a class="docs-heading-anchor-permalink" href="#Storage:-JLD2" title="Permalink"></a></h2><p>you may use JLD2 to directly write a <code>VoronoiGeometry</code> or <code>VoronoiData</code> object to a file. It will be made sure that storing and reading data will be downward compatible in future. </p><h2 id="Storage:-deprecated-solution"><a class="docs-heading-anchor" href="#Storage:-deprecated-solution">Storage: deprecated solution</a><a id="Storage:-deprecated-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Storage:-deprecated-solution" title="Permalink"></a></h2><p>The following solution is still available for grids that have been created with <code>ClassicVertexStorage()</code>. However, it is not advised to use them.</p><article class="docstring"><header><a class="docstring-binding" id="HighVoronoi.write_jld-Tuple{}" href="#HighVoronoi.write_jld-Tuple{}"><code>HighVoronoi.write_jld</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The data can be stored using the <code>write_jld</code> method:</p><pre><code class="nohighlight hljs">write_jld(Geo::VoronoiGeometry,filename,offset=&quot;&quot;;_myopen=jldopen)
write_jld(Geo::VoronoiGeometry,file,offset=&quot;&quot;)</code></pre><p>stores the complete information of a VoronoiGeometry object to a file. This information can later be retrieved using the <code>VoronoiGeometry(file::String, args...)</code> function.</p><ul><li><code>Geo</code>: The Voronoi geometry object to be stored</li><li><code>filename</code>: name of file to store in</li><li><code>file</code>: A file given in a format supporting <code>write(file,&quot;tagname&quot;,content)</code> and <code>read(file,&quot;tagname&quot;,content)</code> </li><li><code>offset</code>: If several Geometry objects are to be stored in the same file, this will be the possibility to identify each one by a unique name. In particular, this is the key to store several objects in one single file.</li><li><code>_myopen</code>: a method that allows the syntax <code>_myopen(filename,&quot;w&quot;) do myfile ....... end</code>. By default the method uses the <code>JLD2</code> library as this (at the point of publishing this package) has the least problems with converting internal data structure to an output format.</li></ul><div class="admonition is-warning"><header class="admonition-header">Filname extension</header><div class="admonition-body"><p>If you want to use the default method, then the filename should end on <code>.jld</code>. Otherwise there might be confusion by the abstract built in julia loading algorithm.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinheida/HighVoronoi.jl/blob/217b7961e185679bfdb1c10cb1a9e77e7c7b4895/src/geometry.jl#L469-L485">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>load_Voronoi_info()</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="Extraction-of-VoronoiData-data-for-further-processing"><a class="docs-heading-anchor" href="#Extraction-of-VoronoiData-data-for-further-processing">Extraction of <code>VoronoiData</code> data for further processing</a><a id="Extraction-of-VoronoiData-data-for-further-processing-1"></a><a class="docs-heading-anchor-permalink" href="#Extraction-of-VoronoiData-data-for-further-processing" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HighVoronoi.VoronoiData" href="#HighVoronoi.VoronoiData"><code>HighVoronoi.VoronoiData</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Using the call </p><pre><code class="nohighlight hljs">data=VoronoiData(VG)</code></pre><p>some data of the Voronoi geometry <code>VG</code> is extracted and presented to the user in a convenient way that requires no knowledge of the complicated multilevel data structures of VoronoiGeometry. Once applied, the data set contains at least the following informations:</p><ul><li><code>nodes::Vector{T}</code>: The original nodes</li><li><code>vertices</code>: For each <code>i</code> this is an iterator over the vertices of cell <code>i</code></li><li><code>boundary_vertices</code>: This is an iterator of the form <code>edge =&gt; (base,direction,node)</code> where <code>edge</code> is a list of generators    of an infinite edge, <code>base</code> the start of the edge, <code>direction</code> the orientation and <code>node</code> is one additional generator that    defines <code>base</code> together with <code>edge</code>.</li></ul><p><strong>Additional Fields in <code>VoronoiData</code></strong></p><p>The set <code>data</code> contains the following additional information, which is <code>READ_ONLY</code> in the standard setting. The standard read-only datastructures are highly involved as the output values are generated on-the-fly from internal data in order to save memory. See below to extract easier editable data structures</p><ul><li><code>neighbors</code>: For each node <code>nodes[i]</code> the field <code>neighbors[i]</code> contains a sorted list of indeces of all neighboring cells.      Multiple appearence of the same node is possible on a periodic grid. </li><li><code>volume</code>: the volume for each node</li><li><code>area</code>: stores for each neighbor <code>neighbors[i][k]</code> of node <code>i</code> in <code>area[i][k]</code> the area of the interface.</li><li><code>bulk_integral</code>: the integral over the bulk of each cell. <code>bulk_integral[i]</code> is of type <code>AbstractVector{Float64}</code></li><li><code>interface_integral</code>: same as for <code>area</code> but with the integral values of the interface function. In paricular    <code>interface_integral[i][k]</code> is of type <code>AbstractVector{Float64}</code></li><li><code>orientations</code>: If the neighbors have been calculated by the integral algorithm, then for each <code>neighbor[i][k]</code> there is the    matched orientation from <code>i</code> to <code>k</code>. This is particularly useful in periodic geometries, where manual calculation of this vector is tricky. </li><li><code>boundary_nodes</code>: A collection iterating as <code>Tuple(generator_i,collection(boundary_index=&gt;mirrored_generator))</code>. In particular, if the cell of generator <code>i</code> touches    the boundary then <code>boundary_nodes</code> has a key <code>i</code>. The value is a dictionary that has for every boudnary plane &#39;k&#39; that is touched    the mirrored version of generator <code>i</code> (if <code>onboudary=false</code>) or its projection onto plane <code>k</code> (if <code>onboudary=true</code>).  </li><li><code>offset</code>: If <code>reduce_to_periodic=false</code>, this field will contain the number of internal nodes. The official nodes start from <code>offset+1</code>.</li><li><code>references</code>: If <code>offset&gt;0</code> then there exist a vectors <code>references</code> and <code>reference_shifts</code> of <code>length(offset)</code> stating    that <code>node[i]=node[references[i]]+reference_shifts[i]</code> for <code>i in 1:length(offset)</code>.</li><li><code>reference_shifts</code>: See the previous entry</li><li><code>boundary</code>: If <code>reduce_to_periodic=false</code> this contains the internal boundary that is used to compute the periodic structure.    Otherwise this contains the official boundary of the domain.</li><li><code>geometry</code>: For internal use, this is a reference to <code>VG</code>.</li></ul><div class="admonition is-warning"><header class="admonition-header">No request implies empty data field</header><div class="admonition-body"><p>If the above data fields where calculated by the integration algorithm, they have no values assigned for <code>1:offset</code>.  On the other hand, you may check this with <code>isassigned</code>. Also if <code>reduce_to_periodic=false</code>, the values for indices &lt;= offset are not assigned.</p></div></div><p><strong>Named Arguments</strong></p><p>The call of <code>VoronoiData(VG)</code> provides the following options:</p><ul><li><code>getFIELD</code>: replace <code>FIELD</code> with any of the above names except <code>geometry</code> to obtain a hard copy of the respective data that is detached from the internal data structure and can be modified or stored separately. </li><li><code>copyall=true</code>: corresponds to setting <code>getFIELD=true</code>  for every <code>FIELD</code>.</li><li><code>reduce_to_periodic=true</code>: This hides all internal data generated from the periodization. It is highly advised to set this option to <code>true</code>   as the user will then only see the periodic mesh with no information overhead.</li><li><code>onboundary=false</code>: refer to <code>boundary_nodes</code> above </li><li><code>sorted=true</code>: During the reduction of the internal pseudo periodic mesh to the fully periodic output, the neighbors (jointly with their respective properties) get sorted by their numbers. This is only possible if <code>getarea</code>,<code>getneighbors</code> and <code>getinterfaceintegral</code> are <code>true</code>. Otherwise it will be ignored</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinheida/HighVoronoi.jl/blob/217b7961e185679bfdb1c10cb1a9e77e7c7b4895/src/voronoidata.jl#L494-L542">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../workflowmesh/">« Workflow</a><a class="docs-footer-nextpage" href="../raycast/">Voronoi: Raycast methods »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 12 September 2024 10:07">Thursday 12 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
