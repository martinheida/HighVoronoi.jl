<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Finite Volume Tutorial · HighVoronoi.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://martinheida.github.io/HighVoronoi.jl/man/finitevolume/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">HighVoronoi.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual Voronoi</span><ul><li><a class="tocitem" href="../short/">Examples Voronoi Generation</a></li><li><a class="tocitem" href="../workflowmesh/">Workflow</a></li><li><a class="tocitem" href="../geometry/">Voronoi: Nodes and Geometry, Integrators</a></li><li><a class="tocitem" href="../raycast/">Voronoi: Raycast methods</a></li><li><a class="tocitem" href="../multithread/">Multithreading</a></li><li><a class="tocitem" href="../database/">Voronoi: Database Structure</a></li><li><a class="tocitem" href="../improving/">Improving Voronoi meshes for FV </a></li><li><a class="tocitem" href="../boundaries/">Boundaries</a></li><li><a class="tocitem" href="../advanced/">Advanced Options</a></li><li><a class="tocitem" href="../periodic/">Highspeed periodic geometries</a></li><li><a class="tocitem" href="../refine/">Refinement and Substitution of Subdomains</a></li><li><a class="tocitem" href="../projection/">Projection operators</a></li><li><a class="tocitem" href="../metapost/">Graphical Output in 2D and 3D</a></li><li><a class="tocitem" href="../errors/">Sources of errors and loss in performance</a></li></ul></li><li><span class="tocitem">Manual Finite Volume</span><ul><li><a class="tocitem" href="../finitevolumeexample/">Finite Volume Examples</a></li><li><a class="tocitem" href="../workflowfv/">Workflow in FV</a></li><li class="is-active"><a class="tocitem" href>Finite Volume Tutorial</a><ul class="internal"><li><a class="tocitem" href="#The-VoronoiFVProblem-dataset"><span>The <code>VoronoiFVProblem</code> dataset</span></a></li><li><a class="tocitem" href="#myVoronoiFVProblem"><span>Examples for the <code>VoronoiFVProblem</code></span></a></li><li><a class="tocitem" href="#parameter_names"><span>Full list of LOCAL PARAMETER names</span></a></li><li><a class="tocitem" href="#Extracting-the-full-FV-linear-equations-including-BOUNDARY-CONDITIONS"><span>Extracting the full FV linear equations including BOUNDARY CONDITIONS</span></a></li></ul></li><li><a class="tocitem" href="../functions/">Functions</a></li><li><a class="tocitem" href="../integrals/">(More) Integrals</a></li><li><a class="tocitem" href="../toyfvfile/">Some code to test and play around</a></li></ul></li><li><a class="tocitem" href="../../showcase/">Intentions of use (EXAMPLES)</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual Finite Volume</a></li><li class="is-active"><a href>Finite Volume Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Finite Volume Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/martinheida/HighVoronoi.jl/blob/main/docs/src/man/finitevolume.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="The-Finite-Volume-functionality"><a class="docs-heading-anchor" href="#The-Finite-Volume-functionality">The Finite Volume functionality</a><a id="The-Finite-Volume-functionality-1"></a><a class="docs-heading-anchor-permalink" href="#The-Finite-Volume-functionality" title="Permalink"></a></h1><p>HighVoronois most important feature to the user is the automatic generation of a linear system </p><p class="math-container">\[\mathbb A\,\mathbf u = \mathbf b\]</p><p>from the PDE-Problem</p><p class="math-container">\[-\nabla\cdot\left(\kappa\nabla u + \kappa u\nabla V\right) = f\,.\]</p><p>More abstract, the class <code>VoronoiFVProblem</code> discretizes the problem </p><p class="math-container">\[\nabla\cdot J(u) = f\,,\tag{Flux-Form}\]</p><p>in the bulk (in the domain) where <span>$J(u)$</span> is a linear differential operator in <span>$u$</span> and <span>$f$</span> is a given right hand side. Furthermore, the method can account for periodic, Dirichlet and Neumann boundary conditions, also all at once (on different parts of the boundary).</p><p>The function <code>linearVoronoiFVProblem</code> then adds particular boundary conditions to the abstract discretization in <code>VoronoiFVProblem</code> and returns a linear equation to be solved.</p><h2 id="The-VoronoiFVProblem-dataset"><a class="docs-heading-anchor" href="#The-VoronoiFVProblem-dataset">The <code>VoronoiFVProblem</code> dataset</a><a id="The-VoronoiFVProblem-dataset-1"></a><a class="docs-heading-anchor-permalink" href="#The-VoronoiFVProblem-dataset" title="Permalink"></a></h2><div class="admonition is-info"><header class="admonition-header">Summary</header><div class="admonition-body"><p>The <code>VoronoiFVProblem</code> is conceptually a black box into which the user throws a list of nodes and a boundary (or a ready-to-use <code>VoronoiGeometry</code>) as well as a description of <span>$J$</span> and <span>$f$</span>. Internally, the black box computes the discrete coefficients of <span>$J$</span> and <span>$f$</span> and stores them in a way that allows efficient computation of the matrix and right-hand side for given boundary conditions. </p><p>We advise the user to first jump to the <a href="#myVoronoiFVProblem">examples for calculations of fluxes</a> below and afterwards study the following abstract description of <code>VoronoiFVProblem</code>.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="HighVoronoi.VoronoiFVProblem-Tuple{}" href="#HighVoronoi.VoronoiFVProblem-Tuple{}"><code>HighVoronoi.VoronoiFVProblem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">VoronoiFVProblem(Geo::VoronoiGeometry; parent = nothing)  # first variant
VoronoiFVProblem(points, boundary; integrator = VI_POLYGON, kwargs...)      # second variant</code></pre><p>Generates Finite Volume data for fluxes and right hand sides given either a <code>VoronoiGeometry</code> object or a set of points and a boundary,  which will serve to internally create a <code>VoronoiGeometry</code>. Allows for the following parameters:</p><ul><li><p><code>kwargs...</code> : arguments that are not listed explicitly below will be passed to the VoronoiGeometry. <code>integrand</code> will be overwritten. </p></li><li><p><code>parent</code>: If <code>parent</code> is generated from <code>Geo_p</code> and <code>Geo</code> is a refined version of <code>Geo_p</code> this parameter will initiate the calculation    of an <span>$L^{1}$</span> projection operator between the spaces of piecewise constant functions on the respective Voronoi Tessellations.  </p></li><li><p><code>discretefunctions=nothing</code> : A named tuple of form <code>(alpha=x-&gt;norm(x),f=x-&gt;-x,)</code>. Will be evaluated pointwise.</p></li><li><p><code>integralfunctions=nothing</code> : A named tuple of form <code>(alpha=x-&gt;norm(x),f=x-&gt;-x,)</code>. It will make the algoritm calculate the integrals   over the given functions or it will associate values to the list of functions based on integrated data present in <code>Geo</code></p></li><li><p><code>fluxes=nothing</code> : this is assumed to be named tuple, e.g. like the following:</p><pre><code class="nohighlight hljs">  fluxes = (alpha = f1, beta = f2, eta = f3, zeta = f4, )</code></pre><p>and every of the given fluxes <code>alpha</code>, <code>beta</code>, <code>eta</code>, <code>zeta</code>, has the following structure:   It is one single flux-function  accessing the following named data (see also <a href="#parameter_names">here in the Documentation</a>):</p><pre><code class="nohighlight hljs">  x_i, x_j, para_i, para_j, para_ij, mass_i, mass_j, mass_ij, normal</code></pre><p>and returning two values. Functions <code>f1</code>, <code>f2</code> ... should hence be defined similar to the  following:</p><pre><code class="nohighlight hljs">  function f1(;x_i,x_j,para_ij, kwargs...)
      # some code
      return something_i, something_j
  end</code></pre><p>Refer to the examples in the documentation.</p></li></ul><div class="admonition is-info"><header class="admonition-header">standard settings</header><div class="admonition-body"><p>if the array of Neumann-planes is not provided, the standard list given in <code>boundary</code> resp. the boundary in <code>Geo</code> will be used. </p></div></div><ul><li><p><code>rhs_functions=nothing</code>: same as for fluxes. However, functions can only access the variables</p><pre><code class="nohighlight hljs">  x_i, mass_i, para_i,</code></pre></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinheida/HighVoronoi.jl/blob/31af805d5bef015f95188aae27204f4a142002ca/src/finitevolume.jl#L150-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighVoronoi.VoronoiFVProblem" href="#HighVoronoi.VoronoiFVProblem"><code>HighVoronoi.VoronoiFVProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct VoronoiFVProblem{...}</code></pre><p>after initialization the struct contains the following information:</p><ul><li><code>Geometry</code> : a <code>VoronoiGeometry</code> containing mesh and integrated information</li><li><code>Coefficients</code> : Not advised to be accessed by user </li><li><code>Parent</code> : Not advised to be accessed by user</li><li><code>projection_down</code> : Not advised to be accessed by user</li><li><code>projection_up</code> : Not advised to be accessed by user</li><li><code>parameters</code> : Not advised to be accessed by user</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinheida/HighVoronoi.jl/blob/31af805d5bef015f95188aae27204f4a142002ca/src/finitevolume.jl#L9-L19">source</a></section></article><h2 id="myVoronoiFVProblem"><a class="docs-heading-anchor" href="#myVoronoiFVProblem">Examples for the <code>VoronoiFVProblem</code></a><a id="myVoronoiFVProblem-1"></a><a class="docs-heading-anchor-permalink" href="#myVoronoiFVProblem" title="Permalink"></a></h2><h3 id="Content"><a class="docs-heading-anchor" href="#Content">Content</a><a id="Content-1"></a><a class="docs-heading-anchor-permalink" href="#Content" title="Permalink"></a></h3><ol><li><a href="#examplecreating">Creating a <code>VoronoiFVProblem</code></a></li><li><a href="#examplefluxes">Calculating fluxes and rigthand side</a></li><li><a href="#FVfromGeo">Creating a VoronoiFVProblem from a VoronoiGeometry</a></li><li><a href="#examplestoragedata">Internal storage of data (For very deep coding only)</a></li></ol><h3 id="examplecreating"><a class="docs-heading-anchor" href="#examplecreating">Creating a <code>VoronoiFVProblem</code> and calculating some integrals...</a><a id="examplecreating-1"></a><a class="docs-heading-anchor-permalink" href="#examplecreating" title="Permalink"></a></h3><p>We create a first instance of <code>VoronoiFVProblem</code>. The following code calculates a <code>VoronoiGeometry</code> for the given <code>data</code> of random points. It furthermore calculates the integral of <code>integralfunctions</code> and pointwise evaluations of <code>discretefunctions</code>. The latter are not stored but will be internally used for calculations of fluxes or right hand sides (in a later example). To get familiar with the data structure try out the following:</p><pre><code class="language-julia hljs">using LinearAlgebra

function myrhs(;para_i,mass_i,kwargs...)
    return para_i[:alpha]*mass_i
end

function test_FV(dim,nop)
    data = rand(dim,nop)
    xs = VoronoiNodes(data)
    cube = cuboid(dim,periodic=[1])
    VoronoiFVProblem(xs,cube, discretefunctions = (alpha=x-&gt;sum(abs,x),), 
                              rhs_functions = (F=myrhs,) )
end

vfvp = test_FV(2,4)
println(vfvp.Coefficients.functions)</code></pre><p>The algorithm internally calculutes for each of the four random cells the quantity <span>$\alpha(x_i)*m_i$</span>, where <span>$m_i$</span> is the mass of cell <span>$i$</span>. The output hence looks like the following:</p><pre><code class="nohighlight hljs">(F = [0.8899968951003052, 1.6176576528551534, 1.2484331005796414, 0.9868594550457225],)</code></pre><ul><li>At a later stage, we will of course not directly work with <code>vfvp.Coefficients.functions</code>...</li><li><code>myrhs</code> could addionally work with <code>x_i</code>, the coordinates of <span>$x_i$</span></li></ul><h3 id="examplefluxes"><a class="docs-heading-anchor" href="#examplefluxes">Calculating fluxes and rigthand side</a><a id="examplefluxes-1"></a><a class="docs-heading-anchor-permalink" href="#examplefluxes" title="Permalink"></a></h3><p>We write <span>$i\sim j$</span> if the Voronoi cells of the nodes <span>$x_i$</span> and <span>$x_j$</span> are neighbored. Then the discrete version of </p><p class="math-container">\[\nabla\cdot J(u) = f\,,\tag{Flux-Form}\]</p><p>in the node <span>$x_i$</span> is </p><p class="math-container">\[\sum_{j\sim i} J_{i,j}(u) = F_i\,.\tag{Flux-Form-discrete}\]</p><div class="admonition is-info"><header class="admonition-header">Indeces $i$ and $j$</header><div class="admonition-body"><p>In the text and in the code hereafter <span>$i$</span> is the current cell and <span>$j$</span> is either a neighbor or an index of a part of the boundary.</p></div></div><p>More precisely, let <span>$f$</span> and <span>$\kappa$</span> be scalar functions. If <span>$m_i$</span>  is the mass of cell <span>$i$</span> and <span>$m_{ij}$</span> is the mass of the interface between cells <span>$i$</span> and <span>$j$</span> and <span>$f_i=f(x_i)$</span> or <span>$f_i=m_i^{-1}\int_{cell_i}f$</span> and similarly for <span>$\kappa$</span> we find the following possible discretization of Fick&#39;s law:</p><p class="math-container">\[J(u)=-\kappa \nabla u \qquad\leftrightarrow\qquad J_{ij}(u)\,=\,-\frac{m_{ij}}{h_{ij}}\sqrt{\kappa_i\kappa_j}(u_j-u_i)\,=\,+\frac{m_{ij}}{h_{ij}}\sqrt{\kappa_i\kappa_j}(u_i-u_j)\,,\]</p><p>with the right hand side </p><p class="math-container">\[F_i=m_i f_i\,.\]</p><p>We can rewrite <span>$J_{ij}(u)$</span> in the following form:</p><p class="math-container">\[J_{ij}(u)=\frac{m_{ij}}{h_{ij}}\sqrt{\kappa_i\kappa_j}u_i-\frac{m_{ij}}{h_{ij}}\sqrt{\kappa_i\kappa_j}u_j=p_{ij,i}u_i - p_{ij,j}u_j\]</p><div class="admonition is-info"><header class="admonition-header">purpose of `VoronoiFVProblem`</header><div class="admonition-body"><p>The purpose of <code>VoronoiFVProblem</code> is to calculate <span>$p_{ij,i}$</span> and <span>$p_{ij,j}$</span> using <code>fluxes=...</code> as well as <span>$F_i$</span> using <code>rhs_functions</code>.</p></div></div><p>We implement the above discretization in <code>myflux_1</code> and an alternative replacing <span>$\sqrt{\kappa_i\kappa_j}$</span> by an average over the joint interface of cells <span>$i,j$</span> in <code>myflux_2</code>. Here, <span>$\alpha$</span> is evaluated pointwise in the middle of each cell / interface, while <span>$\kappa$</span> is averaged over cells and interfaces.</p><pre><code class="language-julia hljs">using LinearAlgebra
using SpecialFunctions

function myflux_1(;para_i,para_j,mass_ij,normal,kwargs...) 
    # kwargs... collects all additional parameters which are not used in the current function.
    weight = norm(normal)^(-1) * mass_ij * sqrt(para_i[:kappa]*para_j[:kappa])
    return weight, weight
end

function myflux_2(;para_ij,mass_ij,normal,kwargs...)
    # kwargs... collects all additional parameters which are not used in the current function.
    weight = norm(normal)^(-1) * mass_ij * para_ij[:kappa]
    return weight, weight
end

myRHS(;para_i,mass_i,kwargs...) = mass_i * para_i[:f] 


function test_FV(dim,nop)
    data = rand(dim,nop)
    xs = VoronoiNodes(data)
    cube = cuboid(dim,periodic=[],neumann=[1,-1]) # cube with preset Neumann BC in dimension 1 and Dirichlet BC all other dimensions
    VoronoiFVProblem(xs,cube, discretefunctions = (f=x-&gt;sin(2*pi*x[1]),), # evaluate f pointwise
                              integralfunctions = (kappa=x-&gt;1.0+norm(x)^2,), # calculate averages of kappa over cells and interfaces
                              fluxes = ( j1 = myflux_1, j2 = myflux_2, ),
                              rhs_functions = (F = myRHS,) )
end

test_FV(2,10)</code></pre><h3 id="FVfromGeo"><a class="docs-heading-anchor" href="#FVfromGeo">Creating a VoronoiFVProblem from a VoronoiGeometry</a><a id="FVfromGeo-1"></a><a class="docs-heading-anchor-permalink" href="#FVfromGeo" title="Permalink"></a></h3><p>It is also possible to write the following less compact code for <code>test_FV(dim,nop)</code>. Though it may seem weird to do the extra effort, remember that mesh generation in high dimensions is very time consuming. Hence this approach could be usefull to set up a high dimensional problem from a formerly calculated grid.</p><pre><code class="language-julia hljs">function test_FV(dim,nop)
    data = rand(dim,nop)
    xs = VoronoiNodes(data)
    cube = cuboid(dim,periodic=[],neumann=[1,-1]) 
    vg = VoronoiGeometry(xs, cube, integrator=HighVoronoi.VI_POLYGON, 
                                   integrand=x-&gt;1.0+norm(x)^2)
    vfvp = VoronoiFVProblem(vg, discretefunctions = (f=x-&gt;sin(2*pi*x[1]),), 
                              integralfunctions = (kappa=x-&gt;0.0,), 
                              fluxes = ( j1 = myflux_1, j2 = myflux_2, ),
                              rhs_functions = (F = myRHS,) )
end</code></pre><p>The instatiation of <code>vg</code> calculates all integrals of <code>x-&gt;1.0+norm(x)^2</code>. The instatiation of <code>vfvp</code> cimply uses the values stored in <code>vg</code> and &quot;rebrands&quot; them as <code>:kappa</code>.</p><div class="admonition is-success"><header class="admonition-header">Compatibility of dimension</header><div class="admonition-body"><p>The dimension of <code>integrand</code> in the instatiation of <code>vg</code> can be greater or equal than the summed up dimension of all <code>integralfunctions</code>, but not less!! The definition of <code>:kappa</code> in <code>VoronoiFVProblem(...)</code> in the above example does not matter as all values have been calculated before. We strongly advise to have a look at the &quot;intentions of use&quot; section. </p></div></div><h3 id="examplestoragedata"><a class="docs-heading-anchor" href="#examplestoragedata">Internal storage of data</a><a id="examplestoragedata-1"></a><a class="docs-heading-anchor-permalink" href="#examplestoragedata" title="Permalink"></a></h3><p>In the <a href="#examplefluxes">second example</a>, try out the following code:</p><pre><code class="language-julia hljs">vfvp = test_FV(2,4)
println(vfvp.Coefficients.functions)
println(vfvp.Coefficients.fluxes)
println(vfvp.Coefficients.rows)
println(vfvp.Coefficients.cols)</code></pre><p>The fields <code>rows</code> and <code>cols</code> of <code>vfvp</code> store the row and coloumn coordinates of potentially non-zero entries of a sparse flux matrix. The arrays stored in <code>fluxes</code> correspondingly store the non-zero values. It is thus possible to directly create <code>SparseMatrix</code> instances from this data. However, this would not yet properly account for boundary conditions. </p><h2 id="parameter_names"><a class="docs-heading-anchor" href="#parameter_names">Full list of LOCAL PARAMETER names</a><a id="parameter_names-1"></a><a class="docs-heading-anchor-permalink" href="#parameter_names" title="Permalink"></a></h2><p>Functions like <code>myflux_1</code> and <code>myflux_2</code> in <a href="#examplecreating">this example here</a> are evaluated on interfaces between neighboring cells or on the boundary and can take the following arguments</p><ul><li><code>x_i</code>: coordinates of the current node <span>$i$</span> </li><li><code>x_j</code>: coordinates of the current neighbor <span>$j$</span> (in case this is an actually existing cell) or the coordinates of a point on the boundary (if this is part of the boundary, see <code>onboundary</code>)</li><li><code>para_i</code> and <code>para_j</code>: a named tuple container of all pointwise evaluated (<code>discretefunctions</code>) or averaged (<code>integralfunctions</code>) functions for either cell <span>$i$</span> and <span>$j$</span> respectively.</li><li><code>para_ij</code>: same for the interface</li><li><code>mass_i</code> and <code>mass_j</code>: if of cell <span>$i$</span> and <span>$j$</span></li><li><code>mass_ij</code>: the mass of the interface</li><li><code>normal</code>: Something like <span>$x_j-x_i$</span>. However, in case of periodic nodes with cells &quot;crossing the periodic boundary&quot;, it typically holds <span>$x_i+\mathrm{normal}\not=x_j$</span> but <span>$(x_i+\mathrm{normal})$</span> is a periodic shift of <span>$x_j$</span>. In any case, it is the correct outer normal vector with length of the &quot;periodized distance&quot;. </li><li><code>onboundary</code>: is true if and only if <code>x_j</code> is a point on the boudary.   </li></ul><p>Righthand side functions (bulk functions) like <code>myRHS</code> are evaluated on nodes have only access to </p><ul><li><code>x_i</code></li><li><code>para_i</code></li><li><code>mass_i</code></li></ul><div class="admonition is-danger"><header class="admonition-header"></header><div class="admonition-body"><ul><li>If a function <code>f</code> is not provided to either <code>discretefunctions</code> or <code>integralfunctions</code> the call <code>para_i[:f]</code> and alike will cause an error message.</li><li>Every name can be used only ONCE. Particularly, a name <code>f</code> CANNOT be used both inside <code>discretefunctions</code> AND <code>integralfunctions</code>.</li></ul></div></div><h2 id="Extracting-the-full-FV-linear-equations-including-BOUNDARY-CONDITIONS"><a class="docs-heading-anchor" href="#Extracting-the-full-FV-linear-equations-including-BOUNDARY-CONDITIONS">Extracting the full FV linear equations including BOUNDARY CONDITIONS</a><a id="Extracting-the-full-FV-linear-equations-including-BOUNDARY-CONDITIONS-1"></a><a class="docs-heading-anchor-permalink" href="#Extracting-the-full-FV-linear-equations-including-BOUNDARY-CONDITIONS" title="Permalink"></a></h2><ol><li><a href="#lin_eq_background">Theoretical background</a></li><li><a href="#linear_vor_prob"><code>linearVoronoiFVProblem</code></a></li><li><a href="#no_dirichlet">No Dirichlet condition: Ambiguity</a></li><li><a href="#lin_vor_prob_ex">Examples</a></li></ol><h3 id="lin_eq_background"><a class="docs-heading-anchor" href="#lin_eq_background">Background</a><a id="lin_eq_background-1"></a><a class="docs-heading-anchor-permalink" href="#lin_eq_background" title="Permalink"></a></h3><p>To understand how boundary conditions are implemented in the <code>HighVoronoi</code> package, multiply equation (Flux-Form) with some function <span>$\varphi$</span> and use integration by parts to obtain </p><p class="math-container">\[-\int_{domain}J\cdot\nabla\varphi=\int_{domain}f\,\varphi-\int_{boundary}\varphi\,J\cdot \nu\]</p><p>where <span>$\nu$</span> is the outer normal vector. </p><p>Furthermore, assume we want to prescribe <span>$u=u_0$</span> on some part of the boundary. We can write <span>$u=\tilde u +u_0$</span> where <span>$\tilde u$</span> has boundary value <span>$0$</span>. Then (Flux-Form-discrete) reads</p><p class="math-container">\[\sum_{j\sim i} J_{i,j}(\tilde u + u_0) = F_i\,.\]</p><p>However, since we work in a discrete setting, we can make the following assumptions:</p><div class="admonition is-info"><header class="admonition-header">Assumptions on boundary data</header><div class="admonition-body"><ul><li>The function <span>$u_0$</span> is a discrete function taking value <span>$0$</span> on every node inside the domain, but might be non-zero on the boundary. <span>$\tilde u$</span> is a discrete function which is zero on all Dirichlet-parts of the boundary. </li><li>The function <code>J_0</code> is a discrete function on the boundary which mimics <span>$J_0=J\cdot\nu$</span>. In particular, we think of <code>J_0(i,j)=m_ij*J_0(x_ij)</code>. </li></ul></div></div><h3 id="linear_vor_prob"><a class="docs-heading-anchor" href="#linear_vor_prob"><code>linearVoronoiFVProblem</code></a><a id="linear_vor_prob-1"></a><a class="docs-heading-anchor-permalink" href="#linear_vor_prob" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="HighVoronoi.linearVoronoiFVProblem-Tuple{VoronoiFVProblem}" href="#HighVoronoi.linearVoronoiFVProblem-Tuple{VoronoiFVProblem}"><code>HighVoronoi.linearVoronoiFVProblem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">linearVoronoiFVProblem(vd::VoronoiFVProblem;flux)</code></pre><p>Takes a <code>VoronoiFVProblem</code> and a <code>flux::Symbol</code> and creates a linear problem. <code>flux</code> has to refer to a flux created in <code>vd</code>.</p><p><strong>Optional arguments</strong></p><ul><li><code>rhs</code>: a <code>Symbol</code> referring to one of the <code>rhs_functions</code> or a vector of <code>Float64</code> of the same length as the number of nodes.    If not provided, the system assumes <code>rhs=zeros(Float64,number_of_nodes)</code>.</li><li><code>Neumann</code>: Can be provided in the forms <ul><li><code>(Int,Function,Int[.],Function,(Int[.],Function),...)</code>. Every <code>Function</code> depends on <code>(;kwargs...)</code> </li></ul>and represents <span>$J*ν$</span> on a single boundary plane <code>Int</code> or multiple planes <code>Int[.]</code>.<ul><li><code>Function</code> then it takes the Neumann boundaries given by the definition of the boundary of the domain, unless nothing is reinterpreted as Dirichlet boundary.</li></ul></li><li><code>Dirichlet</code>: Can be provided in the form <code>(Int,Function,Int[.],Function,(Int[.],Function),...)</code>. Every <code>Function</code> depends on <code>(;kwargs...)</code>    and represents <span>$u_0$</span> on a single boundary plane <code>Int</code> or multiple planes <code>Int[.]</code>.</li></ul><div class="admonition is-info"><header class="admonition-header">`FVevaluate_boundary`</header><div class="admonition-body"><p>Use <code>FVevaluate_boundary(f)</code> if you simply want <code>f</code> to be evaluated pointwise at the boundary nodes.</p></div></div><div class="admonition is-info"><header class="admonition-header">Standard boundary conditions and consistency</header><div class="admonition-body"><p>The algorithm will take zero Neumann  resp. zero Dirichlet as standard in case no other information is provided by the user. However, it is the  users responsibility to make sure there are no double specifications given in <code>Neumann</code> and <code>Dirichlet</code>.</p></div></div><p><strong>Return values</strong></p><pre><code class="nohighlight hljs">rows, cols, vals, rhs = linearVoronoiFVProblem(vd::VoronoiFVProblem;flux,kwargs...)</code></pre><ul><li><code>rows, cols, vals</code> are the row and coloumn indeces of values. Create e.g. <code>A=sparse(rows,cols,vals)</code> and sovle <span>$A*u=rhs$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinheida/HighVoronoi.jl/blob/31af805d5bef015f95188aae27204f4a142002ca/src/finitevolume.jl#L386-L411">source</a></section></article><h3 id="no_dirichlet"><a class="docs-heading-anchor" href="#no_dirichlet">No Dirichlet condition: Ambiguity</a><a id="no_dirichlet-1"></a><a class="docs-heading-anchor-permalink" href="#no_dirichlet" title="Permalink"></a></h3><p>In case the boundary conditions consist only of periodic and/or Neumann conditions, the solution is unique only up to a constant. This is taken into account by providing <code>linearVoronoiFVProblem</code> with the parameter</p><ul><li><code>enforcement_node=1</code>: This picks out a node where the solution is forced to be <span>$0$</span>. If the user wants another condition, such as average value <span>$0$</span>, this can be achieved after solving the linear problem, as the library provides enough tools to calculate the respective integrals in the aftermath.  </li></ul><h3 id="lin_vor_prob_ex"><a class="docs-heading-anchor" href="#lin_vor_prob_ex">Examples</a><a id="lin_vor_prob_ex-1"></a><a class="docs-heading-anchor-permalink" href="#lin_vor_prob_ex" title="Permalink"></a></h3><p>Let us look at the following example:</p><pre><code class="language-julia hljs">    using SparseArrays

    myrhs(;para_i,mass_i,kwargs...) = mass_i*para_i[:alpha]

    function myflux_2(;para_ij,mass_ij,normal,kwargs...)
        weight = norm(normal)^(-1) * mass_ij * para_ij[:alpha]
        return weight, weight
    end

    xs = VoronoiNodes(rand(2,6))
    cube = cuboid(2,periodic=[1])
    vfvp = VoronoiFVProblem(xs, cube, discretefunctions = (alpha=x-&gt;sum(abs,x),), 
                                      rhs_functions=(F=myrhs,), 
                                      fluxes=(j1=myflux_2,) )
    har = FVevaluate_boundary(x-&gt;0.0) # turn a function into the format HighVoronoi needs
    one = FVevaluate_boundary(x-&gt;1.0)
    r,c,v,f = linearVoronoiFVProblem(vfvp, flux = :j1, Neumann = (3,har), Dirichlet = (4,one))
    A = sparse(r,c,v) # a sparse matrix with rows `r`, coloumns `c` and values `v`
    # solution_u = somelinearsolver(A,f)</code></pre><p>As we see, the output of the algorithm is a matrix <code>A</code> and a right hand side <code>f</code> which can be plugged into a linear solver method from some suitable package.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../workflowfv/">« Workflow in FV</a><a class="docs-footer-nextpage" href="../functions/">Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 11 September 2024 12:07">Wednesday 11 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
