<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Some code to test and play around · HighVoronoi.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://martinheida.github.io/HighVoronoi.jl/man/toyfvfile/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">HighVoronoi.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual Voronoi</span><ul><li><a class="tocitem" href="../short/">Examples Voronoi Generation</a></li><li><a class="tocitem" href="../workflowmesh/">Workflow</a></li><li><a class="tocitem" href="../geometry/">Voronoi: Nodes and Geometry, Integrators</a></li><li><a class="tocitem" href="../boundaries/">Boundaries</a></li><li><a class="tocitem" href="../advanced/">Advanced Options</a></li><li><a class="tocitem" href="../periodic/">Highspeed periodic geometries</a></li><li><a class="tocitem" href="../refine/">Refinement and Substitution of Subdomains</a></li><li><a class="tocitem" href="../projection/">Projection operators</a></li><li><a class="tocitem" href="../metapost/">2D-Output using MetaPost</a></li><li><a class="tocitem" href="../errors/">Sources of errors and loss in performance</a></li></ul></li><li><span class="tocitem">Manual Finite Volume</span><ul><li><a class="tocitem" href="../finitevolumeexample/">Finite Volume Examples</a></li><li><a class="tocitem" href="../workflowfv/">Workflow in FV</a></li><li><a class="tocitem" href="../finitevolume/">Finite Volume Tutorial</a></li><li><a class="tocitem" href="../functions/">Functions</a></li><li><a class="tocitem" href="../integrals/">(More) Integrals</a></li><li class="is-active"><a class="tocitem" href>Some code to test and play around</a></li></ul></li><li><a class="tocitem" href="../../showcase/">Intentions of use (EXAMPLES)</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual Finite Volume</a></li><li class="is-active"><a href>Some code to test and play around</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Some code to test and play around</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/martinheida/HighVoronoi.jl/blob/main/docs/src/man/toyfvfile.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="toyfile"><a class="docs-heading-anchor" href="#toyfile">Some code to test and play around</a><a id="toyfile-1"></a><a class="docs-heading-anchor-permalink" href="#toyfile" title="Permalink"></a></h1><p>The following code works as it is. It takes as parameters a function <span>$u$</span>, a field <span>$\kappa$</span> and the dimension <code>dim</code>. It then calculates <span>$-\nabla(\kappa\nabla u)=:f$</span> and creates discrete versions of <span>$\kappa$</span> and <span>$f$</span> to generate a numerical solution <span>$u$</span>. Finally it compares the numerical and the exact solution in <span>$L^2$</span> and plots the numerical result in case <code>dim==2</code>.</p><p>The boundary conditions below are set periodic in dimension 1 , Dirichlet at <span>$x_2=1$</span> and Neumann at <span>$x_2=0$</span> but you can change this according to your whishes.</p><p>The nodes distribution is as standard iid but you can provide a density. The code is implemented to generate 1000 nodes but you can change this as well.</p><pre><code class="language-julia hljs">using HighVoronoi
using SparseArrays
using IterativeSolvers
using NearestNeighbors
using LinearAlgebra
using StaticArrays


##########################################################################################

## Derivatives

##########################################################################################

function ∂_k(f,x,k;dim=length(x),vec2=MVector{dim}(zeros(Float64,dim)))
    h = 0.00245
    vec2 .= x
    vec2[k] += h
    f1 = f(vec2)
    vec2[k] += h
    f2 = f(vec2)
    vec2 .= x
    vec2[k] -= h
    f3 = f(vec2)
    vec2[k] -= h
    f4 = f(vec2)
    return ( 8*(f1-f3) + (f4-f2) ) / ( 12*h ) # five-point stencil
end

function ∇(f::Function,dim)
    vec2=MVector{dim}(zeros(Float64,dim))
    return x-&gt;map(k-&gt;∂_k(f,x,k,dim=dim,vec2=vec2),1:dim)
end

function ∇_buffered(f::Function,dim,vec=MVector{dim}(zeros(Float64,dim)),base=HighVoronoi.empty_local_Base(dim))
    vec = MVector{dim}(zeros(Float64,dim))
    vec2 = MVector{dim}(zeros(Float64,dim))
    return x-&gt;map!(k-&gt;∂_k(f,x,k,dim=dim,vec2=vec2),vec,1:dim)
end

function ∇cdot(f::Function,dim)
    function sum_partials(f,x,dim,vec2)
        f_sum = 0.0
        for k in 1:dim
            f_sum += ∂_k(y-&gt;f(y)[k],x,k,dim=dim,vec2=vec2)
        end
        return f_sum
    end
    vec = MVector{dim}(zeros(Float64,dim))
    return x-&gt;sum_partials(f,x,dim,vec)
end

function neumann_bc(flux,domain,x)
    function plane_of_x(domain,x)
        k = 0
        dist = 10.0
        ldp = length(domain.planes)
        for i in 1:ldp
            d = dot(domain.planes[i].base-x,domain.planes[i].normal)
            if d&lt;dist
                k=i
            end
        end
        return domain.planes[k].normal
    end
    normal = plane_of_x(domain,x)
    return dot(normal,flux(x))
end


##########################################################################################

## Solving -∇⋅(κ∇u) = RHS    on  &#39;domain&#39;
## keep track of signs!!!

##########################################################################################

# returns all necessary data to perform a numerical calculation to solve 
# -∇⋅(κ∇u) = RHS   using HighVoronoi tools
# calculates RHS := -∇⋅(κ∇u) and if needed Neumann condition
# provides u_exact:=u and κ
function make_set(u::Function,κ::Function,dim;periodic=[], 
                    dirichlet_boundary=collect(1:(2*dim)), 
                    neumann_boundary=nothing, density=nothing, 
                    number_of_nodes=1000)
    my_domain = cuboid(dim,periodic=periodic)
    ∇u = ∇(u,dim)
    rhs = ∇cdot(x-&gt;-1.0*κ(x)*∇u(x),dim)
    flux(x) = -κ(x)*∇u(x)
    neumann_flux(x) = -κ(x)*∇_buff_u(x) # faster but with internal buffer
    if density!=nothing
        return (u_exact = u,  κ=κ, RHS = rhs, 
                domain=my_domain, dim=dim,
                dirichlet_boundary=dirichlet_boundary, 
                neumann_boundary=neumann_boundary, 
                number_of_nodes = number_of_nodes,
                neumann = x-&gt;neumann_bc(flux,my_domain,x))
    else
        return (u_exact = u,  κ=κ, RHS = rhs, 
                domain=my_domain, dim=dim,
                density=density,
                dirichlet_boundary=dirichlet_boundary, 
                neumann_boundary=neumann_boundary, 
                number_of_nodes = number_of_nodes,
                neumann = x-&gt;neumann_bc(flux,my_domain,x))
    end
end


using Plots
# plotting the results if dimension is 2
function plot_2d_surface(nodes, values)
    # The following two lines are necessary in order for the plot to look nicely
    func = StepFunction(nodes,values)
    new_nodes = vcat([VoronoiNode([k/10,j*1.0]) for k in 0:10, j in 0:1], [VoronoiNode([j*1.0,k/10]) for k in 1:9, j in 0:1])
    append!(nodes,new_nodes)
    append!(values,[func(n) for n in new_nodes])
    
    x = [node[1] for node in nodes]
    y = [node[2] for node in nodes]
    
    p = Plots.surface(x, y, values, legend=false)
    xlabel!(&quot;X&quot;)
    ylabel!(&quot;Y&quot;)
    zlabel!(&quot;Values&quot;)
    title!(&quot;2D Surface Graph&quot;)
    
    display(p)
end


# Flux function passed as a parameter to HighVoronoi
function SQRA_flux(;para_i,para_j,mass_ij,normal,kwargs...) 
    # kwargs... collects all additional parameters which are not used in the current function.
    weight = norm(normal)^(-1) * mass_ij * sqrt(para_i[:κ]*para_j[:κ])
    return weight, weight
end

# RHS passed to HighVoronoi
myRHS(;para_i,mass_i,kwargs...) = mass_i * para_i[:f] 

# performs numerical calculations to solve -∇⋅(κ∇u) = RHS
function simulation(set)
    # adjust RHS for periodic domain 
    new_RHS = HighVoronoi.PeriodicFunction(set.RHS,set.domain)
    set = (neumann = x-&gt;0.0, set..., RHS=new_RHS)
    # get nodes
    nodes = nothing
    if isdefined(set,:density)
        nodes = VoronoiNodes( set.number_of_nodes;density=set.density, 
                    domain=cuboid(set.dim,periodic=[]), silence=false)
    else
        nodes = VoronoiNodes(rand(set.dim,set.number_of_nodes))
    end
    # Voronoi Geometry and integration. We could also set up VG_κ directly...
    VG_basis = VoronoiGeometry(nodes,set.domain,integrator=HighVoronoi.VI_GEOMETRY)
    VG_κ = VoronoiGeometry(VG_basis, integrator=HighVoronoi.VI_POLYGON, integrand=x-&gt;[set.κ(x),set.RHS(x)])
    vd = VoronoiData(VG_κ) # needed for volumes in the final calculations
    # set up fluxes and RHS
    vfvp = VoronoiFVProblem(VG_κ,  
                              integralfunctions = (κ = set.κ, f = set.RHS, ), 
                              fluxes = ( j1 = SQRA_flux, ),
                              rhs_functions = (F = myRHS,) )
    # define functions that can be applied as boundary conditions
    harmonic = FVevaluate_boundary(x-&gt;0.0) # turn a function into the format HighVoronoi needs
    compatibility = FVevaluate_boundary(x-&gt;set.u_exact(x))
    neumann = FVevaluate_boundary(x-&gt;set.neumann(x))
    # construct linear system from fluxes, RHS and boundary conditions
    r,c,v,f = linearVoronoiFVProblem(vfvp, flux = :j1, rhs = :F, 
            Dirichlet = set.dirichlet_boundary!=nothing ? (set.dirichlet_boundary,compatibility) : nothing, 
            Neumann = set.neumann_boundary!=nothing ? (set.neumann_boundary,neumann) : nothing)
    A = sparse(r,c,v) # a sparse matrix with rows `r`, coloumns `c` and values `v`
    # solve linear system using IterativeSolvers-Package
    solution_u = cg(A,f) # conjugate gradients
    # print out approximate L²-error between exact and numerical solutions 
    println(&quot;Approximate L²-error: &quot;,sqrt(sum(map(k-&gt;abs2(solution_u[k]-set.u_exact(nodes[k]))*vd.volume[k],1:length(nodes)))))
    return nodes, solution_u  # return nodes and values for plotting...
end


###################################################################################

## Putting together the above pieces

###################################################################################

# create parameters
my_set = make_set(x-&gt;sin(x[1]*2*π)^2 * sin(x[2]*2*π)^2, x-&gt;1.0, 2, 
                periodic=[1], dirichlet_boundary=3, neumann_boundary=4)
                # reminder: periodic=[1] identifies boundary 1 with boundary 2
# perform simulation
nodes, values = simulation(my_set)
# plot results
my_set.dim==2 &amp;&amp; plot_2d_surface(nodes, values)
</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../integrals/">« (More) Integrals</a><a class="docs-footer-nextpage" href="../../showcase/">Intentions of use (EXAMPLES) »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Monday 20 November 2023 14:38">Monday 20 November 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
