
const Dirichlet=0
const Neumann=-1

#################################################################################################################

## struct Boundary and related operators on it

#################################################################################################################


@doc raw"""
    Plane{T}
    provides a 'base' vector and a 'normal' vector of type 'T' to describe a plane. 
    BC=Dirichlet or BC=Neumann indicate Dirichlet- resp. Neumann- boundary condition on the plane.
    BC='any positive number' indicates periodic boundary conditions with the complementary plane given by the index BC
"""

struct Plane
    base::Vector{Float64}
    normal::Vector{Float64}
    BC::Int16
    function Plane(b,n,bc) 
        return new(b,n,bc)
    end
end

function planeToString(plane::Plane)
    return "[ Plane($(plane.BC)): base=$(plane.base), normal=$(plane.normal) ] "
end



function BC_Dirichlet(b,n)
    return Plane(b,n,Dirichlet)
end

function BC_Neumann(b,n)
    return Plane(b,n,Neumann)
end

struct BC_Periodic
    up::Plane
    down::Plane
    function BC_Periodic(u,d)
        return new(u,d)
    end
    function BC_Periodic(base1,base2,normal1)
        return new(Plane(base1,normal1,0),Plane(base2,(-1).*normal1,0))
    end
end


#################################################################################################################

## struct Boundary and related operators on it

#################################################################################################################

"""
    Boundary

provides the data structure for boundaries of VoronoiGeometry. Its most important feature is the vector
    
    planes::Vector{Plane}

which stores every flat part of the boundary as

    struct Plane
        base::Vector{Float64} # base of the plane
        normal::Vector{Float64} # outer normal of the domain on this plane
        BC::Int16 # 0 for Dirichlet, -1 for Neumann and >0 for the index of the other correspondant in case this is supposed to be periodic
    end
"""
struct Boundary{T}
    planes::Vector{T}
    convex::Bool
    childs::Vector{Vector{Int64}}
    function Boundary{T}(p,co,ch) where {T}
        return new(p,co,ch)
    end
    function Boundary(_planes::Vector,_convex::Bool)
        B=Boundary{Plane}(_planes,_convex,(Vector{Int64})[])
        return B
    end
end

"""
    Boundary(planes...)

is the constructor for Boundaries. planes... is a list of planes generated by either one of the following functions:

    BC_Dirichlet(b,n)
    BC_Neumann(b,n)

generating Dirichlet resp. Neumann boundaries with base `b` and normal `n`.

    BC_Periodic(base1,base2,normal1)

generating two periodic boundaries with `base1` and `normal1`  resp. with `base2` and `normal = -normal1` 

"""
function Boundary(planes...)
    count=0
    for p in planes
        if typeof(p)==BC_Periodic
            count+=2
        else
            count+=1
        end
    end
    newplanes=Vector{Plane}(undef,count)
    count=1
    for p in planes
        if typeof(p)==BC_Periodic
            newplanes[count]=Plane(p.up.base,p.up.normal,count+1)
            newplanes[count+1]=Plane(p.down.base,p.down.normal,count)
            count+=2
        else
            newplanes[count]=p
            count+=1
        end
    end
    return Boundary(newplanes,true)
end

function Boundary()
    return Boundary(Plane[],true)
end

struct FullSpace
end

import Base.in

function in(x,B::FullSpace)
    return true
end

function length(B::FullSpace)
    return 0
end

function intersect(B::FullSpace,x_0,v,condition=(x->true))
    return 0, Inf64
end

function extend_periodic_part(B::FullSpace,xs::Points)
    return B
end
####################  OUTPUT REPRESENTATION ####################################################################

function boundaryToString(B::Boundary;offset=0)
    result="\u1b[($offset)CBOUNDARY:\n"
    for i in 1:(length(B.planes))
        plane=B.planes[i]
        result*="\u1b[($offset)C    $i: base=$(plane.base), normal=$(plane.normal) ; "
        if (plane.BC==Neumann) result*="Neumann\n"
        elseif plane.BC==Dirichlet result*="Dirichlet\n"
        else result*="periodic with neighbor $(plane.BC)\n" end
    end
    return result
end

function vp_print(B::Boundary;offset=0)
    vp_print(offset,"BOUNDARY:")
    vp_line()
    for i in 1:(length(B.planes))
        plane=B.planes[i]
        vp_print(offset+4,"$i: base=$(plane.base), normal=$(plane.normal) ; ")
        if (plane.BC==Neumann) println("Neumann")
        elseif plane.BC==Dirichlet println("Dirichlet")
        else println("periodic with neighbor $(plane.BC)") end
    end
end

@doc raw"""
    edge_representation2D(B::Boundary)

provides a representation for each plane of 'B' in terms of two verteces
"""
function edge_representation2D(B::Boundary)
    result = EmptyDictOfType(1=>(B.planes[1].base,B.planes[1].base))
    for edge in 1:(length(B.planes))
        intersections=EmptyDictOfType(1=>(1.0,B.planes[1].base))
        x_0=B.planes[edge].base
        v= [0 1;-1 0]*B.planes[edge].normal#zeros(Float64,2)
        for i in 1:(length(B.planes))
            i==edge && continue 
            new_t=intersect(B.planes[i],x_0,v)
            new_t==Inf && continue
            point=x_0+new_t*v
            push!(intersections,i=>(dot(B.planes[i].base-point,B.planes[i].base),point)) # key always non-positive but zero only for the two intersection points at boundary 
        end
        e1=-Inf64
        e2=-Inf64
        x1=copy(x_0)
        x2=copy(x_0)
        while length(intersections)>0
            (_,(e,x))=pop!(intersections)
            if e>=e1
                e2=e1
                e1=e
                x2=x1
                x1=x
            end
        end
        push!(result,edge=>(x1,x2))
    end
    return result
end

####################### GEOMETRIC OPERATIONS ######################################################################

function reflect(node,boundary::Boundary,plane;indeces=nothing)
    _plane=typeof(indeces)==Nothing ? boundary.planes[plane] : boundary.planes[indeces[plane]]
    normal=_plane.normal
    base=_plane.base
    return node+normal .*(2*dot(normal,base.-node))    
end



@doc raw"""
    intersect(P::Plane,x_0,v)

    calculates the scalar solution t to the problem
    (y-P.base)*P.normal=0  ,  x_0+t*v=y
    eg: (P.base-x_0)*P.normal == t v*P.normal 

"""
function intersect(P::Plane,x_0,v)
    return dot(P.base-x_0,P.normal)/dot(v,P.normal)
end

@doc raw"""
    intersect(B::Boundary,x_0,v)

    calculates intersect(P,x_0,v) for every plane P in B and returns (i,t), the index 'i' of the minimal result 
    as well as the minimal result 't'

"""
function intersect(B::Boundary,x_0,v,condition=(x->true))
    index=0::Int64
    t=Inf64::Float64
    for i in 1:(length(B.planes))
        if !condition(i) continue end
        new_t=intersect(B.planes[i],x_0,v)
        if 0<new_t<t 
            t=new_t
            index=i
        end
    end
    return index,t
end

@doc raw"""
    intersections(B::Boundary,x_0,v)

calculates for every plane p_i of B the value t_i with x_0+t_i*v_ in p_i . results will store a sorted list of t_i and indeces stores the corresponding list of i. 
The return value is the entry i of indeces such that x_0 +0.5*(t_i + t_(i+1)) in B
"""
function intersections!(B::Boundary,x_0,v; results=zeros(Float64,length(B.planes)), indeces=collect(1:length(B.planes)), condition=(x->true))
    sort!(indeces)
    for i in 1:(length(B.planes))
        if !condition(B.planes[i].BC) continue end
        results[i]=intersect(B.planes[i],x_0,v)
    end
    quicksort!(results,indeces,indeces)
    found=0
    r=results
    for i in 1:(length(results)-1)
        if (results[i]>-Inf && results[i+1]<Inf)
            point=x_0+0.5*(r[i]+r[i+1])*v
            if point in B 
                found=i 
                break
            end  
        end
    end
    return found
end

@doc raw"""
    intersect(B::Boundary,v::boundary_vertex)
    returns the couple 'i','t' such that the line v.base+t*v.direction lies in B.planes[i]
    'i' is such that 't' is the minimal positive value, i.e. B.planes[i] is actually 
    the true part of the boundary that is hit by 'v'
"""
function intersect(B::Boundary,v::boundary_vertex,condition=(x->true))
    return intersect(B,v.base,v.direction,condition)
end

#############   HANDLING BOUNDARIES   ###############################

function split_boundary_indeces(B::Boundary)
    inds=collect(1:length(B))
    dir = keepat!(copy(inds),map(k->(B.planes[k].BC==0),inds))
    neu = keepat!(copy(inds),map(k->(B.planes[k].BC<0),inds))
    per = keepat!(copy(inds),map(k->!((k in dir) || (k in neu)),inds))
    return per, neu, dir
end


"provides the non-periodic part of the boundary"
function reduce_periodic_part(B::Boundary)
    count=0
    for i in 1:length(B.planes)
        if B.planes[i].BC<=0 count+=1 end
    end
    new_planes=Vector{Plane}(undef,count)
    indeces=Vector{Int64}(undef,count)
    count=0
    for i in 1:length(B.planes)
        if B.planes[i].BC<=0
            count+=1
            indeces[count]=i
            new_planes[count]=B.planes[i]
        end
    end
    return Boundary(new_planes,B.convex),indeces
end


function reduce_to_periodic(B::Boundary)
    count=0
    skipped=zeros(Int64,length(B.planes))
    skip=0
    for i in 1:length(B.planes)
        if B.planes[i].BC>0 
            count+=1 
        else
            skip+=1
        end
        skipped[i]=skip
    end
    new_planes=Vector{Plane}(undef,count)
    count=0
    for i in 1:length(B.planes)
        if B.planes[i].BC>0
            count+=1
            new_planes[count]=Plane(B.planes[i].base,B.planes[i].normal,B.planes[i].BC-skipped[B.planes[i].BC]) 
        end
    end
    return Boundary(new_planes,B.convex)
end

function remove_periodicity(B::Boundary)
    new_planes = Vector{Plane}(undef,length(B.planes))
    for i in 1:length(B.planes)
        new_planes[i]=Plane(B.planes[i].base ,B.planes[i].normal,0) 
    end
    return Boundary(new_planes,B.convex)   
end

function extend_periodic_part(B::Boundary,xs::Points,indeces = false)
    if indeces
        lxs = length(xs)
        _indeces = collect(1:length(B)) 
        for i in 1:length(B.planes)
            if B.planes[i].BC>0
                #bestpos=0
                d=0.0
                for j in 1:lxs
                    #d=max(d,dot(B.planes[i].normal, xs[j] - (bestpos==0 ? B.planes[i].base : xs[bestpos])))
                    d=max(d,dot(B.planes[i].normal, xs[j] - B.planes[i].base ))
                end
                if d>0.0
                    B.planes[i].base .+= (1.01*d) .* B.planes[i].normal
                else
                    _indeces[i] = 0
                end
            else
                _indeces[i] = 0
            end
        end
        return keepat!(_indeces,map(x->(x!=0),_indeces))        
    else
        new_planes = Vector{Plane}(undef,length(B.planes))
        for i in 1:length(B.planes)
            if B.planes[i].BC>0
                new_base = B.planes[i].base+B.planes[i].normal*dot(B.planes[i].normal,B.planes[i].base-B.planes[B.planes[i].BC].base)
                new_planes[i]=Plane(new_base ,B.planes[i].normal,B.planes[i].BC) 
            else
                new_planes[i]=B.planes[i]
            end
        end
        return Boundary(new_planes,B.convex)   
    end 
end


function in(x,B::Boundary)
    l=length(B.planes)
    l==0 && return true
    for i in 1:l
        plane=B.planes[i]
        if dot(plane.base-x,plane.normal)<0 return false end
    end
    return true
end

function adjust_boundary_vertex(x,B::Boundary,sig,lmesh,lsig=length(sig),tolerance=1.0E-10)
    x2 = x
    for i in lsig:-1:1
        sig[i]<=lmesh && break
        plane=B.planes[sig[i]-lmesh]
        my_prod = dot(plane.base-x2,plane.normal)
        if my_prod<0 && my_prod>-tolerance 
            x2 = x2 + 2*my_prod*plane.normal 
        end
    end
    return x2
end

function show_in(x,B::Boundary)
    l=length(B.planes)
    l==0 && return true
    for i in 1:l
        plane=B.planes[i]
        if dot(plane.base-x,plane.normal)<0 
            println(i,": ",plane.base-x," , ",plane.normal," , ",dot(plane.base-x,plane.normal))
            return false 
        end
    end
    return true
end

function project(x,B::FullSpace)
    return x
end

function project(x,B::Boundary)
    x2=x
    l=length(B.planes)
    l==0 && return x
    for i in 1:l
        plane=B.planes[i]
        d=dot(plane.base-x,plane.normal)
        if d<0 
            x2=x2+d*plane.normal 
        end
    end
    return x2
end

function length(b::Boundary)
    return length(b.planes)
end

function push!(boundary::Boundary,plane::Plane)
    push!(boundary.planes,plane)
end

function push!(boundary::Boundary,per::BC_Periodic)
    l=length(boundary.planes)
    push!(boundary.planes,Plane(per.up.base,per.up.normal,l+2))
    push!(boundary.planes,Plane(per.down.base,per.down.normal,l+1))
end


###################### GENERATING CUBES ###############################################

center_cube(dim,size)=cuboid(dim,dimensions=size*ones(Float64,dim),offset=-0.5*size*ones(Float64,dim))

"""
    cuboid(dim;dimensions=ones(Float64,dim),periodic=collect(1:dim),neumann=Int64[],offset=zeros(Float64,dim))

or simply `cuboid(dim)` generates a cube of type `Boundary`. 
- dim : This is the dimension of the cuboid
- dimensions : provides the size of the cuboid in each dimension
- periodic : this is a (sorted!!) list of dimensions in which the cube is assumed to have periodic boundary conditions
- neumann : every dimension k=1...dim which is not periodic my be put here with positive sign for the right hand side or negative sign (i.e. -k) for the left hand side
- offset : shifts the cube in space  

A particular application is the following method provided by HighVoronoi.

    center_cube(dim,size) = cuboid(dim,dimensions=size*ones(Float64,dim),offset=-0.5*size*ones(Float64,dim))

Relying on `cuboid(...)` it generates a cube with center `0` and edge length `size`.
"""
function cuboid(dim;dimensions=ones(Float64,dim),periodic=collect(1:dim),neumann=Int64[],offset=zeros(Float64,dim))
    planes=Vector{Plane}(undef,2*dim)
    unit=zeros(Float64,dim)
    _zeros=zeros(Float64,dim)
    for i in 1:dim
        unit.*=0
        unit[i]=1
        if i in periodic
            planes[(2*i)-1]=Plane(offset.+dimensions[i] .*unit,copy(unit),2*i)
            planes[2*i]=Plane(copy(offset),(-1).*unit,(2*i)-1)
            continue
        end
        if i in neumann
            planes[(2*i)-1]=Plane(offset.+dimensions[i].*unit,copy(unit),Neumann)
        else
            planes[(2*i)-1]=Plane(offset.+dimensions[i].*unit,copy(unit),Dirichlet)
        end
        if -i in neumann
            planes[2*i]=Plane(copy(offset),(-1).*unit,Neumann)
        else
            planes[2*i]=Plane(copy(offset),(-1).*unit,Dirichlet)
        end
    end
    return Boundary(planes,true)
end


