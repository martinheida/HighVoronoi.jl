
const Dirichlet=0
const Neumann=-1

import Base.in


#################################################################################################################

## struct Boundary and related operators on it

#################################################################################################################


@doc raw"""
    Plane{T}
    provides a 'base' vector and a 'normal' vector of type 'T' to describe a plane. 
    BC=Dirichlet or BC=Neumann indicate Dirichlet- resp. Neumann- boundary condition on the plane.
    BC='any positive number' indicates periodic boundary conditions with the complementary plane given by the index BC
"""

struct Plane
    base::Vector{Float64}
    normal::Vector{Float64}
    BC::Int16 
    function Plane(b,n,bc) 
        return new(b,n,bc)
    end
end

function planeToString(plane::Plane)
    return "[ Plane($(plane.BC)): base=$(plane.base), normal=$(plane.normal) ] "
end



function BC_Dirichlet(b,n)
    return Plane(b,n,Dirichlet)
end

function BC_Neumann(b,n)
    return Plane(b,n,Neumann)
end

struct BC_Periodic
    up::Plane
    down::Plane
    function BC_Periodic(u,d)
        return new(u,d)
    end
    function BC_Periodic(base1,base2,normal1)
        return new(Plane(base1,normal1,0),Plane(base2,(-1).*normal1,0))
    end
end


#################################################################################################################

## struct Boundary and related operators on it

#################################################################################################################

"""
    Boundary

provides the data structure for boundaries of VoronoiGeometry. Its most important feature is the vector
    
    planes::Vector{Plane}

which stores every flat part of the boundary as

    struct Plane
        base::Vector{Float64} # base of the plane
        normal::Vector{Float64} # outer normal of the domain on this plane
        BC::Int16 # 0 for Dirichlet, -1 for Neumann and >0 for the index of the other correspondant in case this is supposed to be periodic
    end
"""
struct Boundary
    planes::Vector{Plane}
    convex::Bool
    #childs::Vector{Vector{Int64}}
    function Boundary(_planes::Vector,_convex::Bool)
        return new(_planes,_convex)#,_convex,(Vector{Int64})[])
    end
end

function copy(b::Boundary)
    planes = Vector{Plane}(undef,length(b))
    for i in 1:length(b)
        planes[i] = Plane(copy(b.planes[i].base),copy(b.planes[i].normal),b.planes[i].BC)
    end
    return Boundary(planes,b.convex)
end
"""
    Boundary(planes...)

is the constructor for Boundaries. planes... is a list of planes generated by either one of the following functions:

    BC_Dirichlet(b,n)
    BC_Neumann(b,n)

generating Dirichlet resp. Neumann boundaries with base `b` and normal `n`.

    BC_Periodic(base1,base2,normal1)

generating two periodic boundaries with `base1` and `normal1`  resp. with `base2` and `normal = -normal1` 

"""
function Boundary(planes...)
    count=0
    for p in planes
        if typeof(p)==BC_Periodic
            count+=2
        else
            count+=1
        end
    end
    newplanes=Vector{Plane}(undef,count)
    count=1
    for p in planes
        if typeof(p)==BC_Periodic
            newplanes[count]=Plane(p.up.base,p.up.normal,count+1)
            newplanes[count+1]=Plane(p.down.base,p.down.normal,count)
            count+=2
        else
            newplanes[count]=p
            count+=1
        end
    end
    return Boundary(newplanes,true)
end

function Boundary()
    return Boundary(Plane[],true)
end

####################  OUTPUT REPRESENTATION ####################################################################

function boundaryToString(B::Boundary;offset=0)
    result="\u1b[($offset)CBOUNDARY in $(length(B.planes[1].normal)) dimensions with $(length(B.planes)) planes:\n"
    for i in 1:(length(B.planes))
        plane=B.planes[i]
        result*="\u1b[($offset)C    $i: base=$(plane.base), normal=$(plane.normal) ; "
        if (plane.BC==Neumann) result*="Neumann\n"
        elseif plane.BC==Dirichlet result*="Dirichlet\n"
        else result*="periodic with neighbor $(plane.BC)\n" end
    end
    return result
end

function Base.show(B::Boundary)
    print(boundaryToString(B))
end

function vp_print(B::Boundary;offset=0)
    vp_print(offset,"BOUNDARY:") 
    vp_line()
    for i in 1:(length(B.planes))
        plane=B.planes[i]
        vp_print(offset+4,"$i: base=$(plane.base), normal=$(plane.normal) ; ")
        if (plane.BC==Neumann) println("Neumann")
        elseif plane.BC==Dirichlet println("Dirichlet")
        else println("periodic with neighbor $(plane.BC)") end
    end
end

@doc raw"""
    edge_representation2D(B::Boundary)

provides a representation for each plane of 'B' in terms of two verteces
"""
function edge_representation2D(B::Boundary)
    result = EmptyDictOfType(1=>(B.planes[1].base,B.planes[1].base))
    for edge in 1:(length(B.planes))
        intersections=EmptyDictOfType(1=>(1.0,B.planes[1].base))
        x_0=B.planes[edge].base
        v= [0 1;-1 0]*B.planes[edge].normal#zeros(Float64,2)
        for i in 1:(length(B.planes))
            i==edge && continue 
            new_t=intersect(B.planes[i],x_0,v)
            new_t==Inf && continue
            point=x_0+new_t*v
            push!(intersections,i=>(dot(B.planes[i].base-point,B.planes[i].base),point)) # key always non-positive but zero only for the two intersection points at boundary 
        end
        e1=-Inf64
        e2=-Inf64
        x1=copy(x_0)
        x2=copy(x_0)
        while length(intersections)>0
            (_,(e,x))=pop!(intersections)
            if e>=e1
                e2=e1
                e1=e
                x2=x1
                x1=x
            end
        end
        push!(result,edge=>(x1,x2))
    end
    return result
end

####################### GEOMETRIC OPERATIONS ######################################################################

@inline reflect(node,boundary::Boundary,plane,indeces) = reflect(node,boundary::Boundary,boundary.planes[indeces[plane]])
function reflect(node,boundary::Boundary,plane)
    _plane=boundary.planes[plane] 
    normal=_plane.normal
    base=_plane.base
    return node+normal .*(2*dot(normal,base.-node))    
end



@doc raw"""
    intersect(P::Plane,x_0,v)

    calculates the scalar solution t to the problem
    (y-P.base)*P.normal=0  ,  x_0+t*v=y
    eg: (P.base-x_0)*P.normal == t v*P.normal 

"""
function intersect(P::Plane,x_0,v)
    return dot(P.base-x_0,P.normal)/dot(v,P.normal)
end

@doc raw"""
    intersect(B::Boundary,x_0,v)

    calculates intersect(P,x_0,v) for every plane P in B and returns (i,t), the index 'i' of the minimal result 
    as well as the minimal result 't'

"""
function intersect(B::Boundary,x_0,v,condition=(x->true))
    index=0::Int64
    t=Inf64::Float64
    for i in 1:(length(B.planes))
        if !condition(i) continue end
        new_t=intersect(B.planes[i],x_0,v)
        if 0<new_t<t 
            t=new_t
            index=i
        end
    end
    return index,t
end

function intersection_exists(B::Boundary,x_0,v) 
    p = intersect_point(B,x_0,v)
    for i in 1:length(B.planes)
        if dot(p-B.planes[i].base,B.planes[i].normal)>1.0E-5
            return false
        end
    end
    return true
end

function intersect_point(B::Boundary,x_0,v)
    index, t = intersect(B,x_0,v)
    return t>0 ? x_0+t*v : x_0
end

@doc raw"""
    intersections(B::Boundary,x_0,v)

calculates for every plane p_i of B the value t_i with x_0+t_i*v_ in p_i . results will store a sorted list of t_i and indeces stores the corresponding list of i. 
The return value is the entry i of indeces such that x_0 +0.5*(t_i + t_(i+1)) in B
"""
function intersections!(B::Boundary,x_0,v; results=zeros(Float64,length(B.planes)), indeces=collect(1:length(B.planes)), condition=(x->true))
    sort!(indeces)
    for i in 1:(length(B.planes))
        if !condition(B.planes[i].BC) continue end
        results[i]=intersect(B.planes[i],x_0,v)
    end
    quicksort!(results,indeces,indeces)
    found=0
    r=results
    for i in 1:(length(results)-1)
        if (results[i]>-Inf && results[i+1]<Inf)
            point=x_0+0.5*(r[i]+r[i+1])*v
            if point in B 
                found=i 
                break
            end  
        end
    end
    return found
end

#############   HANDLING BOUNDARIES   ###############################

function compare(B1::Boundary,B2::Boundary,bc=false)
    length(B1)==length(B2) && length(B1)==0 && (return true)
    (length(B1)==0 || length(B2)==0) && (return false) 
    (length(B1)!=length(B2) || length(B1.planes[1].normal)!=length(B2.planes[1].normal)) && (return false)
    lB = length(B1)
    identified = zeros(Bool,lB)
    for k in 1:lB
        for i in 1:lB
            identified[i] && continue
            if abs(dot(B1.planes[k].normal,B2.planes[i].normal)-1.0)<1.0E-10
                if abs(dot(B1.planes[k].base-B2.planes[i].base,B1.planes[k].normal))<1.0E-8
                    identified[i] = true
                    if bc
                        B1.planes[k].BC>0 && B2.planes[k].BC<=0 && (return false) 
                        B1.planes[k].BC<=0 && B2.planes[k].BC>0 && (return false) 
                    end
                else 
                    return false
                end
            end
        end
    end
    return true
end

function same(boundary1::Boundary, boundary2::Boundary, i::Int)
    plane1 = boundary1.planes[i]
    plane2 = boundary2.planes[i]

    normal_match = norm(plane1.normal - plane2.normal) < 1e-5
    
    b1, b2 = plane1.base, plane2.base
    if norm(b1 + b2) > 1e-5
        base_match = norm(b1 - b2) / norm(b1 + b2) < 1e-5
    else
        base_match = norm(b1 - b2) < 1e-5
    end

    return normal_match && base_match
end

function same(boundary1::Boundary, boundary2::Boundary)
    length(boundary1)!=length(boundary2) && return false
    ret = true
    for i in 1:length(boundary1)
        ret &= same(boundary1,boundary2,i)
        !ret && break
    end
    return ret    
end

function split_boundary_indeces(B::Boundary)
    inds=collect(1:length(B))
    dir = keepat!(copy(inds),map(k->(B.planes[k].BC==0),inds))
    neu = keepat!(copy(inds),map(k->(B.planes[k].BC<0),inds))
    per = keepat!(copy(inds),map(k->!((k in dir) || (k in neu)),inds))
    return per, neu, dir
end


"provides the non-periodic part of the boundary"
function reduce_periodic_part(B::Boundary)
    count=0
    for i in 1:length(B.planes)
        if B.planes[i].BC<=0 count+=1 end
    end
    new_planes=Vector{Plane}(undef,count)
    indeces=Vector{Int64}(undef,count)
    count=0
    for i in 1:length(B.planes)
        if B.planes[i].BC<=0
            count+=1
            indeces[count]=i
            new_planes[count]=B.planes[i]
        end
    end
    return Boundary(new_planes,B.convex),indeces
end


function reduce_to_periodic(B::Boundary)
    count=0
    skipped=zeros(Int64,length(B.planes))
    skip=0
    for i in 1:length(B.planes)
        if B.planes[i].BC>0 
            count+=1 
        else
            skip+=1
        end
        skipped[i]=skip
    end
    new_planes=Vector{Plane}(undef,count)
    count=0
    for i in 1:length(B.planes)
        if B.planes[i].BC>0
            count+=1
            new_planes[count]=Plane(B.planes[i].base,B.planes[i].normal,B.planes[i].BC-skipped[B.planes[i].BC]) 
        end
    end
    return Boundary(new_planes,B.convex)
end

function remove_periodicity(B::Boundary)
    new_planes = Vector{Plane}(undef,length(B.planes))
    for i in 1:length(B.planes)
        new_planes[i]=Plane(B.planes[i].base ,B.planes[i].normal,0) 
    end
    return Boundary(new_planes,B.convex)   
end

function extend_periodic_part(B::Boundary,xs::Points,indeces = false)
        lxs = length(xs)
        _indeces = collect(1:length(B)) 
        for i in 1:length(B.planes)
            if B.planes[i].BC>0
                #bestpos=0
                d=0.0
                for j in 1:lxs
                    #d=max(d,dot(B.planes[i].normal, xs[j] - (bestpos==0 ? B.planes[i].base : xs[bestpos])))
                    d=max(d,dot(B.planes[i].normal, xs[j] - B.planes[i].base ))
                end
                if d>0.0
                    B.planes[i].base .+= (1.01*d) .* B.planes[i].normal
                else
                    _indeces[i] = 0
                end
            else
                _indeces[i] = 0
            end
        end
        return keepat!(_indeces,map(x->(x!=0),_indeces))        
end


function in(x,B::Boundary)
    l=length(B.planes)
    l==0 && return true
    for i in 1:l
        plane=B.planes[i]
        if dot(plane.base-x,plane.normal)<0 return false end
    end
    return true
end

function check_boundary(nodes,b::Boundary)
    for x in nodes
        !(x in b) && error("$x does not lie in the domain given by the boundary object\n"*boundaryToString(b,offset=4))
    end
end


@inline function adjust_boundary_vertex(x,B::Boundary,sig,lmesh,lsig=length(sig),tolerance=1.0E-10)
    return x
end

function show_in(x,B::Boundary)
    l=length(B.planes)
    l==0 && return true
    for i in 1:l
        plane=B.planes[i]
        if dot(plane.base-x,plane.normal)<0 
            println(i,": ",plane.base-x," , ",plane.normal," , ",dot(plane.base-x,plane.normal))
            return false 
        end
    end
    return true
end

function project(x,B::Boundary)
    x2=x
    l=length(B.planes)
    l==0 && return x
    for i in 1:l
        plane=B.planes[i]
        d=dot(plane.base-x,plane.normal)
        if d<0 
            x2=x2+d*plane.normal 
        end
    end
    return x2
end

function length(b::Boundary)
    return length(b.planes)
end

function push!(boundary::Boundary,plane::Plane)
    push!(boundary.planes,plane)
end

function push!(boundary::Boundary,per::BC_Periodic)
    l=length(boundary.planes)
    push!(boundary.planes,Plane(per.up.base,per.up.normal,l+2))
    push!(boundary.planes,Plane(per.down.base,per.down.normal,l+1))
end


###################### GENERATING CUBES ###############################################

center_cube(dim,size)=cuboid(dim,dimensions=size*ones(Float64,dim),offset=-0.5*size*ones(Float64,dim))

"""
    cuboid(dim;dimensions=ones(Float64,dim),periodic=collect(1:dim),neumann=Int64[],offset=zeros(Float64,dim))

or simply `cuboid(dim)` generates a cube of type `Boundary`. 
- dim : This is the dimension of the cuboid
- dimensions : provides the size of the cuboid in each dimension
- periodic : this is a (sorted!!) list of dimensions in which the cube is assumed to have periodic boundary conditions
- neumann : every dimension k=1...dim which is not periodic my be put here with positive sign for the right hand side or negative sign (i.e. -k) for the left hand side
- offset : shifts the cube in space  

A particular application is the following method provided by HighVoronoi.

    center_cube(dim,size) = cuboid(dim,dimensions=size*ones(Float64,dim),offset=-0.5*size*ones(Float64,dim))

Relying on `cuboid(...)` it generates a cube with center `0` and edge length `size`.
"""
function cuboid(dim;dimensions=ones(Float64,dim),periodic=collect(1:dim),neumann=Int64[],offset=zeros(Float64,dim))
    planes=Vector{Plane}(undef,2*dim)
    unit=zeros(Float64,dim)
    _zeros=zeros(Float64,dim)
    for i in 1:dim
        unit.*=0
        unit[i]=1
        if i in periodic
            planes[(2*i)-1]=Plane(offset.+dimensions[i] .*unit,copy(unit),2*i)
            planes[2*i]=Plane(copy(offset),(-1).*unit,(2*i)-1)
            continue
        end
        if i in neumann
            planes[(2*i)-1]=Plane(offset.+dimensions[i].*unit,copy(unit),Neumann)
        else
            planes[(2*i)-1]=Plane(offset.+dimensions[i].*unit,copy(unit),Dirichlet)
        end
        if -i in neumann
            planes[2*i]=Plane(copy(offset),(-1).*unit,Neumann)
        else
            planes[2*i]=Plane(copy(offset),(-1).*unit,Dirichlet)
        end
    end
    return Boundary(planes,true)
end


function testboundary()
    p1 = BC_Dirichlet([1.0,0.0],[1.0,0.0])
    p2 = BC_Neumann([0.0,0.0],[-1.0,0.0])
    p3 = BC_Periodic([0.0,1.0],[0.0,0.0],[0.0,1.0])
    b = Boundary(p1,p2,p3)
    println(boundaryToString(b))
    show(b)
    intersections!(b,[0.5,0.5],[1.0,0.0])
    c = cuboid(2,periodic=[1])
    c2 = cuboid(2,periodic=[2])
    show_in([0.5,0.5],c)
    same(c,c2)
    reduce_periodic_part(c)
    reduce_to_periodic(c2)
    push!(c,p1)
    push!(c,p3)
    return true
end