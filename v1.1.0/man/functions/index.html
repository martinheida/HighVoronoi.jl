<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · HighVoronoi.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://martinheida.github.io/HighVoronoi.jl/man/functions/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">HighVoronoi.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual Voronoi</span><ul><li><a class="tocitem" href="../short/">Examples Voronoi Generation</a></li><li><a class="tocitem" href="../workflowmesh/">Workflow</a></li><li><a class="tocitem" href="../geometry/">Voronoi: Nodes and Geometry, Integrators</a></li><li><a class="tocitem" href="../improving/">Improving Voronoi meshes for FV </a></li><li><a class="tocitem" href="../boundaries/">Boundaries</a></li><li><a class="tocitem" href="../advanced/">Advanced Options</a></li><li><a class="tocitem" href="../periodic/">Highspeed periodic geometries</a></li><li><a class="tocitem" href="../refine/">Refinement and Substitution of Subdomains</a></li><li><a class="tocitem" href="../projection/">Projection operators</a></li><li><a class="tocitem" href="../metapost/">Graphical Output in 2D and 3D</a></li><li><a class="tocitem" href="../errors/">Sources of errors and loss in performance</a></li></ul></li><li><span class="tocitem">Manual Finite Volume</span><ul><li><a class="tocitem" href="../finitevolumeexample/">Finite Volume Examples</a></li><li><a class="tocitem" href="../workflowfv/">Workflow in FV</a></li><li><a class="tocitem" href="../finitevolume/">Finite Volume Tutorial</a></li><li class="is-active"><a class="tocitem" href>Functions</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Step-functions"><span>Step functions</span></a></li><li><a class="tocitem" href="#VoronoiKDTree"><span>VoronoiKDTree</span></a></li><li class="toplevel"><a class="tocitem" href="#Diameters-of-cells"><span>Diameters of cells</span></a></li><li class="toplevel"><a class="tocitem" href="#Functions-on-interfaces"><span>Functions on interfaces</span></a></li><li class="toplevel"><a class="tocitem" href="#Functions-from-Data"><span>Functions from Data</span></a></li><li class="toplevel"><a class="tocitem" href="#The-FunctionComposer:-Passing-function-arguments"><span>The FunctionComposer: Passing function arguments</span></a></li><li><a class="tocitem" href="#Retrieving-the-full-(combined)-function"><span>Retrieving the full (combined) function</span></a></li><li><a class="tocitem" href="#Decomposing-the-Composer"><span>Decomposing the Composer</span></a></li></ul></li><li><a class="tocitem" href="../integrals/">(More) Integrals</a></li><li><a class="tocitem" href="../toyfvfile/">Some code to test and play around</a></li></ul></li><li><a class="tocitem" href="../../showcase/">Intentions of use (EXAMPLES)</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual Finite Volume</a></li><li class="is-active"><a href>Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/martinheida/HighVoronoi.jl/blob/main/docs/src/man/functions.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="createalltypesoffunctions"><a class="docs-heading-anchor" href="#createalltypesoffunctions">Periodic functions</a><a id="createalltypesoffunctions-1"></a><a class="docs-heading-anchor-permalink" href="#createalltypesoffunctions" title="Permalink"></a></h1><p>To make a function <code>f</code> periodic with respect to a (partially) periodic boundary <code>b::Boundary</code> or geometry <code>VG::VoronoiGeometry</code> use the following</p><pre><code class="language-julia hljs">f2 = PeriodicFunction(f::Function,b::Boundary)
f2 = PeriodicFunction(f::Function,VG::VoronoiGeometry)</code></pre><h1 id="Step-functions"><a class="docs-heading-anchor" href="#Step-functions">Step functions</a><a id="Step-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Step-functions" title="Permalink"></a></h1><p>Use one of the following methods to create a step function on the Voronoi grid:</p><pre><code class="language-julia hljs">f = StepFunction(VG::VoronoiGeometry, u&lt;:AbstractVector; tree::Union{VoronoiKDTree,KDTree})
f = StepFunction(VG::VoronoiGeometry, u::Function; tree::Union{VoronoiKDTree,KDTree})
f = StepFunction(VG::VoronoiGeometry; tree::Union{VoronoiKDTree,KDTree})
f = StepFunction(nodes::VoronoiNodes, u&lt;:AbstractVector; tree::Union{VoronoiKDTree,KDTree}=KDTree(nodes))</code></pre><p>This yields a step function <code>f</code> that is constant on every cell of the <code>VoronoiGeometry</code> <code>VG</code> or on the Voronoi tessellation given by <code>nodes</code>. If <code>u</code> is an abstract vector, the value <code>f(x)=u[i]</code> is assigned if - according to <code>tree</code> - the nearest neighbor of <code>x</code> is the i-th node of <code>VG</code> or <code>nodes</code>. If no value for <code>u</code> is provided, <code>StepFunction</code> will retrieved bulk-integral data stored in <code>VG</code>. If <code>VG</code> has no bulk-data, the step-function will return <code>nothing</code>.</p><p><code>tree</code> can be a <code>KDTree</code> from <code>NearestNeighbors.jl</code> or a <code>VoronoiKDTree</code>. It is highly recommended to use the last one as it accounts for periodicity.</p><p>Finally, consider the following advanced code:</p><pre><code class="language-julia hljs">    # create a composed function for integration
    f = FunctionComposer(reference_argument = [0.0,0.0], super_type = Float64, alpha = x-&gt;norm(x)*x, beta = x-&gt;sum(abs,x) )
    # create a VoronoiGeometry and integrate :alpha, :beta
    VG = VoronoiGeometry(VoronoiNodes(rand(2,40)), cuboid(2,periodic=[1]), integrator=HighVoronoi.VI_MONTECARLO, integrand=f.functions)
    # make a step function from integrated values:
    f_all = StepFunction(VG)
    # retrieve the alpha and beta- components as a single (real) valued stepfunctions
    alpha_step = x-&gt; HighVoronoi.decompose(f, f_all(x),scalar=true)[:alpha]
    beta_step = x-&gt; HighVoronoi.decompose(f, f_all(x),scalar=true)[:beta]
    # generate some sample output
    println(alpha_step([0.5,0.5]))
    println(beta_step([0.5,0.5]))</code></pre><h2 id="VoronoiKDTree"><a class="docs-heading-anchor" href="#VoronoiKDTree">VoronoiKDTree</a><a id="VoronoiKDTree-1"></a><a class="docs-heading-anchor-permalink" href="#VoronoiKDTree" title="Permalink"></a></h2><pre><code class="language-julia hljs">vt = VoronoiKDTree(VG::VoronoiGeometry; restrict_to_periodic=true)</code></pre><p>This will create a <code>KDTree</code> that accounts for periodicity of <code>VG</code>.  <code>restrict_to_periodic=true</code> implies that the &quot;official&quot; nodes are used only. It is highly recommended not to change this option if you are not knowing what you are doing.</p><h1 id="Diameters-of-cells"><a class="docs-heading-anchor" href="#Diameters-of-cells">Diameters of cells</a><a id="Diameters-of-cells-1"></a><a class="docs-heading-anchor-permalink" href="#Diameters-of-cells" title="Permalink"></a></h1><pre><code class="language-julia hljs">f = DiameterFunction(VG::VoronoiGeometry; tree = VoronoiKDTree(VG))</code></pre><p>This yields <span>$f(x):=(r,R)$</span> where <code>r</code> is the inner and <code>R</code> the outer radius of the Voronoi cell that contains <code>x</code>. This is by its nature a step function.</p><h1 id="Functions-on-interfaces"><a class="docs-heading-anchor" href="#Functions-on-interfaces">Functions on interfaces</a><a id="Functions-on-interfaces-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-on-interfaces" title="Permalink"></a></h1><p>It can be usefull to consider the integrated values over the interfaces of the Voronoi tessellation as a function. This is achieved by <code>InterfaceFunction</code>:</p><pre><code class="language-julia hljs">f = InterfaceFunction(VD::VoronoiData,range,symbol=nothing;scalar=true)</code></pre><p>This takes the <code>VD::VoronoiData</code> and creates a function that locally takes the value <code>VD.interface_integral[i][k]</code> over the respective interface. The value <span>$f(x)$</span> of the function is chosen according to the two nearest neighbors, hence there is  ambiguity in points with more than 2 nearest neighbors.</p><ul><li><code>range</code>: This can be a <code>FunctionComposer</code>-opject, in which case <code>symbol</code> has to be provided. It can also be <code>a:b</code> or <code>[a1,a2,...,aN]</code> to take a subarray of the values. It can also be <code>:all</code> in which case the full vector of values is taken.</li><li><code>scalar</code>: If true, then vectors with only one index will be returned as scalar values.  </li></ul><pre><code class="language-julia hljs">f = InterfaceFunction(VG::VoronoiGeometry,range,symbol=nothing;scalar=true)</code></pre><p>Calculates the <code>VoronoiData</code> and calls the first instance of the method.</p><pre><code class="language-julia hljs">f = InterfaceFunction(VG::VoronoiGeometry)</code></pre><p>Sets <code>range</code> to the full data range. Similar to the above example for <code>StepFunctions</code> one may consider the following setting:</p><pre><code class="language-julia hljs">    # create a composed function for integration
    f = FunctionComposer(reference_argument = [0.0,0.0], super_type = Float64, alpha = x-&gt;norm(x)*x, beta = x-&gt;sum(abs,x) )
    # create a VoronoiGeometry and integrate :alpha, :beta
    VG = VoronoiGeometry(VoronoiNodes(rand(2,40)), cuboid(2,periodic=[1]), integrator=HighVoronoi.VI_MONTECARLO, integrand=f.functions)
    # make a step function from integrated values:
    f_all = InterfaceFunction(VG)
    # retrieve the alpha and beta- components as a single (real) valued stepfunctions
    alpha_i = x-&gt; HighVoronoi.decompose(f, f_all(x),scalar=true)[:alpha]
    beta_i = x-&gt; HighVoronoi.decompose(f, f_all(x),scalar=true)[:beta]
    # generate some sample output
    println(alpha_i([0.5,0.5]))
    println(beta_i([0.5,0.5]))</code></pre><h1 id="Functions-from-Data"><a class="docs-heading-anchor" href="#Functions-from-Data">Functions from Data</a><a id="Functions-from-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-from-Data" title="Permalink"></a></h1><p>If you want to generate a function from various integrated data in your own way, you can call</p><article class="docstring"><header><a class="docstring-binding" id="HighVoronoi.FunctionFromData" href="#HighVoronoi.FunctionFromData"><code>HighVoronoi.FunctionFromData</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">FunctionFromData(args...)</code></pre><p>comes in to variations:</p><pre><code class="nohighlight hljs">FunctionFromData(vg::VoronoiGeometry,tree=VoronoiKDTree(vg),composer=nothing; function_generator)</code></pre><p>generates a function </p><pre><code class="nohighlight hljs">x-&gt;function_generator( data=VoronoiData(vg), composer=composer, _Cell=nearest_neighbor_of(x) )</code></pre><p>from <code>vg</code>, <code>tree</code> and a function </p><pre><code class="nohighlight hljs">function_generator(;data ,composer , _Cell )</code></pre><p>which takes <code>data::VoronoiData</code> generated from <code>vg</code>, <code>composer</code> from above and <code>_Cell::Int</code> for  the number of the current node and returns a <code>Float64</code> or a <code>Vector{Float64}</code> or anything else  if you do not plan to hand it over to the routines of <code>HighVoronoi</code>.  You can access every entry of VoronoiData to generate the value you want to be associated with the  Voronoi cell belonging to <code>vd.nodes[_Cell]</code>.</p><pre><code class="nohighlight hljs">FunctionFromData(vd::VoronoiData,tree::VoronoiKDTree,composer=nothing; function_generator)</code></pre><p>basically does the same but takes a <code>vd::VoronoiData</code> and <code>tree</code> mandatorily and  passes <code>vd</code> to the <code>function_generator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinheida/HighVoronoi.jl/blob/e355649f24f0b8fac66ea67579c07dba7ef17359/src/geometry.jl#L974-L999">source</a></section></article><h1 id="The-FunctionComposer:-Passing-function-arguments"><a class="docs-heading-anchor" href="#The-FunctionComposer:-Passing-function-arguments">The FunctionComposer: Passing function arguments</a><a id="The-FunctionComposer:-Passing-function-arguments-1"></a><a class="docs-heading-anchor-permalink" href="#The-FunctionComposer:-Passing-function-arguments" title="Permalink"></a></h1><div class="admonition is-info"><header class="admonition-header">Always glue functions with a FunctionComposer</header><div class="admonition-body"><p>The <code>FunctionComposer</code> is internally used to glue together real valued functions. Therefore, if a user wants to glue together functions and afterwards work with &quot;glued&quot; information generated from <code>HighVoronoi</code>, using <code>FunctionComposer</code> is the way unify internal and external calculations. </p></div></div><p>The <code>FunctionComposer</code> is the element implemented in <code>HighVoronoi</code> to concatenate several <code>Float</code> or <code>Vector{Float}</code> valued functions into one single <code>Vector{Float}</code>-valued function using <code>vcat(...)</code>. It is built using a call of the following method.</p><article class="docstring"><header><a class="docstring-binding" id="HighVoronoi.FunctionComposer-Tuple{}" href="#HighVoronoi.FunctionComposer-Tuple{}"><code>HighVoronoi.FunctionComposer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FunctionComposer(;reference_argument, super_type, _functions...)</code></pre><p>The composer takes the following arguments:</p><ul><li><code>_functions</code>: This is a list of named funcions.</li><li><code>super_type</code>: suppose your functions return values of type <code>T</code> and <code>Vector{T}</code> you should set <code>super_type=T</code></li><li><code>reference_argument</code>: Your functions take values of type <code>Float</code> and are well defined in <code>0.0</code>? Then you can put e.g. <code>0.0</code> here.    If your function accepts <code>StaticArray{3,Float64}</code> put e.g. <code>SVector{3,Float64}([0.0,1.2,3.4])</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinheida/HighVoronoi.jl/blob/e355649f24f0b8fac66ea67579c07dba7ef17359/src/composer.jl#L10-L18">source</a></section></article><p>A typical example would be</p><pre><code class="language-julia hljs">f = FunctionComposer(reference_argument = [0.0,0.0,0.0], super_type = Float64, alpha = x-&gt;norm(x)*x, beta = x-&gt;sum(abs,x) )</code></pre><p>or:</p><pre><code class="language-julia hljs">myfunctions=(alpha = x-&gt;norm(x)*x, beta = x-&gt;sum(abs,x))
f = FunctionComposer(reference_argument = [0.0,0.0,0.0], super_type = Float64; myfunctions...  )</code></pre><p>The latter has the advantage that you can define your set of functions once and for all and use it again and again ensuring you always have the same order in the arguments. This brings us to an important point:</p><div class="admonition is-warning"><header class="admonition-header">Don&#39;t mess with the order of arguments</header><div class="admonition-body"><p>FunctionComposer takes the order of functions as given in the argument. That is if you make function calls</p><pre><code class="language-julia hljs">f1 = FunctionComposer(reference_argument = [0.0,0.0,0.0], super_type = Float64, alpha = exp, beta = sin  )
f2 = FunctionComposer(reference_argument = [0.0,0.0,0.0], super_type = Float64; beta = sin, alpha = exp  )    </code></pre><p>the algorithm will create two different functions <code>x-&gt;[exp(x),sin(x)]</code> and <code>x-&gt;[sin(x),exp(x)]</code> and it will NOT be able to clear up the mess this creates....</p></div></div><h2 id="Retrieving-the-full-(combined)-function"><a class="docs-heading-anchor" href="#Retrieving-the-full-(combined)-function">Retrieving the full (combined) function</a><a id="Retrieving-the-full-(combined)-function-1"></a><a class="docs-heading-anchor-permalink" href="#Retrieving-the-full-(combined)-function" title="Permalink"></a></h2><p>The full function is stored in the variable <code>FunctionComposer.functions</code>.</p><pre><code class="language-julia hljs">myfunctions=(alpha = x-&gt;norm(x)*x, beta = x-&gt;sum(abs,x))
f = FunctionComposer(reference_argument = [0.0,0.0,0.0], super_type = Float64; myfunctions...  )

myvalue = f.functions([1.2,3.4,5.6])</code></pre><h2 id="Decomposing-the-Composer"><a class="docs-heading-anchor" href="#Decomposing-the-Composer">Decomposing the Composer</a><a id="Decomposing-the-Composer-1"></a><a class="docs-heading-anchor-permalink" href="#Decomposing-the-Composer" title="Permalink"></a></h2><p>To retrieve single information from an array like <code>myvalue</code> in the last example, you can simply use the internal function <code>HighVoronoi.decompose(...)</code>:</p><pre><code class="language-julia hljs">myfunctions=(alpha = x-&gt;norm(x)*x, beta = x-&gt;sum(abs,x))
f = FunctionComposer(reference_argument = [0.0,0.0,0.0], super_type = Float64; myfunctions...  )

myvalue = f.functions([1.2,3.4,5.6])

values = HighVoronoi.decompose(f, myvalue)

println(values[:alpha], values[:beta])</code></pre><p>If you whish <span>$1d$</span>-vectors to be returned as scalars, try out this one:</p><pre><code class="language-julia hljs">values2 = HighVoronoi.decompose(f, myvalue, scalar=true)

println(values2[:alpha], values2[:beta])</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../finitevolume/">« Finite Volume Tutorial</a><a class="docs-footer-nextpage" href="../integrals/">(More) Integrals »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Monday 18 March 2024 07:15">Monday 18 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
