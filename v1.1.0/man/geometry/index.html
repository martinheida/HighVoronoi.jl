<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Voronoi: Nodes and Geometry, Integrators · HighVoronoi.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://martinheida.github.io/HighVoronoi.jl/man/geometry/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">HighVoronoi.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual Voronoi</span><ul><li><a class="tocitem" href="../short/">Examples Voronoi Generation</a></li><li><a class="tocitem" href="../workflowmesh/">Workflow</a></li><li class="is-active"><a class="tocitem" href>Voronoi: Nodes and Geometry, Integrators</a><ul class="internal"><li><a class="tocitem" href="#differentnodegenerators"><span>Nodes</span></a></li><li><a class="tocitem" href="#Geometry"><span>Geometry</span></a></li><li><a class="tocitem" href="#integratoroverview"><span>Integrators (overview)</span></a></li><li><a class="tocitem" href="#Storage"><span>Storage</span></a></li><li><a class="tocitem" href="#Extraction-of-VoronoiData-data-for-further-processing"><span>Extraction of <code>VoronoiData</code> data for further processing</span></a></li></ul></li><li><a class="tocitem" href="../improving/">Improving Voronoi meshes for FV </a></li><li><a class="tocitem" href="../boundaries/">Boundaries</a></li><li><a class="tocitem" href="../advanced/">Advanced Options</a></li><li><a class="tocitem" href="../periodic/">Highspeed periodic geometries</a></li><li><a class="tocitem" href="../refine/">Refinement and Substitution of Subdomains</a></li><li><a class="tocitem" href="../projection/">Projection operators</a></li><li><a class="tocitem" href="../metapost/">Graphical Output in 2D and 3D</a></li><li><a class="tocitem" href="../errors/">Sources of errors and loss in performance</a></li></ul></li><li><span class="tocitem">Manual Finite Volume</span><ul><li><a class="tocitem" href="../finitevolumeexample/">Finite Volume Examples</a></li><li><a class="tocitem" href="../workflowfv/">Workflow in FV</a></li><li><a class="tocitem" href="../finitevolume/">Finite Volume Tutorial</a></li><li><a class="tocitem" href="../functions/">Functions</a></li><li><a class="tocitem" href="../integrals/">(More) Integrals</a></li><li><a class="tocitem" href="../toyfvfile/">Some code to test and play around</a></li></ul></li><li><a class="tocitem" href="../../showcase/">Intentions of use (EXAMPLES)</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual Voronoi</a></li><li class="is-active"><a href>Voronoi: Nodes and Geometry, Integrators</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Voronoi: Nodes and Geometry, Integrators</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/martinheida/HighVoronoi.jl/blob/main/docs/src/man/geometry.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Voronoi:-Nodes-and-Geometry,-Integrators"><a class="docs-heading-anchor" href="#Voronoi:-Nodes-and-Geometry,-Integrators">Voronoi: Nodes and Geometry, Integrators</a><a id="Voronoi:-Nodes-and-Geometry,-Integrators-1"></a><a class="docs-heading-anchor-permalink" href="#Voronoi:-Nodes-and-Geometry,-Integrators" title="Permalink"></a></h1><h2 id="differentnodegenerators"><a class="docs-heading-anchor" href="#differentnodegenerators">Nodes</a><a id="differentnodegenerators-1"></a><a class="docs-heading-anchor-permalink" href="#differentnodegenerators" title="Permalink"></a></h2><p>The most basic thing is the creation of a list of Points. We advise to use the following:</p><article class="docstring"><header><a class="docstring-binding" id="HighVoronoi.VoronoiNodes-Tuple{Matrix}" href="#HighVoronoi.VoronoiNodes-Tuple{Matrix}"><code>HighVoronoi.VoronoiNodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">VoronoiNodes(x::Matrix)</code></pre><p>also available in the forms</p><pre><code class="nohighlight hljs">VoronoiNodes(x::Vector{&lt;:Vector})
VoronoiNodes(x::Vector{&lt;:SVector})</code></pre><p>creates a list of points (as static vectors) from a matrix.</p><p><strong>Example: 100 Points in <span>$(0,1)^3$</span></strong></p><pre><code class="nohighlight hljs">data = rand(3,100)
points = VoronoiNodes(data)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinheida/HighVoronoi.jl/blob/e00f3cc7fdaff6516609540c97c0d3619951f61a/src/mesh.jl#L32-L44">source</a></section></article><p>An advanced method is given by the following</p><pre><code class="language-julia hljs">VoronoiNodes(number_of_nodes::Int;density , 
            domain::Boundary=Boundary(), bounding_box::Boundary=Boundary(),
            criterium=x-&gt;true)</code></pre><p>When <code>density = x-&gt;f(x)</code> this will create a cloud of approximately <code>number_of_nodes</code> points inside the intersection of <code>domain</code> and <code>bounding_box</code> with spatial distribution <span>$f(x)$</span>. Note that both exact number and position of points are random.  The variable <code>bounding_box</code> allows to handle also the case when <code>domain</code> is unbounded. The intersection of <code>domain</code> and <code>bounding_box</code>  HAS TO BE bounded!</p><p>The following two pictures show first a distribution <code>density = x-&gt;sin(pi*2*x[1])^2*sin(pi*2*x[2])^2</code> and the second takes the same density squared.</p><p><img src="../../assets/images/voronoisin2.png" alt="sin^2 distribution of nodes"/></p><p><img src="../../assets/images/voronoisin4.png" alt="sin^4 distribution of nodes"/></p><h3 id="Single-Nodes"><a class="docs-heading-anchor" href="#Single-Nodes">Single Nodes</a><a id="Single-Nodes-1"></a><a class="docs-heading-anchor-permalink" href="#Single-Nodes" title="Permalink"></a></h3><p>To instatiate a single node (e.g. if you want to add a specific node to an existing list of nodes) use</p><pre><code class="language-julia hljs"># make [1.0, 0.0, 0.5] a valid Voronoi node
VoronoiNode([1.0, 0.0, 0.5])</code></pre><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><pre><code class="language-julia hljs"># This is an example to illustrate VoronoiNodes(number_of_nodes::Int;density)

## First some plot routine ############################
using Plots

function plot_2d_surface(nodes, values)
    # The following two lines are necessary in order for the plot to look nicely
    func = StepFunction(nodes,values)
    new_nodes = vcat([VoronoiNode([k/10,j*1.0]) for k in 0:10, j in 0:1], [VoronoiNode([j*1.0,k/10]) for k in 1:9, j in 0:1])
    append!(nodes,new_nodes)
    append!(values,[func(n) for n in new_nodes])
    
    x = [node[1] for node in nodes]
    y = [node[2] for node in nodes]
    
    p = Plots.surface(x, y, values, legend=false)
    xlabel!(&quot;X&quot;)
    ylabel!(&quot;Y&quot;)
    zlabel!(&quot;Values&quot;)
    title!(&quot;2D Surface Graph&quot;)
    
    display(p)
end
########################################################

## Now for the main part ################################

my_distribution = x-&gt;(sin(x[1]*π)*sin(x[2]*π))^4
my_nodes = VoronoiNodes(100,density = my_distribution, domain=cuboid(2,periodic=[]))
# you may compare the output to the following:
# my_nodes = VoronoiNodes(100,density = x-&gt;1.0, domain=cuboid(2,periodic=[]))
println(&quot;This generated $(length(my_nodes)) nodes.&quot;)
my_vals = map(x-&gt;sin(x[1]*π)^2*sin(x[2]*π),my_nodes)
plot_2d_surface(my_nodes,my_vals)</code></pre><h3 id="DensityRange"><a class="docs-heading-anchor" href="#DensityRange">DensityRange</a><a id="DensityRange-1"></a><a class="docs-heading-anchor-permalink" href="#DensityRange" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="HighVoronoi.DensityRange" href="#HighVoronoi.DensityRange"><code>HighVoronoi.DensityRange</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DensityRange{S}</code></pre><p>provides a rectangular grid of points in a <code>S</code>-dimensional space. It is initialized as follows:</p><pre><code class="nohighlight hljs">DensityRange(mr::AbstractVector{&lt;:Integer},range)</code></pre><p>Here, <code>range</code> can be of the following types:</p><ul><li><code>AbstractVector{Tuple{&lt;:Real,&lt;:Real}}</code>: It is assumed that each entry of <code>range</code> is a tuple <code>(a_i,b_i)</code> </li></ul><p>so the range is defined in the cuboid <code>(a_1,b_1)	imes...	imes(a_{dim},b_{dim})</code></p><p><code>mr</code> is assumed to have the same dimension as <code>range</code> and the interval <code>(a_i,b_i)</code> will be devided into <code>mr[i]</code> intervalls</p><ul><li><code>AbstractVector{&lt;:Real}</code>: if e.g. <code>range=[1.0,1.0]</code> this will be transferred to <code>range=[(0.0,1.0),(0.0,1.0)]</code> </li></ul><p>and the first instance of the method is called </p><ul><li><code>Float64</code>: <code>range</code> will be set <code>range*ones(Float64,length(mr))</code> and the second instance is called</li><li><code>Tuple{&lt;:Real,&lt;:Real}</code>: range will be set to an array of identical tuple entries and the first version is called</li></ul><p>Alternatively, one may call the following method:</p><pre><code class="nohighlight hljs">DensityRange(mr::Int,range,dimension=length(range))</code></pre><p>it is assumed that <code>range</code> is an array or tuple of correct length and <code>mr</code> is replaced by <code>mr*ones(Int64,dimension)</code>.  If range is not an array, then <code>dimension</code> has to be provided the correct value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinheida/HighVoronoi.jl/blob/e00f3cc7fdaff6516609540c97c0d3619951f61a/src/densityrange.jl#L1-L25">source</a></section></article><h2 id="Geometry"><a class="docs-heading-anchor" href="#Geometry">Geometry</a><a id="Geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Geometry" title="Permalink"></a></h2><p>The creation and storage of Voronoi geometry data is handled by the following class. </p><article class="docstring"><header><a class="docstring-binding" id="HighVoronoi.VoronoiGeometry" href="#HighVoronoi.VoronoiGeometry"><code>HighVoronoi.VoronoiGeometry</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VoronoiGeometry{T}</code></pre><p>This is the fundamental struct to store information about the generated Voronoi grid. The geometric data can be accessed using the type <code>VoronoiData</code>.  However, there is always the possibility to access the data also via the following fields:</p><ul><li>Integrator.Integral: stores the integrated values in terms of a <code>Voronoi_Integral</code></li><li>basic_mesh: stores the fundamental data of nodes and verteces. also stored in Integrator.Integral.MESH</li><li>nodes: direct reference to the nodes. Also provided in basic_mesh.nodes</li></ul><div class="admonition is-warning"><header class="admonition-header">Avoid direct access to the data</header><div class="admonition-body"><p>Accessing the data directly, that is without calling <code>VoronoiData</code>, is likely to cause confusion or to provide &quot;wrong&quot; information.  The reason is that particularly for periodic boundary conditions, the mesh is enriched by a periodization of the boundary nodes.  These nodes are lateron dropped by the VoronoiData-Algorithm.       </p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinheida/HighVoronoi.jl/blob/e00f3cc7fdaff6516609540c97c0d3619951f61a/src/geometry.jl#L1-L14">source</a></section></article><p>To create a Voronoi mesh it is most convenient to call either of the following methods</p><article class="docstring"><header><a class="docstring-binding" id="HighVoronoi.VoronoiGeometry-Tuple{}" href="#HighVoronoi.VoronoiGeometry-Tuple{}"><code>HighVoronoi.VoronoiGeometry</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">VoronoiGeometry(xs::Points,b::Boundary)</code></pre><p>This creates a Voronoi mesh from the points <code>xs</code> given e.g. as an array of <code>SVector</code> and a boundary <code>b</code> that might be constructed using  the commands in the Boundaries section.</p><p>You have the following optional commands:</p><ul><li><code>silence</code>: Suppresses output to the command line when <code>true</code>. The latter will speed up the algorithm by a few percent. default is <code>false</code>. </li><li><code>integrator</code>: can be either one of the following values:<ul><li><code>VI_GEOMETRY</code>: Only the basic properties of the mesh are provided: the verteces implying a List of neighbors of each node</li><li><code>VI_MONTECARLO</code>: Volumes, interface areas and integrals are calculated using a montecarlo algorithm.    This particular integrator comes up with the following additional paramters:<ul><li><code>mc_accurate=(int1,int2,int3)</code>: Montecarlo integration takes place in <code>int1</code> directions, over <code>int2</code>    volumetric samples (vor volume integrals only). It reuses the same set of directions <code>int3</code>-times to save memory allocation time.   Standard setting is: <code>(1000,100,20)</code>.</li></ul></li><li><code>VI_POLYGON</code>: We use the polygon structure of the mesh to calculate the exact values of interface area and volume. The    integral over functions is calculated using the values at the center, the verteces and linear interpolation between.  </li><li><code>VI_HEURISTIC</code>: When this integrator is chosen, you need to provide a fully computed Geometry including volumes and interface areas.   <code>VI_HEURISTIC</code> will then use this information to derive the integral values.</li><li><code>VI_HEURISTIC_MC</code>: This combines directly <code>VI_MONTECARLO</code> calculations of volumes and interfaces and calculates integral values    of functions based on those volumes and areas. In particular, it also relies on <code>mc_accurate</code>!</li></ul></li><li><code>integrand</code>: This is a function <code>f(x)</code> depending on one spatial variable <code>x</code> returning a <code>Vector{Float64}</code>.    The integrated values will be provided for each cell and for each pair of neighbors, i.e. for each interface</li><li><code>periodic_grid</code>: This will initiate a special internal routine to fastly create a periodic grid. Look up the section in the documentation. </li></ul><p><strong>With density distribution:</strong></p><pre><code class="nohighlight hljs">VoronoiGeometry(number::Int,b=Boundary();density, kwargs...)</code></pre><p>this call genertates a distribution of approsximately <code>number</code> nodes and generates a <code>VoronoiGeometry</code>. It takes as parameters all of the  above mentioned keywords (though <code>periodic_grid</code> makes no sense) and all keywords valid for a call of VoronoiNodes(number;domain=b,density=density, ....)  </p><p>In future versions, there will be an implementation of the parameter <code>cubic=true</code>, where the grid will be generated based on a distribution of &quot;cubic&quot; cells. In the current version there will be a warning that this is not yet implemented.</p><p><strong>Advanced methods</strong></p><pre><code class="nohighlight hljs">VoronoiGeometry(file::String)
VoronoiGeometry(VG::VoronoiGeometry)</code></pre><p>Loads a Voronoi mesh from the <code>file</code> or copies it from the original data <code>VG</code>. If <code>integrator</code> is not provided, it will use the original integrator stored to the file.  In the second case, if integrand is not provided explicitly, it will use <code>integrand = VG.integrand</code> as standard. Additionally it has the following options:</p><ul><li><code>_myopen=jldopen</code>: the method to use to open the file. See the section on <code>write_jld</code>.</li><li><code>offset</code>: See the section on <code>write_jld</code>.</li><li><code>integrate=false</code>: This will or will not call the integration method after loading/copying the data. Makes sense for using <code>VI_HEURISTIC</code> together with       <code>volume=true</code>, <code>area=true</code> and providing values for <code>integrand</code> and <code>integrand</code>. If <code>integrand != nothing</code> but <code>bulk==false</code> or <code>interface==false</code>        this parameter will internally be set <code>true</code>.</li><li><code>volume=true</code>: Load volume data from file</li><li><code>area=true</code>: Load interface area data from file</li><li><code>bulk=false</code>: Load integrated function values on the cell volumes from file. When set <code>true</code> and <code>integrand=f</code> is provided    the method  will compare the dimension of <code>f</code> and of the stored data. </li><li><code>interface=false</code>: Load integrated function values on the interfaces. When set <code>true</code> and <code>integrand=f</code> is provided    the method  will compare the dimension of <code>f</code> and of the stored data.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinheida/HighVoronoi.jl/blob/e00f3cc7fdaff6516609540c97c0d3619951f61a/src/geometry.jl#L36-L91">source</a></section></article><h2 id="integratoroverview"><a class="docs-heading-anchor" href="#integratoroverview">Integrators (overview)</a><a id="integratoroverview-1"></a><a class="docs-heading-anchor-permalink" href="#integratoroverview" title="Permalink"></a></h2><p>As discussed above there is a variety of integrators available to the user, plus some internal integrators that we will not discuss in this manual. The important integrators for the user are:</p><ul><li><code>VI_GEOMETRY</code>: Only the basic properties of the mesh are provided: the verteces and an implicit list of neighbors of each node. This is the fastes way to generate a <code>VoronoiGeometry</code></li><li><code>VI_MONTECARLO</code>: Volumes, interface areas and integrals are calculated using a montecarlo algorithm introduced by A. Sikorski in <code>VoronoiGraph.jl</code> and discussed in a forthcoming article by Heida, Sikorski, Weber. This particular integrator comes up with the following additional paramters:<ul><li><code>mc_accurate=(int1,int2,int3)</code>: Montecarlo integration takes place in <code>int1</code> directions, over <code>int2</code>        volumetric samples (vor volume integrals only). It reuses the same set of directions <code>int3</code>-times to save memory allocation time.       Standard setting is: <code>(1000,100,20)</code>.</li></ul></li><li><code>VI_POLYGON</code>: We use the polygon structure of the mesh to calculate the exact values of interface area and volume. The        integral over functions is calculated using the values at the center, the verteces and linear interpolation between. Also this method is to be discussed in the anounced article by Heida, Sikorski, Weber. </li><li><code>VI_FAST_POLYGON</code>: Even more precise than <code>VI_POLYGON</code>, very fast (50 secs for 500 nodes in 6D) but using a lot of memory. It is advised to use this integrator if you insists on accuracy over performance and if you have large RAM (advised &gt;=4GB of FREE RAM). On my personal machine with total 16GB RAM <code>VI_FAST_POLYGON</code> is by factor 15 faster than <code>VI_POLYGON</code> for 500 nodes in 6 dimensions and integrating <span>$x\rightarrow(x_1,x_2^2)$</span>.</li><li><code>VI_HEURISTIC</code>: When this integrator is chosen, you need to provide a fully computed Geometry including volumes and interface areas.       <code>VI_HEURISTIC</code> will then use this information to derive the integral values.</li><li><code>VI_HEURISTIC_MC</code>: This combines directly <code>VI_MONTECARLO</code> calculations of volumes and interfaces and calculates integral values        of functions based on those volumes and areas. In particular, it also relies on <code>mc_accurate</code>!</li></ul><p>It is important to have in mind that the polygon-integrator will be faster in low dimensions, whereas the Montecarlo integrator will outperform from 5 dimensions and higher. However, when volumes and integrals are to be calculated in high dimensions, the <code>VI_HEURISTIC_MC</code> is highly recommended, as it works with much less function evaluations than the <code>VI_MONTECARLO</code>. </p><h2 id="Storage"><a class="docs-heading-anchor" href="#Storage">Storage</a><a id="Storage-1"></a><a class="docs-heading-anchor-permalink" href="#Storage" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HighVoronoi.write_jld-Tuple{}" href="#HighVoronoi.write_jld-Tuple{}"><code>HighVoronoi.write_jld</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The data can be stored using the <code>write_jld</code> method:</p><pre><code class="nohighlight hljs">write_jld(Geo::VoronoiGeometry,filename,offset=&quot;&quot;;_myopen=jldopen)
write_jld(Geo::VoronoiGeometry,file,offset=&quot;&quot;)</code></pre><p>stores the complete information of a VoronoiGeometry object to a file. This information can later be retrieved using the <code>VoronoiGeometry(file::String, args...)</code> function.</p><ul><li><code>Geo</code>: The Voronoi geometry object to be stored</li><li><code>filename</code>: name of file to store in</li><li><code>file</code>: A file given in a format supporting <code>write(file,&quot;tagname&quot;,content)</code> and <code>read(file,&quot;tagname&quot;,content)</code> </li><li><code>offset</code>: If several Geometry objects are to be stored in the same file, this will be the possibility to identify each one by a unique name. In particular, this is the key to store several objects in one single file.</li><li><code>_myopen</code>: a method that allows the syntax <code>_myopen(filename,&quot;w&quot;) do myfile ....... end</code>. By default the method uses the <code>JLD2</code> library as this (at the point of publishing this package) has the least problems with converting internal data structure to an output format.</li></ul><div class="admonition is-warning"><header class="admonition-header">Filname extension</header><div class="admonition-body"><p>If you want to use the default method, then the filename should end on <code>.jld</code>. Otherwise there might be confusion by the abstract built in julia loading algorithm.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinheida/HighVoronoi.jl/blob/e00f3cc7fdaff6516609540c97c0d3619951f61a/src/geometry.jl#L402-L418">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HighVoronoi.load_Voronoi_info-Tuple{}" href="#HighVoronoi.load_Voronoi_info-Tuple{}"><code>HighVoronoi.load_Voronoi_info</code></a> — <span class="docstring-category">Method</span></header><section><div><p>If you want to make sure that the data you load will be rich enough, compact information can be retrieved as follows:</p><pre><code class="nohighlight hljs">load_Voronoi_info(filname,offset=&quot;&quot;)</code></pre><p>This will print out compact information of the data stored in file <code>filename</code> and the offset <code>offset</code>. Yields dimension, number of nodes, number of internal nodes and the dimension of the stored integrated data. Note that the latter information is of particular importance since here is the highest risk for the user to mess up stored data with the algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinheida/HighVoronoi.jl/blob/e00f3cc7fdaff6516609540c97c0d3619951f61a/src/geometry.jl#L453-L460">source</a></section></article><h2 id="Extraction-of-VoronoiData-data-for-further-processing"><a class="docs-heading-anchor" href="#Extraction-of-VoronoiData-data-for-further-processing">Extraction of <code>VoronoiData</code> data for further processing</a><a id="Extraction-of-VoronoiData-data-for-further-processing-1"></a><a class="docs-heading-anchor-permalink" href="#Extraction-of-VoronoiData-data-for-further-processing" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HighVoronoi.VoronoiData" href="#HighVoronoi.VoronoiData"><code>HighVoronoi.VoronoiData</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Using the call </p><pre><code class="nohighlight hljs">data=VoronoiData(VG)</code></pre><p>some data of the Voronoi geometry <code>VG</code> is extracted. Once applied, the data set contains at least the following informations:</p><ul><li><code>nodes::Vector{T}</code>: The original nodes</li><li><code>neighbors::Vector{Vector{Int64}}</code>: For each node <code>nodes[i]</code> the field <code>neighbors[i]</code> contains a sorted list of indeces of all neighboring cells.      Multiple appearence of the same node is possible on a periodic grid. </li></ul><p><strong>Fields in <code>VoronoiData</code></strong></p><p>Conditionally on what the <code>VoronoiGeometry</code> <code>VG</code> was told to calculate, the set <code>data</code> contains the following additional information:</p><ul><li><code>volume::Vector{Float64}</code>: the volume for each node</li><li><code>area::Vector{Vector{Float64}}</code>: stores for each neighbor <code>neighbors[i][k]</code> of node <code>i</code> in <code>area[i][k]</code> the area of the interface.</li><li><code>bulk_integral::Vector{Vector{Float64}}</code>: the integral over the bulk function</li><li><code>interface_integral::Vector{Vector{Vector{Float64}}}</code>: same as for <code>area</code> but with the integral values of the interface function. In paricular    <code>interface_integral[i][k]</code> is of type <code>Vector{Float64}</code></li></ul><div class="admonition is-warning"><header class="admonition-header">No request implies empty data field</header><div class="admonition-body"><p>If the four above data fieds where not requested to be calculated, the vectors have length <code>0</code> and any attempt to access their values will eventually result in an error message. </p></div></div><p><strong>Named Arguments</strong></p><p>The call of <code>VoronoiData(VG)</code> provides the following options:</p><ul><li><code>view_only=false</code>: If <code>true</code> this implies that for <code>nodes</code>,<code>volume</code>,<code>area</code>,<code>bulk_integral</code> and <code>interface_integral</code> only views on the internally stored data will be provided.   When set to <code>false</code>, deep copies of the of the internal data will be provided. <code>neighbors</code> will always be explicitly defined within this dataset only (i.e. no <code>view</code>)</li><li><code>reduce_to_periodic=true</code>: This erases all data generated from the periodization. It is highly advised to set this option to <code>true</code>   as the user will then only see the periodic mesh as one would expect it.</li><li><code>getorientations=false</code>: This is set automatically to <code>true</code> once <code>reduce_to_periodic==true</code>. Once set <code>true</code> the result contains the field        <code>orientations::Vector{Vector{T}}</code>,    <code>T</code> being the type of d-dimensional vectors originally provided by the nodes of the grid.    </li><li><code>getvertices=false</code>: Set to <code>true</code> the field <code>vertices::Vector{Dict{Vector{Int64},T}}</code> will for each node <code>i</code> contain a dictionary <code>[nodes]=&gt;coordinate</code>.   furthermore, the field <code>boundary_verteces::Dict{Vector{Int64},boundary_vertex{T}}</code> will contain a list of edges that go to infinity</li><li><code>getboundarynodes=false</code>: Set to <code>true</code> the field <code>boundary_nodes::Dict{Int64,Dict{Int64,T}}</code> will contain a dictionary    <code>node=&gt;Dict(boundary=&gt;point)</code>, where boundary is the index <code>boundary = length(nodes) + number_of_boundary_plane</code>. When <code>onboundary==false</code> then <code>point</code>    will be mirrored version of <code>nodes[node]</code> at the boundary plane <code>number_of_boundary_plane</code>. Otherwise, <code>point</code> is the center of <code>nodes[node]</code> and its mirrored version </li><li><code>onboundary=false</code>: Explained in the last topic. Furthermore, the value is stored in <code>boundary_nodes_on_boundary::Bool</code> </li><li><code>sorted=true</code>: During the reduction of the internal pseude periodic mesh to the fully periodic output, the neighbors (jointly with their respective properties) get sorted by their numbers</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinheida/HighVoronoi.jl/blob/e00f3cc7fdaff6516609540c97c0d3619951f61a/src/geometry.jl#L643-L682">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../workflowmesh/">« Workflow</a><a class="docs-footer-nextpage" href="../improving/">Improving Voronoi meshes for FV  »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Monday 18 March 2024 06:24">Monday 18 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
