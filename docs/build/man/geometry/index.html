<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Creating and handling the Voronoi geometry · HighVoronoi Documentation</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">HighVoronoi Documentation</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../short/">In short...</a></li><li class="is-active"><a class="tocitem" href>Creating and handling the Voronoi geometry</a><ul class="internal"><li><a class="tocitem" href="#Storage"><span>Storage</span></a></li><li><a class="tocitem" href="#Extraction-of-VoronoiData-data-for-further-processing"><span>Extraction of <code>VoronoiData</code> data for further processing</span></a></li></ul></li><li><a class="tocitem" href="../boundaries/">Boundaries</a></li><li><a class="tocitem" href="../refine/">Refinement and Substitution of Subdomains</a></li><li><a class="tocitem" href="../periodic/">Highspeed periodic geometries</a></li><li><a class="tocitem" href="../functions/">FunctionComposer</a></li><li><a class="tocitem" href="../finitevolume/">Finite Volume Problems</a></li><li><a class="tocitem" href="../projection/">Projection operators</a></li><li><a class="tocitem" href="../metapost/">2D-Output using MetaPost</a></li></ul></li><li><a class="tocitem" href="../../showcase/">Intentions of use (EXAMPLES)</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Creating and handling the Voronoi geometry</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Creating and handling the Voronoi geometry</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Creating-and-handling-the-Voronoi-geometry"><a class="docs-heading-anchor" href="#Creating-and-handling-the-Voronoi-geometry">Creating and handling the Voronoi geometry</a><a id="Creating-and-handling-the-Voronoi-geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-and-handling-the-Voronoi-geometry" title="Permalink"></a></h1><p>The most basic thing is the creation of a list of Points. We advise to use the following:</p><article class="docstring"><header><a class="docstring-binding" id="HighVoronoi.VoronoiNodes-Tuple{Matrix}" href="#HighVoronoi.VoronoiNodes-Tuple{Matrix}"><code>HighVoronoi.VoronoiNodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">VoronoiNodes(x::Matrix)</code></pre><p>also available in the forms</p><pre><code class="nohighlight hljs">VoronoiNodes(x::Vector{&lt;:Vector})
VoronoiNodes(x::Vector{&lt;:SVector})</code></pre><p>creates a list of points (as static vectors) from a matrix.</p><p><strong>Example: 100 Points in <span>$(0,1)^3$</span></strong></p><pre><code class="nohighlight hljs">data = rand(3,100)
points = VoronoiNodes(data)</code></pre></div></section></article><p>The creation and storage of Voronoi geometry data is handled by the following class. </p><article class="docstring"><header><a class="docstring-binding" id="HighVoronoi.VoronoiGeometry" href="#HighVoronoi.VoronoiGeometry"><code>HighVoronoi.VoronoiGeometry</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VoronoiGeometry{T}</code></pre><p>This is the fundamental struct to store information about the generated Voronoi grid. The geometric data can be accessed using the type <code>VoronoiData</code>.  However, there is always the possibility to access the data also via the following fields:</p><ul><li>Integrator.Integral: stores the integrated values in terms of a <code>Voronoi_Integral</code></li><li>basic_mesh: stores the fundamental data of nodes and verteces. also stored in Integrator.Integral.MESH</li><li>nodes: direct reference to the nodes. Also provided in basic_mesh.nodes</li></ul><div class="admonition is-warning"><header class="admonition-header">Avoid direct access to the data</header><div class="admonition-body"><p>Accessing the data directly, that is without calling <code>VoronoiData</code>, is likely to cause confusion or to provide &quot;wrong&quot; information.  The reason is that particularly for periodic boundary conditions, the mesh is enriched by a periodization of the boundary nodes.  These nodes are lateron dropped by the VoronoiData-Algorithm.       </p></div></div></div></section></article><p>To create a Voronoi mesh it is most convenient to call either of the following methods</p><article class="docstring"><header><a class="docstring-binding" id="HighVoronoi.VoronoiGeometry-Tuple{}" href="#HighVoronoi.VoronoiGeometry-Tuple{}"><code>HighVoronoi.VoronoiGeometry</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">VoronoiGeometry(xs::Points,b::Boundary)</code></pre><p>This creates a Voronoi mesh from the points <code>xs</code> given e.g. as an array of <code>SVector</code> and a boundary <code>b</code> that might be constructed using  the commands in the Boundaries section.</p><p>You have the following optional commands:</p><ul><li><code>integrator</code>: can be either one of the following values:<ul><li><code>VI_GEOMETRY</code>: Only the basic properties of the mesh are provided: the verteces implying a List of neighbors of each node</li><li><code>VI_MONTECARLO</code>: Volumes, interface areas and integrals are calculated using a montecarlo algorithm.    This particular integrator comes up with the following additional paramters:<ul><li><code>mc_accurate=(int1,int2,int3)</code>: Montecarlo integration takes place in <code>int1</code> directions, over <code>int2</code>    volumetric samples (vor volume integrals only). It reuses the same set of directions <code>int3</code>-times to save memory allocation time.   Standard setting is: <code>(1000,100,20)</code>.</li></ul></li><li><code>VI_POLYGON</code>: We use the polygon structure of the mesh to calculate the exact values of interface area and volume. The    integral over functions is calculated using the values at the center, the verteces and linear interpolation between.  </li><li><code>VI_HEURISTIC</code>:</li></ul></li><li><code>integrand</code>: This is a function <code>f(x)</code> depending on one spatial variable <code>x</code> returning a <code>Vector{Float64}</code>.    The integrated values will be provided for each cell and for each pair of neighbors, i.e. for each interface</li><li><code>periodic_grid</code>: This will initiate a special internal routine to fastly create a periodic grid. Look up the section in the documentation. </li></ul><p><strong>Advanced methods</strong></p><pre><code class="nohighlight hljs">VoronoiGeometry(file::String)
VoronoiGeometry(VG::VoronoiGeometry)</code></pre><p>Loads a Voronoi mesh from the <code>file</code> or copies it from the original data <code>VG</code>. If <code>integrator</code> is not provided, it will use the original integrator stored to the file.  In the second case, if integrand is not provided explicitly, it will use <code>integrand = VG.integrand</code> as standard. Additionally it has the following options:</p><ul><li><code>_myopen=jldopen</code>: the method to use to open the file. See the section on <code>write_jld</code>.</li><li><code>offset</code>: See the section on <code>write_jld</code>.</li><li><code>integrate=false</code>: This will or will not call the integration method after loading/copying the data. Makes sense for using <code>VI_HEURISTIC</code> together with       <code>volume=true</code>, <code>area=true</code> and providing values for <code>integrand</code> and <code>integrand</code>. If <code>integrand != nothing</code> but <code>bulk==false</code> or <code>interface==false</code>        this parameter will internally be set <code>true</code>.</li><li><code>volume=true</code>: Load volume data from file</li><li><code>area=true</code>: Load interface area data from file</li><li><code>bulk=false</code>: Load integrated function values on the cell volumes from file. When set <code>true</code> and <code>integrand=f</code> is provided    the method  will compare the dimension of <code>f</code> and of the stored data. </li><li><code>interface=false</code>: Load integrated function values on the interfaces. When set <code>true</code> and <code>integrand=f</code> is provided    the method  will compare the dimension of <code>f</code> and of the stored data.</li></ul></div></section></article><h2 id="Storage"><a class="docs-heading-anchor" href="#Storage">Storage</a><a id="Storage-1"></a><a class="docs-heading-anchor-permalink" href="#Storage" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HighVoronoi.write_jld-Tuple{}" href="#HighVoronoi.write_jld-Tuple{}"><code>HighVoronoi.write_jld</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The data can be stored using the <code>write_jld</code> method:</p><pre><code class="nohighlight hljs">write_jld(Geo::VoronoiGeometry,filename,offset=&quot;&quot;;_myopen=jldopen)
write_jld(Geo::VoronoiGeometry,file,offset=&quot;&quot;)</code></pre><p>stores the complete information of a VoronoiGeometry object to a file. This information can later be retrieved using the <code>VoronoiGeometry(file::String, args...)</code> function.</p><ul><li><code>Geo</code>: The Voronoi geometry object to be stored</li><li><code>filename</code>: name of file to store in</li><li><code>file</code>: A file given in a format supporting <code>write(file,&quot;tagname&quot;,content)</code> and <code>read(file,&quot;tagname&quot;,content)</code> </li><li><code>offset</code>: If several Geometry objects are to be stored in the same file, this will be the possibility to identify each one by a unique name. In particular, this is the key to store several objects in one single file.</li><li><code>_myopen</code>: a method that allows the syntax <code>_myopen(filename,&quot;w&quot;) do myfile ....... end</code>. By default the method uses the <code>JLD2</code> library as this (at the point of publishing this package) has the least problems with converting internal data structure to an output format.</li></ul><div class="admonition is-warning"><header class="admonition-header">Filname extension</header><div class="admonition-body"><p>If you want to use the default method, then the filename should end on <code>.jld</code>. Otherwise there might be confusion by the abstract built in julia loading algorithm.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HighVoronoi.load_Voronoi_info-Tuple{}" href="#HighVoronoi.load_Voronoi_info-Tuple{}"><code>HighVoronoi.load_Voronoi_info</code></a> — <span class="docstring-category">Method</span></header><section><div><p>If you want to make sure that the data you load will be rich enough, compact information can be retrieved as follows:</p><pre><code class="nohighlight hljs">load_Voronoi_info(filname,offset=&quot;&quot;)</code></pre><p>This will print out compact information of the data stored in file <code>filename</code> and the offset <code>offset</code>. Yields dimension, number of nodes, number of internal nodes and the dimension of the stored integrated data. Note that the latter information is of particular importance since here is the highest risk for the user to mess up stored data with the algorithm.</p></div></section></article><h2 id="Extraction-of-VoronoiData-data-for-further-processing"><a class="docs-heading-anchor" href="#Extraction-of-VoronoiData-data-for-further-processing">Extraction of <code>VoronoiData</code> data for further processing</a><a id="Extraction-of-VoronoiData-data-for-further-processing-1"></a><a class="docs-heading-anchor-permalink" href="#Extraction-of-VoronoiData-data-for-further-processing" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HighVoronoi.VoronoiData" href="#HighVoronoi.VoronoiData"><code>HighVoronoi.VoronoiData</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Using the call </p><pre><code class="nohighlight hljs">data=VoronoiData(VG)</code></pre><p>some data of the Voronoi geometry <code>VG</code> is extracted. Once applied, the data set contains at least the following informations:</p><ul><li><code>nodes::Vector{T}</code>: The original nodes</li><li><code>neighbors::Vector{Vector{Int64}}</code>: For each node <code>nodes[i]</code> the field <code>neighbors[i]</code> contains a sorted list of indeces of all neighboring cells.      Multiple appearence of the same node is possible on a periodic grid. </li></ul><p><strong>Fields in <code>VoronoiData</code></strong></p><p>Conditionally on what the <code>VoronoiGeometry</code> <code>VG</code> was told to calculate, the set <code>data</code> contains the following additional information:</p><ul><li><code>volume::Vector{Float64}</code>: the volume for each node</li><li><code>area::Vector{Vector{Float64}}</code>: stores for each neighbor <code>neighbors[i][k]</code> of node <code>i</code> in <code>area[i][k]</code> the area of the interface.</li><li><code>bulk_integral::Vector{Vector{Float64}}</code>: the integral over the bulk function</li><li><code>interface_integral::Vector{Vector{Vector{Float64}}}</code>: same as for <code>area</code> but with the integral values of the interface function. In paricular    <code>interface_integral[i][k]</code> is of type <code>Vector{Float64}</code></li></ul><div class="admonition is-warning"><header class="admonition-header">No request implies empty data field</header><div class="admonition-body"><p>If the four above data fieds where not requested to be calculated, the vectors have length <code>0</code> and any attempt to access their values will eventually result in an error message. </p></div></div><p><strong>Named Arguments</strong></p><p>The call of <code>VoronoiData(VG)</code> provides the following options:</p><ul><li><code>view_only=false</code>: If <code>true</code> this implies that for <code>nodes</code>,<code>volume</code>,<code>area</code>,<code>bulk_integral</code> and <code>interface_integral</code> only views on the internally stored data will be provided.   When set to <code>false</code>, deep copies of the of the internal data will be provided. <code>neighbors</code> will always be explicitly defined within this dataset only (i.e. no <code>view</code>)</li><li><code>reduce_to_periodic=true</code>: This erases all data generated from the periodization. It is highly advised to set this option to <code>true</code>   as the user will then only see the periodic mesh as one would expect it.</li><li><code>getorientations=false</code>: This is set automatically to <code>true</code> once <code>reduce_to_periodic==true</code>. Once set <code>true</code> the result contains the field        <code>orientations::Vector{Vector{T}}</code>,    <code>T</code> being the type of d-dimensional vectors originally provided by the nodes of the grid.    </li><li><code>getverteces=false</code>: Set to <code>true</code> the field <code>verteces::Vector{Dict{Vector{Int64},T}}</code> will for each node <code>i</code> contain a dictionary <code>[nodes]=&gt;coordinate</code>.   furthermore, the field <code>boundary_verteces::Dict{Vector{Int64},boundary_vertex{T}}</code> will contain a list of edges that go to infinity</li><li><code>getboundarynodes=false</code>: Set to <code>true</code> the field <code>boundary_nodes::Dict{Int64,Dict{Int64,T}}</code> will contain a dictionary    <code>node=&gt;Dict(boundary=&gt;point)</code>, where boundary is the index <code>boundary = length(nodes) + number_of_boundary_plane</code>. When <code>onboundary==false</code> then <code>point</code>    will be mirrored version of <code>nodes[node]</code> at the boundary plane <code>number_of_boundary_plane</code>. Otherwise, <code>point</code> is the center of <code>nodes[node]</code> and its mirrored version </li><li><code>onboundary=false</code>: Explained in the last topic. Furthermore, the value is stored in <code>boundary_nodes_on_boundary::Bool</code> </li><li><code>sorted=true</code>: During the reduction of the internal pseude periodic mesh to the fully periodic output, the neighbors (jointly with their respective properties) get sorted by their numbers</li></ul></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../short/">« In short...</a><a class="docs-footer-nextpage" href="../boundaries/">Boundaries »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Friday 14 April 2023 09:32">Friday 14 April 2023</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
