var documenterSearchIndex = {"docs":
[{"location":"man/boundaries/#allonboundaries","page":"Boundaries","title":"Boundaries","text":"","category":"section"},{"location":"man/boundaries/#The-Boundary-struct","page":"Boundaries","title":"The Boundary struct","text":"","category":"section"},{"location":"man/boundaries/","page":"Boundaries","title":"Boundaries","text":"In what follows we describe how boundaries are implemented in the calculation of Voronoi meshes. Handling boundaries within HighVoronoi is done using the following struct.","category":"page"},{"location":"man/boundaries/","page":"Boundaries","title":"Boundaries","text":"Boundary","category":"page"},{"location":"man/boundaries/#HighVoronoi.Boundary","page":"Boundaries","title":"HighVoronoi.Boundary","text":"Boundary\n\nprovides the data structure for boundaries of VoronoiGeometry. Its most important feature is the vector\n\nplanes::Vector{Plane}\n\nwhich stores every flat part of the boundary as\n\nstruct Plane\n    base::Vector{Float64} # base of the plane\n    normal::Vector{Float64} # outer normal of the domain on this plane\n    BC::Int16 # 0 for Dirichlet, -1 for Neumann and >0 for the index of the other correspondant in case this is supposed to be periodic\nend\n\n\n\n\n\n","category":"type"},{"location":"man/boundaries/#createboundary","page":"Boundaries","title":"Creating Boundaries","text":"","category":"section"},{"location":"man/boundaries/","page":"Boundaries","title":"Boundaries","text":"Apart from cuboids, Boundary should always be generated using the following method:","category":"page"},{"location":"man/boundaries/","page":"Boundaries","title":"Boundaries","text":"Boundary(planes...)","category":"page"},{"location":"man/boundaries/#HighVoronoi.Boundary-Tuple","page":"Boundaries","title":"HighVoronoi.Boundary","text":"Boundary(planes...)\n\nis the constructor for Boundaries. planes... is a list of planes generated by either one of the following functions:\n\nBC_Dirichlet(b,n)\nBC_Neumann(b,n)\n\ngenerating Dirichlet resp. Neumann boundaries with base b and normal n.\n\nBC_Periodic(base1,base2,normal1)\n\ngenerating two periodic boundaries with base1 and normal1  resp. with base2 and normal = -normal1 \n\n\n\n\n\n","category":"method"},{"location":"man/boundaries/#Rectangular-domains","page":"Boundaries","title":"Rectangular domains","text":"","category":"section"},{"location":"man/boundaries/","page":"Boundaries","title":"Boundaries","text":"For simplicity of application, the following methods are provided for boundaries of rectangular domains. They return an object of type b::Boundary with the following structure:","category":"page"},{"location":"man/boundaries/","page":"Boundaries","title":"Boundaries","text":"For every iin 1mathrmdim ","category":"page"},{"location":"man/boundaries/","page":"Boundaries","title":"Boundaries","text":"the plane b.plane[2*i-1] has base mathrmoffseti+e_i*mathrmdimensionsi and normal e_i\nthe plane b.plane[2*i] has base mathrmoffseti and normal -e_i","category":"page"},{"location":"man/boundaries/","page":"Boundaries","title":"Boundaries","text":"cuboid(dim;dimensions=ones(Float64,dim),periodic=collect(1:dim),neumann=Int64[],offset=zeros(Float64,dim))","category":"page"},{"location":"man/boundaries/#HighVoronoi.cuboid-Tuple{Any}","page":"Boundaries","title":"HighVoronoi.cuboid","text":"cuboid(dim;dimensions=ones(Float64,dim),periodic=collect(1:dim),neumann=Int64[],offset=zeros(Float64,dim))\n\nor simply cuboid(dim) generates a cube of type Boundary. \n\ndim : This is the dimension of the cuboid\ndimensions : provides the size of the cuboid in each dimension\nperiodic : this is a (sorted!!) list of dimensions in which the cube is assumed to have periodic boundary conditions\nneumann : every dimension k=1...dim which is not periodic my be put here with positive sign for the right hand side or negative sign (i.e. -k) for the left hand side\noffset : shifts the cube in space  \n\nA particular application is the following method provided by HighVoronoi.\n\ncenter_cube(dim,size) = cuboid(dim,dimensions=size*ones(Float64,dim),offset=-0.5*size*ones(Float64,dim))\n\nRelying on cuboid(...) it generates a cube with center 0 and edge length size.\n\n\n\n\n\n","category":"method"},{"location":"man/boundaries/#Warnings","page":"Boundaries","title":"Warnings","text":"","category":"section"},{"location":"man/boundaries/","page":"Boundaries","title":"Boundaries","text":"warning: Using no boundaries in high dimensions\nwhen using no boundary planes the result \"at infinity\" i.e. for farout vertex points can be corrupted for high dimensions. This is because virtually every boundary point (a point with infinite cell) becomes neighbor with almost all other boundary points and the verteces reach out to very very very large coordinates compared to the original nodes coordinates. The Library provides internal algorithms to identify and correct misscalculations but this functionallity is, however, limited to the precission of Float64. We advise to implement a farout boundary (e.g. 1.0E6) compared to a cube of diameter 1.","category":"page"},{"location":"man/geometry/#Creating-and-handling-the-Voronoi-geometry","page":"Creating and handling the Voronoi geometry","title":"Creating and handling the Voronoi geometry","text":"","category":"section"},{"location":"man/geometry/","page":"Creating and handling the Voronoi geometry","title":"Creating and handling the Voronoi geometry","text":"The most basic thing is the creation of a list of Points. We advise to use the following:","category":"page"},{"location":"man/geometry/","page":"Creating and handling the Voronoi geometry","title":"Creating and handling the Voronoi geometry","text":"VoronoiNodes(x::Matrix)","category":"page"},{"location":"man/geometry/#HighVoronoi.VoronoiNodes-Tuple{Matrix}","page":"Creating and handling the Voronoi geometry","title":"HighVoronoi.VoronoiNodes","text":"VoronoiNodes(x::Matrix)\n\nalso available in the forms\n\nVoronoiNodes(x::Vector{<:Vector})\nVoronoiNodes(x::Vector{<:SVector})\n\ncreates a list of points (as static vectors) from a matrix.\n\nExample: 100 Points in (01)^3\n\ndata = rand(3,100)\npoints = VoronoiNodes(data)\n\n\n\n\n\n","category":"method"},{"location":"man/geometry/","page":"Creating and handling the Voronoi geometry","title":"Creating and handling the Voronoi geometry","text":"The creation and storage of Voronoi geometry data is handled by the following class. ","category":"page"},{"location":"man/geometry/","page":"Creating and handling the Voronoi geometry","title":"Creating and handling the Voronoi geometry","text":"VoronoiGeometry{T}","category":"page"},{"location":"man/geometry/#HighVoronoi.VoronoiGeometry","page":"Creating and handling the Voronoi geometry","title":"HighVoronoi.VoronoiGeometry","text":"VoronoiGeometry{T}\n\nThis is the fundamental struct to store information about the generated Voronoi grid. The geometric data can be accessed using the type VoronoiData.  However, there is always the possibility to access the data also via the following fields:\n\nIntegrator.Integral: stores the integrated values in terms of a Voronoi_Integral\nbasic_mesh: stores the fundamental data of nodes and verteces. also stored in Integrator.Integral.MESH\nnodes: direct reference to the nodes. Also provided in basic_mesh.nodes\n\nwarning: Avoid direct access to the data\nAccessing the data directly, that is without calling VoronoiData, is likely to cause confusion or to provide \"wrong\" information.  The reason is that particularly for periodic boundary conditions, the mesh is enriched by a periodization of the boundary nodes.  These nodes are lateron dropped by the VoronoiData-Algorithm.       \n\n\n\n\n\n","category":"type"},{"location":"man/geometry/","page":"Creating and handling the Voronoi geometry","title":"Creating and handling the Voronoi geometry","text":"To create a Voronoi mesh it is most convenient to call either of the following methods","category":"page"},{"location":"man/geometry/","page":"Creating and handling the Voronoi geometry","title":"Creating and handling the Voronoi geometry","text":"VoronoiGeometry()","category":"page"},{"location":"man/geometry/#HighVoronoi.VoronoiGeometry-Tuple{}","page":"Creating and handling the Voronoi geometry","title":"HighVoronoi.VoronoiGeometry","text":"VoronoiGeometry(xs::Points,b::Boundary)\n\nThis creates a Voronoi mesh from the points xs given e.g. as an array of SVector and a boundary b that might be constructed using  the commands in the Boundaries section.\n\nYou have the following optional commands:\n\nintegrator: can be either one of the following values:\nVI_GEOMETRY: Only the basic properties of the mesh are provided: the verteces implying a List of neighbors of each node\nVI_MONTECARLO: Volumes, interface areas and integrals are calculated using a montecarlo algorithm.    This particular integrator comes up with the following additional paramters:\nmc_accurate=(int1,int2,int3): Montecarlo integration takes place in int1 directions, over int2    volumetric samples (vor volume integrals only). It reuses the same set of directions int3-times to save memory allocation time.   Standard setting is: (1000,100,20).\nVI_POLYGON: We use the polygon structure of the mesh to calculate the exact values of interface area and volume. The    integral over functions is calculated using the values at the center, the verteces and linear interpolation between.  \nVI_HEURISTIC:\nintegrand: This is a function f(x) depending on one spatial variable x returning a Vector{Float64}.    The integrated values will be provided for each cell and for each pair of neighbors, i.e. for each interface\n\nAdvanced methods\n\nVoronoiGeometry(file::String)\nVoronoiGeometry(VG::VoronoiGeometry)\n\nLoads a Voronoi mesh from the file or copies it from the original data VG. If integrator is not provided, it will use the original integrator stored to the file.  In the second case, if integrand is not provided explicitly, it will use integrand = VG.integrand as standard. Additionally it has the following options:\n\nintegrate=false: This will or will not call the integration method after loading/copying the data. Makes sense for using VI_HEURISTIC together with       volume=true, area=true and providing values for integrand and integrand. If integrand != nothing but bulk==false or interface==false        this parameter will internally be set true.\nvolume=true: Load volume data from file\narea=true: Load interface area data from file\nbulk=false: Load integrated function values on the cell volumes from file. When set true and integrand=f is provided    the method  will compare the dimension of f and of the stored data. \ninterface=false: Load integrated function values on the interfaces. When set true and integrand=f is provided    the method  will compare the dimension of f and of the stored data.\nVoronoiGeometry(matrix_data,p::PeriodicVoronoiBasis) \n\nTakes matrix_data, which is a matrix with dimension rows and numberOfNodes points and p=PeriodicVoronoiBasis(). It then requires the following keyword arguments:\n\ndimensions = ones(Float64,size(matrix_data,1)): all points in matrix_data are assumed to be placed inside the box given by the origin and this point.\nstretchfactors = ones(Float64,size(matrix_data,1))): the data is internally multiplied by diagm(stretchfactors)\n\nThe overall purpose of this method is to generate a periodized version of the block dimensions with points matrix_data in each space dimension. The resulting data lies within  the box given by the origin and 2 * diagm(stretchfactors) * dimensions. Furthermore, a Voronoi tessellation of this box is calculated with fixed (Dirichlet-) boundary. Volumes and areas  are obtained using VI_POLYGON.\n\nThe result can serve as initial data for the following method:\n\n\n\n\n\n","category":"method"},{"location":"man/geometry/#Storage","page":"Creating and handling the Voronoi geometry","title":"Storage","text":"","category":"section"},{"location":"man/geometry/","page":"Creating and handling the Voronoi geometry","title":"Creating and handling the Voronoi geometry","text":"write_jld()","category":"page"},{"location":"man/geometry/#HighVoronoi.write_jld-Tuple{}","page":"Creating and handling the Voronoi geometry","title":"HighVoronoi.write_jld","text":"The data can be stored using the write_jld method:\n\nwrite_jld(Geo::VoronoiGeometry,filename,offset=\"\")\n\nstores the complete information of a VoronoiGeometry object to a file. This information can later be retrieved using the VoronoiGeometry(file::String, args...) function.\n\nGeo: The Voronoi geometry object to be stored\nfilename: name of file to store in\noffset: If several Geometry objects are to be stored in the same file, this will be the possibility to identify each one by a unique name. In particular, this is the key to store several objects in one single file.\n\nwarning: Filname extension\nThe filename needs to end on .jld. Otherwise there might be confusion by the loading algorithm.\n\n\n\n\n\n","category":"method"},{"location":"man/geometry/","page":"Creating and handling the Voronoi geometry","title":"Creating and handling the Voronoi geometry","text":"load_Voronoi_info()","category":"page"},{"location":"man/geometry/#HighVoronoi.load_Voronoi_info-Tuple{}","page":"Creating and handling the Voronoi geometry","title":"HighVoronoi.load_Voronoi_info","text":"If you want to make sure that the data you load will be rich enough, compact information can be retrieved as follows:\n\nload_Voronoi_info(filname,offset=\"\")\n\nThis will print out compact information of the data stored in file filename and the offset offset. Yields dimension, number of nodes, number of internal nodes and the dimension of the stored integrated data. Note that the latter information is of particular importance since here is the highest risk for the user to mess up stored data with the algorithm.\n\n\n\n\n\n","category":"method"},{"location":"man/geometry/#Extraction-of-VoronoiData-data-for-further-processing","page":"Creating and handling the Voronoi geometry","title":"Extraction of VoronoiData data for further processing","text":"","category":"section"},{"location":"man/geometry/","page":"Creating and handling the Voronoi geometry","title":"Creating and handling the Voronoi geometry","text":"VoronoiData","category":"page"},{"location":"man/geometry/#HighVoronoi.VoronoiData","page":"Creating and handling the Voronoi geometry","title":"HighVoronoi.VoronoiData","text":"Using the call \n\ndata=VoronoiData(VG)\n\nsome data of the Voronoi geometry VG is extracted. Once applied, the data set contains at least the following informations:\n\nnodes::Vector{T}: The original nodes\nneighbors::Vector{Vector{Int64}}: For each node nodes[i] the field neighbors[i] contains a sorted list of indeces of all neighboring cells.      Multiple appearence of the same node is possible on a periodic grid. \n\nFields in VoronoiData\n\nConditionally on what the VoronoiGeometry VG was told to calculate, the set data contains the following additional information:\n\nvolume::Vector{Float64}: the volume for each node\narea::Vector{Vector{Float64}}: stores for each neighbor neighbors[i][k] of node i in area[i][k] the area of the interface.\nbulk_integral::Vector{Vector{Float64}}: the integral over the bulk function\ninterface_integral::Vector{Vector{Vector{Float64}}}: same as for area but with the integral values of the interface function. In paricular    interface_integral[i][k] is of type Vector{Float64}\n\nwarning: No request implies empty data field\nIf the four above data fieds where not requested to be calculated, the vectors have length 0 and any attempt to access their values will eventually result in an error message. \n\nNamed Arguments\n\nThe call of VoronoiData(VG) provides the following options:\n\nview_only=false: If true this implies that for nodes,volume,area,bulk_integral and interface_integral only views on the internally stored data will be provided.   When set to false, deep copies of the of the internal data will be provided. neighbors will always be explicitly defined within this dataset only (i.e. no view)\nreduce_to_periodic=true: This erases all data generated from the periodization. It is highly advised to set this option to true   as the user will then only see the periodic mesh as one would expect it.\ngetorientations=false: This is set automatically to true once reduce_to_periodic==true. Once set true the result contains the field        orientations::Vector{Vector{T}},    T being the type of d-dimensional vectors originally provided by the nodes of the grid.    \ngetverteces=false: Set to true the field verteces::Vector{Dict{Vector{Int64},T}} will for each node i contain a dictionary [nodes]=>coordinate.   furthermore, the field boundary_verteces::Dict{Vector{Int64},boundary_vertex{T}} will contain a list of edges that go to infinity\ngetboundarynodes=false: Set to true the field boundary_nodes::Dict{Int64,Dict{Int64,T}} will contain a dictionary    node=>Dict(boundary=>point), where boundary is the index boundary = length(nodes) + number_of_boundary_plane. When onboundary==false then point    will be mirrored version of nodes[node] at the boundary plane number_of_boundary_plane. Otherwise, point is the center of nodes[node] and its mirrored version \nonboundary=false: Explained in the last topic. Furthermore, the value is stored in boundary_nodes_on_boundary::Bool \nsorted=true: During the reduction of the internal pseude periodic mesh to the fully periodic output, the neighbors (jointly with their respective properties) get sorted by their numbers\n\n\n\n\n\n","category":"type"},{"location":"showcase/#intentions","page":"Intentions of use (EXAMPLES)","title":"Using the HighVoronoi Library","text":"","category":"section"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"We collect some examples how the package is meant to be applied.","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"tip: SKIP ''Mesh generation'' and study the ''Finite Volume methods'' section first\nIf you are interested in Finite Volume methods but you do not want to go to much into details on mesh generation, you may skipt this first part. However, for setting up several different problems on large dimensions, recycling mesh data and using mesh refinement techniques, it is strongly advised to study the capabilities of the VoronoiGeometry data structure in a second approach.","category":"page"},{"location":"showcase/#Mesh-generation-and-integration","page":"Intentions of use (EXAMPLES)","title":"Mesh generation and integration","text":"","category":"section"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"Mesh generation in form of a VoronoiGeometry relies on the following data: A set of points (VoronoiNodes), a boundary (Boundary, cuboid), the choice of an integrator method and the optional choice of a function to be integrated (integrand = x->...). Points and boundaries can also be retrieved from a formerly calculated VoronoiGeometry.","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"The intentions how this is done are demonstrated in the following examples:","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"Example 1: Basics\nExample 2: Integration on fully periodic grid\nExample 3: Non-periodic bounded domain with data storage\nExample 4: Load and integrate new function\nExample 5: Copy and integrate new function\nExample 6: Mesh-Refinement\nExample 7: Mesh-Refinement with locally new integrand","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"Future extensions imply the fast, efficient generation of large quasi-periodic meshes in high dimensions. These meshes shall then be locally refined according to the user's needs. ","category":"page"},{"location":"showcase/#Mgi1","page":"Intentions of use (EXAMPLES)","title":"Example 1: Basics","text":"","category":"section"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"Generate a 3D mesh of 100 Points with no boundary. Calculates only verteces and neighbors.","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"xs = VoronoiNodes( rand(3,100) )\r\nvg = VoronoiGeometry(xs, integrator=HighVoronoi.VI_GEOMETRY)\r\nvd = VoronoiData(vg, getverteces=true)   \r\n# vd.neighbors contains for each node `i` a list of all neighbors\r\n# vd.verteces contains for each node `i` a list of all verteces that define the cell.","category":"page"},{"location":"showcase/#Mgi2","page":"Intentions of use (EXAMPLES)","title":"Example 2: Integration on fully periodic grid","text":"","category":"section"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"Generate a 5D mesh of 1000 points with periodic boundary conditions on a unit cube (01)^5. It then uses triangulation integration to integrate the function","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"xmapstoleft(beginarraycx  x_1x_2endarrayright)","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"For general polygon domains see here. ","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"xs2 = VoronoiNodes( rand(5,1000) )\r\nvg2 = VoronoiGeometry(xs2, cuboid(5), integrator=HighVoronoi.VI_POLYGON, integrand = x->[norm(x),x[1]*x[2]])\r\nvd2 = VoronoiData(vg2)    ","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"vd2.volume[i] and vd2.bulk_integral[i] contain the volume of cell i and the integral of integrand over cell i\nvd2.neighbors[i] contains an array of all neighbors of i. \nfor each j the field vd2.area[i][j] contains the interface area between i and vd2.neighbors[i][j].\nfor each j the field vd2.interface_integral[i][j] contains the integral of integrand over    the interface area between i and vd2.neighbors[i][j].","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"note: \nIf jnot=k but vd2.neighbors[i][j]==vd2.neighbors[i][k]  this means that i shares two differnt interfaces with n=vd2.neighbors[i][j].  This happens due to periodicity and low number of nodes in relation to the dimension.","category":"page"},{"location":"showcase/#Mgi3","page":"Intentions of use (EXAMPLES)","title":"Example 3: Non-periodic bounded domain with data storage","text":"","category":"section"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"Like Example 2 but we store and load the data:","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"xs3 = VoronoiNodes( rand(5,1000) )\r\nvg3 = VoronoiGeometry(xs3, cuboid(5,periodic=[2]), integrator=HighVoronoi.VI_POLYGON, integrand = x->[norm(x),x[1]*x[2]])\r\nwrite_jld(vg3, \"my5Dexample.jld\")\r\nvg3_reload_vol = VoronoiGeometry(\"my5Dexample.jld\")","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"The mesh vg3 is periodic only in direction of e_2=(01000). The variable vg3_reload_vol now contains a copy of nodes, verteces, volumes and areas in vg3. It contains NOT the integral values.","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"vg3_a = VoronoiGeometry(\"my5Dexample.jld\", bulk=true, interface=true)","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"The variable vg3_a contains also the integrated values. However, the method will prompt a warning because no integrand is provided. Hence try the following:","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"vg3_modified = VoronoiGeometry(\"my5Dexample.jld\", bulk=true, interface=true, integrand = x->[x[5],sqrt(abs(x[3]))])\r\nvg3_full = VoronoiGeometry(\"my5Dexample.jld\", bulk=true, interface=true, integrand = x->[norm(x),x[1]*x[2]])","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"warning: \nThe method VoronoiGeometry(filename) DOES compare the dimensions of the integrand with the stored data. However, it DOES NOT compare wether the original and the newly provided function are the same.","category":"page"},{"location":"showcase/#Mgi4","page":"Intentions of use (EXAMPLES)","title":"Example 4: Load and integrate new function","text":"","category":"section"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"We can also recycle efficiently the stored geometry by using its volumes and interfaces and integrate another function using the VI_HEURISTIC integrator.","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"vg4 = VoronoiGeometry(\"my5Dexample.jld\", integrand = x->[x[1]*x[5],sqrt(abs(x[3])),sum(abs2,x)],integrator=HighVoronoi.VI_HEURISTIC)","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"This will cause a warning stating that the new integrator VI_HEURISTIC does not match the original integrator. Just ignore it. You can also use VI_POLYGON or VI_MONTECARLO but this will take much more time for the integration.","category":"page"},{"location":"showcase/#Mgi5","page":"Intentions of use (EXAMPLES)","title":"Example 5: Copy and integrate new function","text":"","category":"section"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"Similar to the last example, we may also directly copy vg3","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"vg5 = VoronoiGeometry(vg3, integrator=HighVoronoi.VI_HEURISTIC, integrand = x->[sum(abs2,x)])","category":"page"},{"location":"showcase/#Mgi6","page":"Intentions of use (EXAMPLES)","title":"Example 6: Mesh-Refinement","text":"","category":"section"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"Say the user has created or loaded a VoronoiGeometry and wants to add some more points. In our case, we create a partially periodic mesh in 3D with 1000 points in (01)^3 and afterwards add 100 Points in (001)^3 for higher resolution in this region.","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"vg6 = VoronoiGeometry( VoronoiNodes(rand(3,1000)), cuboid(3,periodic=[2]), \r\n                      integrand=x->[sum(abs,x)], integrator=HighVoronoi.VI_POLYGON)\r\nrefine!(vg6, VoronoiNodes(0.1.*rand(3,100)))                      ","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"If, for whatever reason, the user does not want the algorithm to update the volumes, areas, integrals, ... he may add the command update=false.","category":"page"},{"location":"showcase/#Mgi7","page":"Intentions of use (EXAMPLES)","title":"Example 7: Mesh-Refinement with locally new integrand","text":"","category":"section"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"We modify Example 6:","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"vg7 = VoronoiGeometry( VoronoiNodes(rand(3,1000)), cuboid(3,periodic=[2]), \r\n                      integrand=x->[sum(abs,x)], integrator=HighVoronoi.VI_POLYGON)\r\nvg7b = VoronoiGeometry( vg7, bulk=true, interface=true, integrand=x->[sqrt(sum(abs2,x))])\r\nrefine!(vg7b, VoronoiNodes(0.1.*rand(3,100)))                      ","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"Because bulk=true and interface=true, vg7b simply copies all data from vg7, including the integrated values of f(x)=[sum(abs,x)]. However, when the refine! function is called, the local integral on every modified interface and cell will be recalculated using the new function  f2(x)=[sqrt(sum(abs2,x))]. This means in the new cell we completly have integrated values of f2 while on old and non-modified  cells we still have integrated values of f. On cells that have been partially modified, the new integral is an interpolation between the old and the new function.","category":"page"},{"location":"showcase/#Finite-Volume-problems:-Generating-the-matrix-and-the-right-hand-side-from-data","page":"Intentions of use (EXAMPLES)","title":"Finite Volume problems: Generating the matrix and the right hand side from data","text":"","category":"section"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"The most simple way to implement a Finite Volume discretization within HighVoronoi is to provide","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"a list of nodes\na domain\na list of parameter functions to evaluated pointwise or in an averaged sense\na description of the flux in terms of the Voronoi mesh and the pointwise/averaged data\na description of right hand side in terms of the Voronoi mesh and the pointwise/averaged data\na description of the boundary conditions (note that periodic boundary conditions are in fact implemented as a part of the MESH and cannot be modified at this stage)","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"We provide the following two examples covering both intentions of use","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"Example 1: Most simple way from scratch\nExample 2: Relying on preexisting VoronoiGeometry","category":"page"},{"location":"showcase/#FVex1","page":"Intentions of use (EXAMPLES)","title":"Example 1: Most simple way from scratch","text":"","category":"section"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"We create #nop points within (01)^3 and prescribe (01)^3 as our domain for the mesh generation. We define functions kappa(x)=1+x^2 and f(x)=sin(2*pi*x_1). Then we make use of VoronoiFVProblem to set up the discrete equation","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"forall i qquad sum_jsim ip_iju_i-p_jiu_j=F_i","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"where","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"left(p_ijp_jiright)=mathrmmyflux=left(frac1x_i-x_jm_ij*sqrtkappa_ikappa_jfrac1x_i-x_jm_ij*sqrtkappa_ikappa_jright)qquad F_i=m_i*f(x_i)","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"This is a discretization of","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"-nablacdot(kappanabla u)=fqquadmathrmon(01)^3","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"As boundary conditions we implement for J=-kappanabla u and outer normal nu:","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"beginalign*\r\n1  u(x)  =sin(pi x_2)sin(pi x_3)  quadtexton   01times(01)^2\r\n2  u(x)  =0  quadtexton   (01)times01times(01)\r\n3  jcdotnu  =1  quadtexton   (01)^2times01\r\nendalign*","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"Accodring to the internal structure of the cube, BC 1. corresponds to the surface planes [1,2], BC 2. corresponds to the surface planes [3,4] and BC 3. correpsonds to the surface planes [5,6]. More information on boundaries is given here. ","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"using LinearAlgebra\r\nusing SpecialFunctions\r\nusing SparseArrays\r\n\r\nfunction myflux(;para_i,para_j,mass_ij,normal,kwargs...) \r\n    # kwargs... collects all additional parameters which are not used in the current function.\r\n    weight = norm(normal)^(-1) * mass_ij * sqrt(para_i[:kappa]*para_j[:kappa])\r\n    return weight, weight\r\nend\r\n\r\nmyRHS(;para_i,mass_i,kwargs...) = mass_i * para_i[:f] \r\n\r\n\r\nfunction test_FV_3D(nop)\r\n    vfvp = VoronoiFVProblem( VoronoiNodes( rand(3,nop) ), cuboid(3,periodic=[]), \r\n                                discretefunctions = (f=x->sin(2*pi*x[1]),), # evaluate f pointwise\r\n                                integralfunctions = (kappa=x->1.0+norm(x)^2,), # calculate averages of kappa over cells and interfaces\r\n                                fluxes = ( j1 = myflux, ),\r\n                                rhs_functions = (F = myRHS,) )\r\n    # turn functions that depend on x into the required HighVoronoi-format:\r\n    homogeneous = FVevaluate_boundary(x->0.0)\r\n    one = FVevaluate_boundary(x->1.0)\r\n    non_hom = FVevaluate_boundary(x->sin(pi*x[2])*sin(pi*x[3]))\r\n\r\n    r,c,v,f = linearVoronoiFVProblem(   vfvp, flux = :j1, rhs = :F, \r\n                                    Neumann = ([5,6],one), \r\n                                    Dirichlet = (([3,4],homogeneous), ([1,2],non_hom),), )\r\n    A = sparse(r,c,v) # a sparse matrix with rows `r`, coloumns `c` and values `v`\r\n    # solution_u = somelinearsolver(A,f)\r\n\r\nend\r\n\r\ntest_FV_3D(100)","category":"page"},{"location":"showcase/#FVex2","page":"Intentions of use (EXAMPLES)","title":"Example 2: Relying on preexisting VoronoiGeometry","text":"","category":"section"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"We build a 5D-mesh in the unit cube of 5000 points using VoronoiGeometry and store it for later use. Since we have plenty of time, we do it using the exact VI_POLYGON integrator.","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"write_jld( VoronoiGeometry( VoronoiNodes(rand(5,5000)), cuboid(5,periodic=[]), integrator=HighVoronoi.VI_POLYGON ), \"my5Dmesh.jld\" )","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"Next, we want to use this stored grid to immplement the above example in 5D, adding homogeneous Dirichlet conditions in the remaining dimensions. However, we also want :f to be evaluated in an averaged sence, not pointwise. Since we will need their specification in two places, we fix them once and for all:","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"my_functions = (f=x->sin(2*pi*x[1]), kappa=x->1.0+norm(x)^2,)","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"We need to integrate kappa and f the moment we load the geometry from file. To make sure the integrated data will match the needs of the Finite Volume algorithm, we use FunctionComposer:","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"composed_function = FunctionComposer(reference_argument=zeros(Float64,5), super_type=Float64; my_functions...).functions","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"The definitions of myflux and myRHS are independent from the dimension and can just be taken from above.","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"function test_FV_5D_from_file()_\r\n    my_functions = (f=x->sin(2*pi*x[1]), kappa=x->1.0+norm(x)^2,)\r\n    composed_function = FunctionComposer(   reference_argument=zeros(Float64,5), \r\n                                            super_type=Float64; my_functions...).functions\r\n\r\n    vg = VoronoiGeometry( \"my5Dmesh.jld\",   integrator = HighVoronoi.VI_HEURISTIC, \r\n                                            integrand = composed_function)\r\n\r\n    vfvp = VoronoiFVProblem( vg, integralfunctions = my_functions, \r\n                                 fluxes = ( j1 = myflux, ),\r\n                                 rhs_functions = (F = myRHS,) )\r\n\r\n    homogeneous = FVevaluate_boundary(x->0.0)\r\n    one = FVevaluate_boundary(x->1.0)\r\n    non_hom = FVevaluate_boundary(x->sin(pi*x[2])*sin(pi*x[3]))\r\n\r\n    r,c,v,f = linearVoronoiFVProblem(   vfvp, flux = :j1, rhs = :F, Neumann = ([5,6],one), \r\n                                Dirichlet = (([3,4,7,8,9,10],homogeneous), ([1,2],non_hom),), )\r\n    A = sparse(r,c,v) # a sparse matrix with rows `r`, coloumns `c` and values `v`\r\n    # solution_u = somelinearsolver(A,f)\r\nend","category":"page"},{"location":"man/functions/#Passing-function-arguments-to-VoronoiGeometry-and-VoronoiFVProblem","page":"FunctionComposer","title":"Passing function arguments to VoronoiGeometry and VoronoiFVProblem","text":"","category":"section"},{"location":"man/functions/","page":"FunctionComposer","title":"FunctionComposer","text":"info: Always glue functions with a FunctionComposer\nThe FunctionComposer is internally used to glue together real valued functions. Therefore, if a user wants to glue together functions and afterwards work with \"glued\" information generated from HighVoronoi, using FunctionComposer is the way unify internal and external calculations. ","category":"page"},{"location":"man/functions/#The-FunctionComposer-struct","page":"FunctionComposer","title":"The FunctionComposer struct","text":"","category":"section"},{"location":"man/functions/","page":"FunctionComposer","title":"FunctionComposer","text":"The FunctionComposer is the element implemented in HighVoronoi to concatenate several Float or Vector{Float} valued functions into one single Vector{Float}-valued function using vcat(...). It is built using a call of the following method.","category":"page"},{"location":"man/functions/","page":"FunctionComposer","title":"FunctionComposer","text":"FunctionComposer(;reference_argument, super_type, _functions...)","category":"page"},{"location":"man/functions/#HighVoronoi.FunctionComposer-Tuple{}","page":"FunctionComposer","title":"HighVoronoi.FunctionComposer","text":"FunctionComposer(;reference_argument, super_type, _functions...)\n\nThe composer takes the following arguments:\n\n_functions: This is a list of named funcions.\nsuper_type: suppose your functions return values of type T and Vector{T} you should set super_type=T\nreference_argument: Your functions take values of type Float and are well defined in 0.0? Then you can put e.g. 0.0 here.    If your function accepts StaticArray{3,Float64} put e.g. SVector{3,Float64}([0.0,1.2,3.4])\n\n\n\n\n\n","category":"method"},{"location":"man/functions/","page":"FunctionComposer","title":"FunctionComposer","text":"A typical example would be","category":"page"},{"location":"man/functions/","page":"FunctionComposer","title":"FunctionComposer","text":"f = FunctionComposer(reference_argument = [0.0,0.0,0.0], super_type = Float64, alpha = x->norm(x)*x, beta = x->sum(abs,x) )","category":"page"},{"location":"man/functions/","page":"FunctionComposer","title":"FunctionComposer","text":"or:","category":"page"},{"location":"man/functions/","page":"FunctionComposer","title":"FunctionComposer","text":"myfunctions=(alpha = x->norm(x)*x, beta = x->sum(abs,x))\r\nf = FunctionComposer(reference_argument = [0.0,0.0,0.0], super_type = Float64; myfunctions...  )","category":"page"},{"location":"man/functions/","page":"FunctionComposer","title":"FunctionComposer","text":"The latter has the advantage that you can define your set of functions once and for all and use it again and again ensuring you always have the same order in the arguments. This brings us to an important point:","category":"page"},{"location":"man/functions/","page":"FunctionComposer","title":"FunctionComposer","text":"warning: Don't mess with the order of arguments\nFunctionComposer takes the order of functions as given in the argument. That is if you make function callsf1 = FunctionComposer(reference_argument = [0.0,0.0,0.0], super_type = Float64, alpha = exp, beta = sin  )\r\nf2 = FunctionComposer(reference_argument = [0.0,0.0,0.0], super_type = Float64; beta = sin, alpha = exp  )    the algorithm will create two different functions x->[exp(x),sin(x)] and x->[sin(x),exp(x)] and it will NOT be able to clear up the mess this creates....","category":"page"},{"location":"man/functions/#Retrieving-the-full-(combined)-function","page":"FunctionComposer","title":"Retrieving the full (combined) function","text":"","category":"section"},{"location":"man/functions/","page":"FunctionComposer","title":"FunctionComposer","text":"The full function is stored in the variable FunctionComposer.functions.","category":"page"},{"location":"man/functions/","page":"FunctionComposer","title":"FunctionComposer","text":"myfunctions=(alpha = x->norm(x)*x, beta = x->sum(abs,x))\r\nf = FunctionComposer(reference_argument = [0.0,0.0,0.0], super_type = Float64; myfunctions...  )\r\n\r\nmyvalue = f.functions([1.2,3.4,5.6])","category":"page"},{"location":"man/functions/#Decomposing-the-Composer","page":"FunctionComposer","title":"Decomposing the Composer","text":"","category":"section"},{"location":"man/functions/","page":"FunctionComposer","title":"FunctionComposer","text":"To retrieve single information from an array like myvalue in the last example, you can simply use the internal function HighVoronoi.decompose(...):","category":"page"},{"location":"man/functions/","page":"FunctionComposer","title":"FunctionComposer","text":"myfunctions=(alpha = x->norm(x)*x, beta = x->sum(abs,x))\r\nf = FunctionComposer(reference_argument = [0.0,0.0,0.0], super_type = Float64; myfunctions...  )\r\n\r\nmyvalue = f.functions([1.2,3.4,5.6])\r\n\r\nvalues = HighVoronoi.decompose(f, myvalue)\r\n\r\nprintln(values[:alpha], values[:beta])","category":"page"},{"location":"man/functions/","page":"FunctionComposer","title":"FunctionComposer","text":"If you whish 1d-vectors to be returned as scalars, try out this one:","category":"page"},{"location":"man/functions/","page":"FunctionComposer","title":"FunctionComposer","text":"values2 = HighVoronoi.decompose(f, myvalue, scalar=true)\r\n\r\nprintln(values2[:alpha], values2[:beta])","category":"page"},{"location":"man/finitevolume/#The-Finite-Volume-functionality","page":"Finite Volume Problems","title":"The Finite Volume functionality","text":"","category":"section"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"HighVoronois most important feature to the user is the automatic generation of a linear system ","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"mathbb Amathbf u = mathbf b","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"from the PDE-Problem","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"-nablacdotleft(kappanabla u + kappa unabla Vright) = f","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"More abstract, the class VoronoiFVProblem discretizes the problem ","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"nablacdot J(u) = ftagFlux-Form","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"in the bulk (in the domain) where J(u) is a linear differential operator in u and f is a given right hand side. Furthermore, the method can account for periodic, Dirichlet and Neumann boundary conditions, also all at once (on different parts of the boundary).","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"The function linearVoronoiFVProblem then adds particular boundary conditions to the abstract discretization in VoronoiFVProblem and returns a linear equation to be solved.","category":"page"},{"location":"man/finitevolume/#The-VoronoiFVProblem-dataset","page":"Finite Volume Problems","title":"The VoronoiFVProblem dataset","text":"","category":"section"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"note: Summary\nThe VoronoiFVProblem is conceptually a black box into which the user throws a list of nodes and a boundary (or a ready-to-use VoronoiGeometry) as well as a description of J and f. Internally, the black box computes the discrete coefficients of J and f and stores them in a way that allows efficient computation of the matrix and right-hand side for given boundary conditions. We advise the user to first jump to the examples for calculations of fluxes below and afterwards study the following abstract description of VoronoiFVProblem.","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"VoronoiFVProblem()","category":"page"},{"location":"man/finitevolume/#HighVoronoi.VoronoiFVProblem-Tuple{}","page":"Finite Volume Problems","title":"HighVoronoi.VoronoiFVProblem","text":"VoronoiFVProblem(Geo::VoronoiGeometry; parent = nothing)  # first variant\nVoronoiFVProblem(points, boundary; integrator = VI_POLYGON, mc_accurate = (1000,100,20))      # second variant\n\nGenerates Finite Volume data for fluxes and right hand sides given either a VoronoiGeometry object or a set of points and a boundary,  which will serve to internally create a VoronoiGeometry. Allows for the following parameters:\n\nparent: If parent is generated from Geo_p and Geo is a refined version of Geo_p this parameter will initiate the calculation    of an L^1 projection operator between the spaces of piecewise constant functions on the respective Voronoi Tessellations.  \ndiscretefunctions=nothing : A named tuple of form (alpha=x->norm(x),f=x->-x,). Will be evaluated pointwise.\nintegralfunctions=nothing : A named tuple of form (alpha=x->norm(x),f=x->-x,). It will make the algoritm calculate the integrals   over the given functions or it will associate values to the list of functions based on integrated data present in Geo\nfluxes=nothing : this is assumed to be named tuple, e.g. like the following:\n  fluxes = (alpha = f1, beta = f2, eta = f3, zeta = f4, )\nand every of the given fluxes alpha, beta, eta, zeta, has the following structure:   It is one single flux-function  accessing the following named data (see also here in the Documentation):\n  x_i, x_j, para_i, para_j, para_ij, mass_i, mass_j, mass_ij, normal\nand returning two values. Functions f1, f2 ... should hence be defined similar to the  following:\n  function f1(;x_i,x_j,para_ij, kwargs...)\n      # some code\n      return something_i, something_j\n  end\nRefer to the examples in the documentation. \n\nnote: standard settings\nif the array of Neumann-planes is not provided, the standard list given in boundary resp. the boundary in Geo will be used. \n\nrhs_functions=nothing: same as for fluxes. However, functions can only access the variables\n  x_i, mass_i, para_i,\n\n\n\n\n\n","category":"method"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"VoronoiFVProblem","category":"page"},{"location":"man/finitevolume/#HighVoronoi.VoronoiFVProblem","page":"Finite Volume Problems","title":"HighVoronoi.VoronoiFVProblem","text":"struct VoronoiFVProblem{...}\n\nafter initialization the struct contains the following information:\n\nGeometry : a VoronoiGeometry containing mesh and integrated information\nCoefficients : Not advised to be accessed by user \nParent : Not advised to be accessed by user\nprojection_down : Not advised to be accessed by user\nprojection_up : Not advised to be accessed by user\nparameters : Not advised to be accessed by user\n\n\n\n\n\n","category":"type"},{"location":"man/finitevolume/#myVoronoiFVProblem","page":"Finite Volume Problems","title":"Examples for the VoronoiFVProblem","text":"","category":"section"},{"location":"man/finitevolume/#Content","page":"Finite Volume Problems","title":"Content","text":"","category":"section"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"Creating a VoronoiFVProblem\nCalculating fluxes and rigthand side\nCreating a VoronoiFVProblem from a VoronoiGeometry\nInternal storage of data (For very deep coding only)","category":"page"},{"location":"man/finitevolume/#examplecreating","page":"Finite Volume Problems","title":"Creating a VoronoiFVProblem and calculating some integrals...","text":"","category":"section"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"We create a first instance of VoronoiFVProblem. The following code calculates a VoronoiGeometry for the given data of random points. It furthermore calculates the integral of integralfunctions and pointwise evaluations of discretefunctions. The latter are not stored but will be internally used for calculations of fluxes or right hand sides (in a later example). To get familiar with the data structure try out the following:","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"using LinearAlgebra\r\n\r\nfunction myrhs(;para_i,mass_i,kwargs...)\r\n    return para_i[:alpha]*mass_i\r\nend\r\n\r\nfunction test_FV(dim,nop)\r\n    data = rand(dim,nop)\r\n    xs = VoronoiNodes(data)\r\n    cube = cuboid(dim,periodic=[1])\r\n    VoronoiFVProblem(xs,cube, discretefunctions = (alpha=x->sum(abs,x),), \r\n                              rhs_functions = (F=myrhs,) )\r\nend\r\n\r\nvfvp = test_FV(2,4)\r\nprintln(vfvp.Coefficients.functions)","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"The algorithm internally calculutes for each of the four random cells the quantity alpha(x_i)*m_i, where m_i is the mass of cell i. The output hence looks like the following:","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"(F = [0.8899968951003052, 1.6176576528551534, 1.2484331005796414, 0.9868594550457225],)","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"At a later stage, we will of course not directly work with vfvp.Coefficients.functions...\nmyrhs could addionally work with x_i, the coordinates of x_i","category":"page"},{"location":"man/finitevolume/#examplefluxes","page":"Finite Volume Problems","title":"Calculating fluxes and rigthand side","text":"","category":"section"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"We write isim j if the Voronoi cells of the nodes x_i and x_j are neighbored. Then the discrete version of ","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"nablacdot J(u) = ftagFlux-Form","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"in the node x_i is ","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"sum_jsim i J_ij(u) = F_itagFlux-Form-discrete","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"note: Indeces $i$ and $j$\nIn the text and in the code hereafter i is the current cell and j is either a neighbor or an index of a part of the boundary.","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"More precisely, let f and kappa be scalar functions. If m_i  is the mass of cell i and m_ij is the mass of the interface between cells i and j and f_i=f(x_i) or f_i=m_i^-1int_cell_if and similarly for kappa we find the following possible discretization of Fick's law:","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"J(u)=-kappa nabla u qquadleftrightarrowqquad J_ij(u)=-fracm_ijh_ijsqrtkappa_ikappa_j(u_j-u_i)=+fracm_ijh_ijsqrtkappa_ikappa_j(u_i-u_j)","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"with the right hand side ","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"F_i=m_i f_i","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"We can rewrite J_ij(u) in the following form:","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"J_ij(u)=fracm_ijh_ijsqrtkappa_ikappa_ju_i-fracm_ijh_ijsqrtkappa_ikappa_ju_j=p_ijiu_i - p_ijju_j","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"note: purpose of `VoronoiFVProblem`\nThe purpose of VoronoiFVProblem is to calculate p_iji and p_ijj using fluxes=... as well as F_i using rhs_functions.","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"We implement the above discretization in myflux_1 and an alternative replacing sqrtkappa_ikappa_j by an average over the joint interface of cells ij in myflux_2. Here, alpha is evaluated pointwise in the middle of each cell / interface, while kappa is averaged over cells and interfaces.","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"using LinearAlgebra\r\nusing SpecialFunctions\r\n\r\nfunction myflux_1(;para_i,para_j,mass_ij,normal,kwargs...) \r\n    # kwargs... collects all additional parameters which are not used in the current function.\r\n    weight = norm(normal)^(-1) * mass_ij * sqrt(para_i[:kappa]*para_j[:kappa])\r\n    return weight, weight\r\nend\r\n\r\nfunction myflux_2(;para_ij,mass_ij,normal,kwargs...)\r\n    # kwargs... collects all additional parameters which are not used in the current function.\r\n    weight = norm(normal)^(-1) * mass_ij * para_ij[:kappa]\r\n    return weight, weight\r\nend\r\n\r\nmyRHS(;para_i,mass_i,kwargs...) = mass_i * para_i[:f] \r\n\r\n\r\nfunction test_FV(dim,nop)\r\n    data = rand(dim,nop)\r\n    xs = VoronoiNodes(data)\r\n    cube = cuboid(dim,periodic=[],neumann=[1,-1]) # cube with preset Neumann BC in dimension 1 and Dirichlet BC all other dimensions\r\n    VoronoiFVProblem(xs,cube, discretefunctions = (f=x->sin(2*pi*x[1]),), # evaluate f pointwise\r\n                              integralfunctions = (kappa=x->1.0+norm(x)^2,), # calculate averages of kappa over cells and interfaces\r\n                              fluxes = ( j1 = myflux_1, j2 = myflux_2, ),\r\n                              rhs_functions = (F = myRHS,) )\r\nend\r\n\r\ntest_FV(2,10)","category":"page"},{"location":"man/finitevolume/#FVfromGeo","page":"Finite Volume Problems","title":"Creating a VoronoiFVProblem from a VoronoiGeometry","text":"","category":"section"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"It is also possible to write the following less compact code for test_FV(dim,nop). Though it may seem weird to do the extra effort, remember that mesh generation in high dimensions is very time consuming. Hence this approach could be usefull to set up a high dimensional problem from a formerly calculated grid.","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"function test_FV(dim,nop)\r\n    data = rand(dim,nop)\r\n    xs = VoronoiNodes(data)\r\n    cube = cuboid(dim,periodic=[],neumann=[1,-1]) \r\n    vg = VoronoiGeometry(xs, cube, integrator=HighVoronoi.VI_POLYGON, \r\n                                   integrand=x->1.0+norm(x)^2)\r\n    vfvp = VoronoiFVProblem(vg, discretefunctions = (f=x->sin(2*pi*x[1]),), \r\n                              integralfunctions = (kappa=x->0.0,), \r\n                              fluxes = ( j1 = myflux_1, j2 = myflux_2, ),\r\n                              rhs_functions = (F = myRHS,) )\r\nend","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"The instatiation of vg calculates all integrals of x->1.0+norm(x)^2. The instatiation of vfvp cimply uses the values stored in vg and \"rebrands\" them as :kappa.","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"tip: Compatibility of dimension\nThe dimension of integrand in the instatiation of vg can be greater or equal than the summed up dimension of all integralfunctions, but not less!! The definition of :kappa in VoronoiFVProblem(...) in the above example does not matter as all values have been calculated before. We strongly advise to have a look at the \"intentions of use\" section. ","category":"page"},{"location":"man/finitevolume/#examplestoragedata","page":"Finite Volume Problems","title":"Internal storage of data","text":"","category":"section"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"In the second example, try out the following code:","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"vfvp = test_FV(2,4)\r\nprintln(vfvp.Coefficients.functions)\r\nprintln(vfvp.Coefficients.fluxes)\r\nprintln(vfvp.Coefficients.rows)\r\nprintln(vfvp.Coefficients.cols)","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"The fields rows and cols of vfvp store the row and coloumn coordinates of potentially non-zero entries of a sparse flux matrix. The arrays stored in fluxes correspondingly store the non-zero values. It is thus possible to directly create SparseMatrix instances from this data. However, this would not yet properly account for boundary conditions. ","category":"page"},{"location":"man/finitevolume/#parameter_names","page":"Finite Volume Problems","title":"Full list of LOCAL PARAMETER names","text":"","category":"section"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"Functions like myflux_1 and myflux_2 in this example here are evaluated on interfaces between neighboring cells or on the boundary and can take the following arguments","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"x_i: coordinates of the current node i \nx_j: coordinates of the current neighbor j (in case this is an actually existing cell) or the coordinates of a point on the boundary (if this is part of the boundary, see onboundary)\npara_i and para_j: a named tuple container of all pointwise evaluated (discretefunctions) or averaged (integralfunctions) functions for either cell i and j respectively.\npara_ij: same for the interface\nmass_i and mass_j: if of cell i and j\nmass_ij: the mass of the interface\nnormal: Something like x_j-x_i. However, in case of periodic nodes with cells \"crossing the periodic boundary\", it typically holds x_i+mathrmnormalnot=x_j but (x_i+mathrmnormal) is a periodic shift of x_j. In any case, it is the correct outer normal vector with length of the \"periodized distance\". \nonboundary: is true if and only if x_j is a point on the boudary.   ","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"Righthand side functions (bulk functions) like myRHS are evaluated on nodes have only access to ","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"x_i\npara_i\nmass_i","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"danger: \nIf a function f is not provided to either discretefunctions or integralfunctions the call para_i[:f] and alike will cause an error message.\nEvery name can be used only ONCE. Particularly, a name f CANNOT be used both inside discretefunctions AND integralfunctions.","category":"page"},{"location":"man/finitevolume/#Full-linear-equations-including-BOUNDARY-CONDITIONS","page":"Finite Volume Problems","title":"Full linear equations including BOUNDARY CONDITIONS","text":"","category":"section"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"Theoretical background\nlinearVoronoiFVProblem\nExamples","category":"page"},{"location":"man/finitevolume/#lin_eq_background","page":"Finite Volume Problems","title":"Background","text":"","category":"section"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"To understand how boundary conditions are implemented in the HighVoronoi package, multiply equation (Flux-Form) with some function varphi and use integration by parts to obtain ","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"-int_domainJcdotnablavarphi=int_domainfvarphi-int_boundaryvarphiJcdot nu","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"where nu is the outer normal vector. ","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"Furthermore, assume we want to prescribe u=u_0 on some part of the boundary. We can write u=tilde u +u_0 where tilde u has boundary value 0. Then (Flux-Form-discrete) reads","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"sum_jsim i J_ij(tilde u + u_0) = F_i","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"However, since we work in a discrete setting, we can make the following assumptions:","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"note: Assumptions on boundary data\nThe function u_0 is a discrete function taking value 0 on every node inside the domain, but might be non-zero on the boundary. tilde u is a discrete function which is zero on all Dirichlet-parts of the boundary. \nThe function J_0 is a discrete function on the boundary which mimics J_0=Jcdotnu. In particular, we think of J_0(i,j)=m_ij*J_0(x_ij). ","category":"page"},{"location":"man/finitevolume/#linear_vor_prob","page":"Finite Volume Problems","title":"linearVoronoiFVProblem","text":"","category":"section"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"linearVoronoiFVProblem(vd::VoronoiFVProblem;flux)","category":"page"},{"location":"man/finitevolume/#HighVoronoi.linearVoronoiFVProblem-Tuple{VoronoiFVProblem}","page":"Finite Volume Problems","title":"HighVoronoi.linearVoronoiFVProblem","text":"linearVoronoiFVProblem(vd::VoronoiFVProblem;flux)\n\nTakes a VoronoiFVProblem and a flux::Symbol and creates a linear problem. flux has to refer to a flux created in vd.\n\nOptional arguments\n\nrhs: a Symbol referring to one of the rhs_functions or a vector of Float64 of the same length as the number of nodes.    If not provided, the system assumes rhs=zeros(Float64,number_of_nodes).\nNeumann: Can be provided in the forms \n(Int,Function,Int[.],Function,(Int[.],Function),...). Every Function depends on (;kwargs...) \nand represents J*ν on a single boundary plane Int or multiple planes Int[.].\nFunction then it takes the Neumann boundaries given by the definition of the boundary of the domain, unless nothing is reinterpreted as Dirichlet boundary.\nDirichlet: Can be provided in the form (Int,Function,Int[.],Function,(Int[.],Function),...). Every Function depends on (;kwargs...)    and represents u_0 on a single boundary plane Int or multiple planes Int[.].\n\nnote: `FVevaluate_boundary`\nUse FVevaluate_boundary(f) if you simply want f to be evaluated pointwise at the boundary nodes.\n\nnote: Standard boundary conditions and consistency\nThe algorithm will take zero Neumann  resp. zero Dirichlet as standard in case no other information is provided by the user. However, it is the  users responsibility to make sure there are no double specifications given in Neumann and Dirichlet.\n\nReturn values\n\nrows, cols, vals, rhs = linearVoronoiFVProblem(vd::VoronoiFVProblem;flux,kwargs...)\n\nrows, cols, vals are the row and coloumn indeces of values. Create e.g. A=sparse(rows,cols,vals) and sovle A*u=rhs\n\n\n\n\n\n","category":"method"},{"location":"man/finitevolume/#lin_vor_prob_ex","page":"Finite Volume Problems","title":"Examples","text":"","category":"section"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"Let us look at the following example:","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"    using SparseArrays\r\n\r\n    myrhs(;para_i,mass_i,kwargs...) = mass_i*para_i[:alpha]\r\n\r\n    function myflux_2(;para_ij,mass_ij,normal,kwargs...)\r\n        weight = norm(normal)^(-1) * mass_ij * para_ij[:alpha]\r\n        return weight, weight\r\n    end\r\n\r\n    xs = VoronoiNodes(rand(2,6))\r\n    cube = cuboid(2,periodic=[1])\r\n    vfvp = VoronoiFVProblem(xs, cube, discretefunctions = (alpha=x->sum(abs,x),), \r\n                                      rhs_functions=(F=myrhs,), \r\n                                      fluxes=(j1=myflux_2,) )\r\n    har = FVevaluate_boundary(x->0.0) # turn a function into the format HighVoronoi needs\r\n    one = FVevaluate_boundary(x->1.0)\r\n    r,c,v,f = linearVoronoiFVProblem(vfvp, flux = :j1, Neumann = (3,har), Dirichlet = (4,one))\r\n    A = sparse(r,c,v) # a sparse matrix with rows `r`, coloumns `c` and values `v`\r\n    # solution_u = somelinearsolver(A,f)","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Problems","title":"Finite Volume Problems","text":"As we see, the output of the algorithm is a matrix A and a right hand side f which can be plugged into a linear solver method from some suitable package.","category":"page"},{"location":"man/metapost/#D-Output-using-MetaPost","page":"2D-Output using MetaPost","title":"2D-Output using MetaPost","text":"","category":"section"},{"location":"man/metapost/","page":"2D-Output using MetaPost","title":"2D-Output using MetaPost","text":"Similar to LaTeXX, MetaPost is an elegant way to create eps, pdf etc. from a programming language vector graphic code. If you do not have it installed on your PC, you may use the  MetaPost generator by Troy Henderson: www.tlhiv.org/mppreview/. However, this link sometimes did not work in the past.","category":"page"},{"location":"man/metapost/#draw2d","page":"2D-Output using MetaPost","title":"draw2d","text":"","category":"section"},{"location":"man/metapost/","page":"2D-Output using MetaPost","title":"2D-Output using MetaPost","text":"The package provides the following output functions:","category":"page"},{"location":"man/metapost/","page":"2D-Output using MetaPost","title":"2D-Output using MetaPost","text":"draw2D","category":"page"},{"location":"man/metapost/#HighVoronoi.draw2D","page":"2D-Output using MetaPost","title":"HighVoronoi.draw2D","text":"draw2D(VG::VoronoiGeometry, filename::String; board=MetaPostBoard(), drawNodes=true, drawVerteces=true, drawEdges=true)\n\nGenerates MetaPost of VG output in the file with name filename for a two-dimensional VoronoiGeometry.\n\nboard : The MetaPostBoard to be used. \ndrawNodes : Set this value to \"false\" in order to not show the nodes in the output  \ndrawVerteces : Set this value to \"false\" in order to not show the verteces in the output  \ndrawEdges : Set this value to \"false\" in order to not show the edges in the output  \n\n\n\n\n\ndraw2D(Integral::Voronoi_Integral, filename::String; domain=nothing, board=MetaPostBoard(), drawNodes=true, drawVerteces=true, drawEdges=true)\n\nWrites MetaPost code for the internal type Voronoi_Integral, which may be assessed via VoronoiGeometry.Integrator.Integral. It has one additional parameter:\n\ndomain: A domain of type Boundary can be passed here. This will be shown in the color specified by domain_color.\n\n\n\n\n\n","category":"function"},{"location":"man/metapost/#The-MeatPostBoard","page":"2D-Output using MetaPost","title":"The MeatPostBoard","text":"","category":"section"},{"location":"man/metapost/","page":"2D-Output using MetaPost","title":"2D-Output using MetaPost","text":"These methods are based on the MetaPostBoard structure:","category":"page"},{"location":"man/metapost/","page":"2D-Output using MetaPost","title":"2D-Output using MetaPost","text":"MetaPostBoard","category":"page"},{"location":"man/metapost/#HighVoronoi.MetaPostBoard","page":"2D-Output using MetaPost","title":"HighVoronoi.MetaPostBoard","text":"MetaPostBoard\n\nProvides a board to display a two-dimensional VoronoiGeometry in MetaPost text format using draw2D.\n\n\n\n\n\n","category":"type"},{"location":"man/metapost/","page":"2D-Output using MetaPost","title":"2D-Output using MetaPost","text":"MetaPostBoard()","category":"page"},{"location":"man/metapost/#HighVoronoi.MetaPostBoard-Tuple{}","page":"2D-Output using MetaPost","title":"HighVoronoi.MetaPostBoard","text":"The constructor\n\nMetaPostBoard()\n\nGenerates a MetapostBoard where the following <:Real-type arguments may be passed (=standard value)\n\nscaling=100: denotes a factor by which every object is magnified (also applies to the coordinates of points)\nnode_size=0.01: nodes are drawn as a cross. This variable is the size of a cross BEFORE scaling\nvertex_size=0.003: same for verteces\n\nAdditionally, the following colors may be passed as a <:String. note that an empty string implies the usage of the MetaPost standard pen color.\n\nnodes_color=\"\": the color at which nodes are draw. Empty string implies standard color (typically black)\nvertex_color=\"red\": color verteces\nedge_color=\"blue\": color of edges\ndomain_color=\"\": color the domain, in case a domain argument is passed to the draw2D-function. Also it displays the domain that was passed to a VoronoiGeometry during instatiation  \nboard::Boundary: provides a board: every node or vertex outside this board is not drawn\n\n\n\n\n\n","category":"method"},{"location":"#Functionality-of-the-HighVoronoi-Package","page":"Home","title":"Functionality of the HighVoronoi Package","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HighVoronoi is intended as an effective Voronoi mesh generator in any ARBITRARY DIMENSION greater or equal to 2. It can work on polygonal domains and also on (partially or fully) periodic domains. It also provides methods to implement Finite Volume problems on these high dimensional meshes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Mesh generation as well as the Monte-Carlo method are based on an algorithm first published in the VoronoiGraph package by Alexander Sikorski in the version of June 2022. However, the code was fully restructured and in wide parts rewritten to adapt it to mesh-refinement. ","category":"page"},{"location":"#The-HighVoronoi-package-provides","page":"Home","title":"The HighVoronoi package provides","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"a series of data sets that allow to set up a Voronoi mesh in arbitrary dimension on a convex domain with plane boundaries or even without boundaries.\n2 different methods to calculate the volumes and interface areas of cells: An exact triangulation method and a Montecarlo method\n3 different methods to integrate functions:\ntwo on the fly for both triangulation and Montecarlo\none based on given volume and surface data\nRefinement of Voronoi tessellations: Add points to your grid and the algorithm will locally recalculate the mesh, including integration of volume, area and functions.\nSet up the linear equation for a finite volume Voronoi discretization of a given elliptic PDE with Neumann, Dirichlet or periodic boundary conditions\nother functionalities like 2D data export in Metapost, storing and loading data.","category":"page"},{"location":"#Overview-of-data-structures-and-methods","page":"Home","title":"Overview of data structures and methods","text":"","category":"section"},{"location":"#Data-Structures","page":"Home","title":"Data Structures","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"VoronoiGeometry: Creating, updating, refining and managing the mesh\nVoronoiNodes: Nodes for the mesh\nBoundary: Boundary of the mesh\nVoronoiData: Providing the data of the mesh for further use outside of HighVoronoi.jl\nVoronoiFVProblem: Calculating internal data for setting up linear matrix equations for Finite Volume discretizations on a VoronoiGeometry","category":"page"},{"location":"#Methods","page":"Home","title":"Methods","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"write_jld: Store a VoronoiGeometry\nrefine!: refine a VoronoiGeometry by new nodes\nlinearVoronoiFVProblem: Extract the Matrix and right-hand-side from a given VoronoiFVProblem and for given boundary conditions.","category":"page"},{"location":"#To-be-implemented-in-a-forthcoming-version","page":"Home","title":"To be implemented in a forthcoming version","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"refine a VoronoiFVProblem. Project a given \"rough\" FV solution of a linearVoronoiFVProblem onto the refined solution space. \nprovide fast and efficient methods for quasi-periodic meshes in High dimensions and with high resolution.","category":"page"},{"location":"man/short/#Using-the-HighVoronoi-Library","page":"In Short...","title":"Using the HighVoronoi Library","text":"","category":"section"},{"location":"man/short/","page":"In Short...","title":"In Short...","text":"The following are examples to get a first impression of the functionalities of HighVoronoi. They do not represent the actual intention of use. For this we refer here","category":"page"},{"location":"man/short/#Getting-Started...","page":"In Short...","title":"Getting Started...","text":"","category":"section"},{"location":"man/short/","page":"In Short...","title":"In Short...","text":"You can write your first HighVoronoi code e.g. as follows:","category":"page"},{"location":"man/short/","page":"In Short...","title":"In Short...","text":"function VoronoiTest(dim,nop)\r\n    # create a random matrix of dim x nop entries\r\n    data=rand(dim,nop)\r\n    # transform these into `nop` different static vectors of dimension `dim`\r\n    xs=VoronoiNodes(data)\r\n    return VoronoiGeometry(xs,Boundary())\r\nend","category":"page"},{"location":"man/short/","page":"In Short...","title":"In Short...","text":"The command Boundary() creates an unbounded version of mathbb R^dim. This VoronoiGeometry only contains the nodes, verteces and neighbor relations, as well as information on verteces \"going to infinity\".","category":"page"},{"location":"man/short/#Bounded-domains,-volumes-and-interface-areas","page":"In Short...","title":"Bounded domains, volumes and interface areas","text":"","category":"section"},{"location":"man/short/","page":"In Short...","title":"In Short...","text":"So let us make the following modification:","category":"page"},{"location":"man/short/","page":"In Short...","title":"In Short...","text":"function VoronoiTest_cube(dim,nop,integrator=HighVoronoi.VI_POLYGON)\r\n    # create a random matrix of dim x nop entries\r\n    data=rand(dim,nop)\r\n    # transform these into `nop` different static vectors of dimension `dim`\r\n    xs=VoronoiNodes(data)\r\n    return VoronoiGeometry(xs,cuboid(dim,periodic=Int64[]),integrator=integrator)\r\nend\r\n\r\nvd=VoronoiData(VoronoiTest_cube(2,10))\r\n\r\nprintln(vd.volume)\r\nprintln(vd.neighbors)\r\nprintln(vd.area)","category":"page"},{"location":"man/short/","page":"In Short...","title":"In Short...","text":"The parameter integrator tells julia wether and how to compute volumes of cells and areas of interfaces. VI_POLYGON refers to an exact trigonalization of the polytopes. \nBoundary() has been exchanged for cuboid(dim,periodic=Int64[]), which in this case returns the simple cube 01^dim. Remark: Unlike VI_MONTECARLO the algorithm VI_POLYGON  will return finite volumes also for the infinite cells that are automatically created on unbounded domains like Boundary(). \nThe last three lines cause julia to print the volumes of the 10 cells, the neighbors of each cell and the area of the respective interfaces. Note that some points have neighbors with values from 11 to 14. ","category":"page"},{"location":"man/short/","page":"In Short...","title":"In Short...","text":"warning: Boundary planes can be neighbors\nThe numbers 11 to 14 represent an internal numbering of the 4 hyperplanes (e.g. lines) that define the cube 01^2. In general, given a domain with N nodes and P planes, whenever a Voronoi cell corresponding to node n touches a boundary plane p this will cause a neighbor entry N+p.  ","category":"page"},{"location":"man/short/#Periodic-Boundaries","page":"In Short...","title":"Periodic Boundaries","text":"","category":"section"},{"location":"man/short/","page":"In Short...","title":"In Short...","text":"The HighVoronoi package provides several possibilities to define boundaries of bounded or (partially) unbounded domains. It also provides the possibility to study periodic boundary conditions:","category":"page"},{"location":"man/short/","page":"In Short...","title":"In Short...","text":"function VoronoiTest_cube_periodic(dim,nop,integrator=HighVoronoi.VI_POLYGON)\r\n    # create a random matrix of dim x nop entries\r\n    data=rand(dim,nop)\r\n    # transform these into `nop` different static vectors of dimension `dim`\r\n    xs=VoronoiNodes(data)\r\n    return VoronoiGeometry(xs,cuboid(dim,periodic=[1]),integrator=integrator)\r\nend\r\n\r\nvd=VoronoiData(VoronoiTest_cube_periodic(2,10))\r\n\r\nprintln(vd.volume)\r\nprintln(vd.neighbors)\r\nprintln(vd.area)","category":"page"},{"location":"man/short/","page":"In Short...","title":"In Short...","text":"periodic=[1] in the cuboid(...) command forces the Voronoi mesh to be periodic in space dimension 1. Note that the internal default is periodic = collect(1:dim), i.e. the grid to be periodic in all space dimensions. Our current choice has the following essential consequences.   \nNo cell will have 11 or 12 as a neighbor, since these boundaries are now periodic. \nSome cells n will have \"doubled\" neighbors, i.e. the same neighbor node appears twice (or even more often for e.g. periodic=[1,2]) in the array  vd.neighbors[n]. This is since for only few cells it is highly probable, that one cell has the same neighbor both \"on the left\" and \"on the right\".","category":"page"},{"location":"man/short/#Recycle-Voronoi-data-for-new-integrations","page":"In Short...","title":"Recycle Voronoi data for new integrations","text":"","category":"section"},{"location":"man/short/","page":"In Short...","title":"In Short...","text":"The following code first generates a Voronoi grid, simulatneously integrating the function x->[norm(x),1]. Afterwards, the volume and area information is used to integrate the function x->[x[1]]","category":"page"},{"location":"man/short/","page":"In Short...","title":"In Short...","text":"data = rand(4,20)#round.(rand(dim,nop),digits=4)\r\nxs = HighVoronoi.VoronoiNodes(data)\r\n\r\nVG = VoronoiGeometry(xs,cuboid(4,periodic=Int64[]),integrator=HighVoronoi.VI_POLYGON,integrand = x->[norm(x),1])\r\n\r\nVG2 = VoronoiGeometry(VG,integrand = x->[x[1]],integrate=true,integrator=HighVoronoi.VI_HEURISTIC)\r\n\r\nvd = VoronoiData(VG)\r\nprintln(vd.bulk_integral)\r\n\r\nvd2 = VoronoiData(VG2)\r\nprintln(vd2.bulk_integral)","category":"page"},{"location":"man/short/#Store-and-load-data","page":"In Short...","title":"Store and load data","text":"","category":"section"},{"location":"man/short/","page":"In Short...","title":"In Short...","text":"Data can easily be stored using the following ","category":"page"},{"location":"man/short/","page":"In Short...","title":"In Short...","text":"Geo = VoronoiGeometry(HighVoronoi.VoronoiNodes(rand(4,20)), cuboid(4,periodic=Int64[]), integrator=HighVoronoi.VI_POLYGON, integrand = x->[norm(x),1])\r\n\r\nwrite_jld(Geo,\"example.jld\")","category":"page"},{"location":"man/short/","page":"In Short...","title":"In Short...","text":"the ending \".jld\" is important as it indicates julia which data format to use. Retrieve this data later using","category":"page"},{"location":"man/short/","page":"In Short...","title":"In Short...","text":"Geo = VoronoiGeometry(\"example.jld\", bulk=true, interface=true, integrand = x->[norm(x),1])","category":"page"},{"location":"man/short/","page":"In Short...","title":"In Short...","text":"warning: integrands can easily be messed up...\nThe method does not store the integrand parameter to the file. However, due to bulk=true, interface=true the integral data is loaded from the file and must be properly interpreted by a potential user. This has drawbacks and advantages, as will be discussed in the Intentions of use.","category":"page"}]
}
