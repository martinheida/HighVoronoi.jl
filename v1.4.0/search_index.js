var documenterSearchIndex = {"docs":
[{"location":"man/short/#Voronoi-generation-using-the-HighVoronoi-Library","page":"Examples Voronoi Generation","title":"Voronoi generation using the HighVoronoi Library","text":"","category":"section"},{"location":"man/short/","page":"Examples Voronoi Generation","title":"Examples Voronoi Generation","text":"The following are examples to get a first impression of the functionalities of HighVoronoi. They do not represent the actual intention of use. For this we refer here","category":"page"},{"location":"man/short/#quickVG","page":"Examples Voronoi Generation","title":"Getting Started...","text":"","category":"section"},{"location":"man/short/","page":"Examples Voronoi Generation","title":"Examples Voronoi Generation","text":"You can write your first HighVoronoi code e.g. as follows:","category":"page"},{"location":"man/short/","page":"Examples Voronoi Generation","title":"Examples Voronoi Generation","text":"function VoronoiTest(dim,nop)\r\n    # create a random matrix of dim x nop entries\r\n    data=rand(dim,nop)\r\n    # transform these into `nop` different static vectors of dimension `dim`\r\n    xs=VoronoiNodes(data)\r\n    return VoronoiGeometry(xs,Boundary())\r\nend","category":"page"},{"location":"man/short/","page":"Examples Voronoi Generation","title":"Examples Voronoi Generation","text":"The command Boundary() creates an unbounded version of mathbb R^dim. This VoronoiGeometry only contains the nodes, verteces and neighbor relations, as well as information on verteces \"going to infinity\".","category":"page"},{"location":"man/short/#Bounded-domains,-volumes-and-interface-areas","page":"Examples Voronoi Generation","title":"Bounded domains, volumes and interface areas","text":"","category":"section"},{"location":"man/short/","page":"Examples Voronoi Generation","title":"Examples Voronoi Generation","text":"So let us make the following modification:","category":"page"},{"location":"man/short/","page":"Examples Voronoi Generation","title":"Examples Voronoi Generation","text":"function VoronoiTest_cube(dim,nop,integrator=HighVoronoi.VI_POLYGON)\r\n    # create a random matrix of dim x nop entries\r\n    data=rand(dim,nop)\r\n    # transform these into `nop` different static vectors of dimension `dim`\r\n    xs=VoronoiNodes(data)\r\n    return VoronoiGeometry(xs,cuboid(dim,periodic=Int64[]),integrator=integrator)\r\nend\r\n\r\nvd=VoronoiData(VoronoiTest_cube(2,10))\r\n\r\nprintln(vd.volume)\r\nprintln(vd.neighbors)\r\nprintln(vd.area)","category":"page"},{"location":"man/short/","page":"Examples Voronoi Generation","title":"Examples Voronoi Generation","text":"The parameter integrator tells julia wether and how to compute volumes of cells and areas of interfaces. VI_POLYGON refers to an exact trigonalization of the polytopes. \nBoundary() has been exchanged for cuboid(dim,periodic=Int64[]), which in this case returns the simple cube 01^dim. Remark: Unlike VI_MONTECARLO the algorithm VI_POLYGON  will return finite volumes also for the infinite cells that are automatically created on unbounded domains like Boundary(). \nThe last three lines cause julia to print the volumes of the 10 cells, the neighbors of each cell and the area of the respective interfaces. Note that some points have neighbors with values from 11 to 14. ","category":"page"},{"location":"man/short/","page":"Examples Voronoi Generation","title":"Examples Voronoi Generation","text":"warning: Boundary planes can be neighbors\nThe numbers 11 to 14 represent an internal numbering of the 4 hyperplanes (e.g. lines) that define the cube 01^2. In general, given a domain with N nodes and P planes, whenever a Voronoi cell corresponding to node n touches a boundary plane p this will cause a neighbor entry N+p.  ","category":"page"},{"location":"man/short/#Periodic-Boundaries","page":"Examples Voronoi Generation","title":"Periodic Boundaries","text":"","category":"section"},{"location":"man/short/","page":"Examples Voronoi Generation","title":"Examples Voronoi Generation","text":"The HighVoronoi package provides several possibilities to define boundaries of bounded or (partially) unbounded domains. It also provides the possibility to study periodic boundary conditions:","category":"page"},{"location":"man/short/","page":"Examples Voronoi Generation","title":"Examples Voronoi Generation","text":"function VoronoiTest_cube_periodic(dim,nop,integrator=HighVoronoi.VI_POLYGON)\r\n    # create a random matrix of dim x nop entries\r\n    data=rand(dim,nop)\r\n    # transform these into `nop` different static vectors of dimension `dim`\r\n    xs=VoronoiNodes(data)\r\n    return VoronoiGeometry(xs,cuboid(dim,periodic=[1]),integrator=integrator)\r\nend\r\n\r\nvd=VoronoiData(VoronoiTest_cube_periodic(2,10))\r\n\r\nprintln(vd.volume)\r\nprintln(vd.neighbors)\r\nprintln(vd.area)","category":"page"},{"location":"man/short/","page":"Examples Voronoi Generation","title":"Examples Voronoi Generation","text":"periodic=[1] in the cuboid(...) command forces the Voronoi mesh to be periodic in space dimension 1. Note that the internal default is periodic = collect(1:dim), i.e. the grid to be periodic in all space dimensions. Our current choice has the following essential consequences.   \nNo cell will have 11 or 12 as a neighbor, since these boundaries are now periodic. \nSome cells n will have \"doubled\" neighbors, i.e. the same neighbor node appears twice (or even more often for e.g. periodic=[1,2]) in the array  vd.neighbors[n]. This is since for only few cells it is highly probable, that one cell has the same neighbor both \"on the left\" and \"on the right\".","category":"page"},{"location":"man/short/#Recycle-Voronoi-data-for-new-integrations","page":"Examples Voronoi Generation","title":"Recycle Voronoi data for new integrations","text":"","category":"section"},{"location":"man/short/","page":"Examples Voronoi Generation","title":"Examples Voronoi Generation","text":"The following code first generates a Voronoi grid, simulatneously integrating the function x->[norm(x),1]. Afterwards, the volume and area information is used to integrate the function x->[x[1]]","category":"page"},{"location":"man/short/","page":"Examples Voronoi Generation","title":"Examples Voronoi Generation","text":"data = rand(4,20)#round.(rand(dim,nop),digits=4)\r\nxs = HighVoronoi.VoronoiNodes(data)\r\n\r\nVG = VoronoiGeometry(xs,cuboid(4,periodic=Int64[]),integrator=HighVoronoi.VI_POLYGON,integrand = x->[norm(x),1])\r\n\r\nVG2 = VoronoiGeometry(VG,integrand = x->[x[1]],integrate=true,integrator=HighVoronoi.VI_HEURISTIC)\r\n\r\nvd = VoronoiData(VG)\r\nprintln(vd.bulk_integral)\r\n\r\nvd2 = VoronoiData(VG2)\r\nprintln(vd2.bulk_integral)","category":"page"},{"location":"man/short/#Recycle-Voronoi-data-for-refined-geometries","page":"Examples Voronoi Generation","title":"Recycle Voronoi data for refined geometries","text":"","category":"section"},{"location":"man/short/","page":"Examples Voronoi Generation","title":"Examples Voronoi Generation","text":"The following creates a VoronoiGeometry VG, then makes a copy VG2 and refines it with 20 points inside the region (002)^4. ","category":"page"},{"location":"man/short/","page":"Examples Voronoi Generation","title":"Examples Voronoi Generation","text":"xs = HighVoronoi.VoronoiNodes(rand(4,20))\r\n\r\nVG = VoronoiGeometry(xs,cuboid(4,periodic=Int64[]),integrator=HighVoronoi.VI_POLYGON,integrand = x->[norm(x),1])\r\n\r\nVG2 = copy(VG)\r\n\r\nrefine!(VG,VoronoiNodes(0.2*rand(4,20)))\r\n\r\nvd = VoronoiData(VG)\r\nprintln(vd.bulk_integral)\r\n\r\nvd2 = VoronoiData(VG2)\r\nprintln(vd2.bulk_integral)","category":"page"},{"location":"man/short/#Store-and-load-data","page":"Examples Voronoi Generation","title":"Store and load data","text":"","category":"section"},{"location":"man/short/","page":"Examples Voronoi Generation","title":"Examples Voronoi Generation","text":"Data can easily be stored using the following ","category":"page"},{"location":"man/short/","page":"Examples Voronoi Generation","title":"Examples Voronoi Generation","text":"Geo = VoronoiGeometry(HighVoronoi.VoronoiNodes(rand(4,20)), cuboid(4,periodic=Int64[]), integrator=HighVoronoi.VI_POLYGON, integrand = x->[norm(x),1])\r\n\r\nwrite_jld(Geo,\"example.jld\")","category":"page"},{"location":"man/short/","page":"Examples Voronoi Generation","title":"Examples Voronoi Generation","text":"the ending \".jld\" is important as it indicates julia which data format to use. Retrieve this data later using","category":"page"},{"location":"man/short/","page":"Examples Voronoi Generation","title":"Examples Voronoi Generation","text":"Geo = VoronoiGeometry(\"example.jld\", bulk=true, interface=true, integrand = x->[norm(x),1])","category":"page"},{"location":"man/short/","page":"Examples Voronoi Generation","title":"Examples Voronoi Generation","text":"warning: integrands can easily be messed up...\nThe method does not store the integrand parameter to the file. However, due to bulk=true, interface=true the integral data is loaded from the file and must be properly interpreted by a potential user. This has drawbacks and advantages, as will be discussed in the Intentions of use.","category":"page"},{"location":"man/database/#Voronoi:-Database-Structure","page":"Voronoi: Database Structure","title":"Voronoi: Database Structure","text":"","category":"section"},{"location":"man/database/","page":"Voronoi: Database Structure","title":"Voronoi: Database Structure","text":"There are currently three types of internal data storage implemented. They may be called using the keyword vertex_storage at the VoronoiGeometry constructor.","category":"page"},{"location":"man/database/#Standard-solution","page":"Voronoi: Database Structure","title":"Standard solution","text":"","category":"section"},{"location":"man/database/","page":"Voronoi: Database Structure","title":"Voronoi: Database Structure","text":"The most recent and most efficient method is DatabaseVertexStorage(). It stores all information in one centralized database and uses a sophisticated indexing system for fast access to any information from all points in the code. It might be slightly slower than the other two methods for large grids in high dimension, but it requires much less memory and for smaller grids it is even faster than the other two methods. ","category":"page"},{"location":"man/database/","page":"Voronoi: Database Structure","title":"Voronoi: Database Structure","text":"This is the only database that is reliably compatible with multithreading and as such it will be automatically enforced once threading=MutliThread(...) is provided as an option!","category":"page"},{"location":"man/database/#Deprecated-solution","page":"Voronoi: Database Structure","title":"Deprecated solution","text":"","category":"section"},{"location":"man/database/","page":"Voronoi: Database Structure","title":"Voronoi: Database Structure","text":"Another option is the ReferencedVertexStorage() which is slower but may be useful in low dimensions. It has a decentralized dictionary-based data structure with additional references. It was first implemented to save memory compared to the very initial solution. ","category":"page"},{"location":"man/database/#Initial-solution","page":"Voronoi: Database Structure","title":"Initial solution","text":"","category":"section"},{"location":"man/database/","page":"Voronoi: Database Structure","title":"Voronoi: Database Structure","text":"The ClassicVertexStorage() which is fast for integration algorithms in low dimensions and which was the first database structure underlying the computations. It builds solely on a system of dictionaries. For some applications it is efficient but it requires a lot of memory which becomes troublesome in high dimensions. However, for documentation of the development of the library, it is still useable.","category":"page"},{"location":"man/convexhull/#convexhull","page":"Convex Hulls","title":"Convex Hull","text":"","category":"section"},{"location":"man/convexhull/","page":"Convex Hulls","title":"Convex Hulls","text":"Use the following to compute the convex hull of the VoronoiNodes xs:","category":"page"},{"location":"man/convexhull/","page":"Convex Hulls","title":"Convex Hulls","text":"cv = ConvexHull(xs,\"computing convex hull: \"; nthreads=Threads.nthreads(), method = RCOriginal)","category":"page"},{"location":"man/convexhull/","page":"Convex Hulls","title":"Convex Hulls","text":"Note that only the following methods are available: RCOriginal, RCNonGeneral. Again, RCOriginal is faster and for nodes in general position (that means there are only d points in mathbbR^d that generate one surface element) while  RCNonGeneral can be used for nodes in non-general position.\nnthreads will be initialized with Threads.nthreads() by default. If you want less threads, provide a positive Int64. You can set the string to \"\" in order to have only a progress bar. \nlength(cv) will give you the number of surface elements\ncv[i] will then give you (sig,r,u) where sig is a list of generating nodes, r is a point on the plane equidistant to all sig and u is the outer normal of that plane. ","category":"page"},{"location":"man/geometry/#Voronoi:-Nodes-and-Geometry,-Integrators","page":"Voronoi: Nodes and Geometry, Integrators","title":"Voronoi: Nodes and Geometry, Integrators","text":"","category":"section"},{"location":"man/geometry/#differentnodegenerators","page":"Voronoi: Nodes and Geometry, Integrators","title":"Nodes","text":"","category":"section"},{"location":"man/geometry/","page":"Voronoi: Nodes and Geometry, Integrators","title":"Voronoi: Nodes and Geometry, Integrators","text":"The most basic thing is the creation of a list of Points. We advise to use the following:","category":"page"},{"location":"man/geometry/","page":"Voronoi: Nodes and Geometry, Integrators","title":"Voronoi: Nodes and Geometry, Integrators","text":"VoronoiNodes(x::Matrix)","category":"page"},{"location":"man/geometry/#HighVoronoi.VoronoiNodes-Tuple{Matrix}","page":"Voronoi: Nodes and Geometry, Integrators","title":"HighVoronoi.VoronoiNodes","text":"VoronoiNodes(x::Matrix)\n\nalso available in the forms\n\nVoronoiNodes(x::Vector{<:Vector})\nVoronoiNodes(x::Vector{<:SVector})\n\ncreates a list of points (as static vectors) from a matrix.\n\nExample: 100 Points in (01)^3\n\ndata = rand(3,100)\npoints = VoronoiNodes(data)\n\n\n\n\n\n","category":"method"},{"location":"man/geometry/","page":"Voronoi: Nodes and Geometry, Integrators","title":"Voronoi: Nodes and Geometry, Integrators","text":"An advanced method is given by the following","category":"page"},{"location":"man/geometry/","page":"Voronoi: Nodes and Geometry, Integrators","title":"Voronoi: Nodes and Geometry, Integrators","text":"VoronoiNodes(number_of_nodes::Int;density , \r\n            domain::Boundary=Boundary(), bounding_box::Boundary=Boundary(),\r\n            criterium=x->true)","category":"page"},{"location":"man/geometry/","page":"Voronoi: Nodes and Geometry, Integrators","title":"Voronoi: Nodes and Geometry, Integrators","text":"When density = x->f(x) this will create a cloud of approximately number_of_nodes points inside the intersection of domain and bounding_box with spatial distribution f(x). Note that both exact number and position of points are random.  The variable bounding_box allows to handle also the case when domain is unbounded. The intersection of domain and bounding_box  HAS TO BE bounded!","category":"page"},{"location":"man/geometry/","page":"Voronoi: Nodes and Geometry, Integrators","title":"Voronoi: Nodes and Geometry, Integrators","text":"The following two pictures show first a distribution density = x->sin(pi*2*x[1])^2*sin(pi*2*x[2])^2 and the second takes the same density squared.","category":"page"},{"location":"man/geometry/","page":"Voronoi: Nodes and Geometry, Integrators","title":"Voronoi: Nodes and Geometry, Integrators","text":"(Image: sin^2 distribution of nodes)","category":"page"},{"location":"man/geometry/","page":"Voronoi: Nodes and Geometry, Integrators","title":"Voronoi: Nodes and Geometry, Integrators","text":"(Image: sin^4 distribution of nodes)","category":"page"},{"location":"man/geometry/#Single-Nodes","page":"Voronoi: Nodes and Geometry, Integrators","title":"Single Nodes","text":"","category":"section"},{"location":"man/geometry/","page":"Voronoi: Nodes and Geometry, Integrators","title":"Voronoi: Nodes and Geometry, Integrators","text":"To instatiate a single node (e.g. if you want to add a specific node to an existing list of nodes) use","category":"page"},{"location":"man/geometry/","page":"Voronoi: Nodes and Geometry, Integrators","title":"Voronoi: Nodes and Geometry, Integrators","text":"# make [1.0, 0.0, 0.5] a valid Voronoi node\r\nVoronoiNode([1.0, 0.0, 0.5])","category":"page"},{"location":"man/geometry/#Example","page":"Voronoi: Nodes and Geometry, Integrators","title":"Example","text":"","category":"section"},{"location":"man/geometry/","page":"Voronoi: Nodes and Geometry, Integrators","title":"Voronoi: Nodes and Geometry, Integrators","text":"# This is an example to illustrate VoronoiNodes(number_of_nodes::Int;density)\r\n\r\n## First some plot routine ############################\r\nusing Plots\r\n\r\nfunction plot_2d_surface(nodes, values)\r\n    # The following two lines are necessary in order for the plot to look nicely\r\n    func = StepFunction(nodes,values)\r\n    new_nodes = vcat([VoronoiNode([k/10,j*1.0]) for k in 0:10, j in 0:1], [VoronoiNode([j*1.0,k/10]) for k in 1:9, j in 0:1])\r\n    append!(nodes,new_nodes)\r\n    append!(values,[func(n) for n in new_nodes])\r\n    \r\n    x = [node[1] for node in nodes]\r\n    y = [node[2] for node in nodes]\r\n    \r\n    p = Plots.surface(x, y, values, legend=false)\r\n    xlabel!(\"X\")\r\n    ylabel!(\"Y\")\r\n    zlabel!(\"Values\")\r\n    title!(\"2D Surface Graph\")\r\n    \r\n    display(p)\r\nend\r\n########################################################\r\n\r\n## Now for the main part ################################\r\n\r\nmy_distribution = x->(sin(x[1]*π)*sin(x[2]*π))^4\r\nmy_nodes = VoronoiNodes(100,density = my_distribution, domain=cuboid(2,periodic=[]))\r\n# you may compare the output to the following:\r\n# my_nodes = VoronoiNodes(100,density = x->1.0, domain=cuboid(2,periodic=[]))\r\nprintln(\"This generated $(length(my_nodes)) nodes.\")\r\nmy_vals = map(x->sin(x[1]*π)^2*sin(x[2]*π),my_nodes)\r\nplot_2d_surface(my_nodes,my_vals)","category":"page"},{"location":"man/geometry/#DensityRange","page":"Voronoi: Nodes and Geometry, Integrators","title":"DensityRange","text":"","category":"section"},{"location":"man/geometry/","page":"Voronoi: Nodes and Geometry, Integrators","title":"Voronoi: Nodes and Geometry, Integrators","text":"DensityRange{S}","category":"page"},{"location":"man/geometry/#HighVoronoi.DensityRange","page":"Voronoi: Nodes and Geometry, Integrators","title":"HighVoronoi.DensityRange","text":"DensityRange{S}\n\nprovides a rectangular grid of points in a S-dimensional space. It is initialized as follows:\n\nDensityRange(mr::AbstractVector{<:Integer},range)\n\nHere, range can be of the following types:\n\nAbstractVector{Tuple{<:Real,<:Real}}: It is assumed that each entry of range is a tuple (a_i,b_i) \n\nso the range is defined in the cuboid (a_1,b_1)\times...\times(a_{dim},b_{dim})\n\nmr is assumed to have the same dimension as range and the interval (a_i,b_i) will be devided into mr[i] intervalls\n\nAbstractVector{<:Real}: if e.g. range=[1.0,1.0] this will be transferred to range=[(0.0,1.0),(0.0,1.0)] \n\nand the first instance of the method is called \n\nFloat64: range will be set range*ones(Float64,length(mr)) and the second instance is called\nTuple{<:Real,<:Real}: range will be set to an array of identical tuple entries and the first version is called\n\nAlternatively, one may call the following method:\n\nDensityRange(mr::Int,range,dimension=length(range))\n\nit is assumed that range is an array or tuple of correct length and mr is replaced by mr*ones(Int64,dimension).  If range is not an array, then dimension has to be provided the correct value.\n\n\n\n\n\n","category":"type"},{"location":"man/geometry/#Geometry","page":"Voronoi: Nodes and Geometry, Integrators","title":"Geometry","text":"","category":"section"},{"location":"man/geometry/","page":"Voronoi: Nodes and Geometry, Integrators","title":"Voronoi: Nodes and Geometry, Integrators","text":"The creation and storage of Voronoi geometry data is handled by the following class. ","category":"page"},{"location":"man/geometry/","page":"Voronoi: Nodes and Geometry, Integrators","title":"Voronoi: Nodes and Geometry, Integrators","text":"VoronoiGeometry{T}","category":"page"},{"location":"man/geometry/#HighVoronoi.VoronoiGeometry","page":"Voronoi: Nodes and Geometry, Integrators","title":"HighVoronoi.VoronoiGeometry","text":"VoronoiGeometry{T}\n\nThis is the fundamental struct to store information about the generated Voronoi grid. The geometric data can be accessed using the type VoronoiData.  However, there is always the possibility to access the data also via the following fields:\n\nIntegrator.Integral: stores the integrated values in terms of a Voronoi_Integral\nbasic_mesh: stores the fundamental data of nodes and verteces. also stored in Integrator.Integral.MESH\nnodes: direct reference to the nodes. Also provided in basic_mesh.nodes\n\nwarning: Avoid direct access to the data\nAccessing the data directly, that is without calling VoronoiData, is likely to cause confusion or to provide \"wrong\" information.  The reason is that particularly for periodic boundary conditions, the mesh is enriched by a periodization of the boundary nodes.  These nodes are lateron dropped by the VoronoiData-Algorithm.       \n\n\n\n\n\n","category":"type"},{"location":"man/geometry/","page":"Voronoi: Nodes and Geometry, Integrators","title":"Voronoi: Nodes and Geometry, Integrators","text":"To create a Voronoi mesh it is most convenient to call either of the following methods","category":"page"},{"location":"man/geometry/","page":"Voronoi: Nodes and Geometry, Integrators","title":"Voronoi: Nodes and Geometry, Integrators","text":"VoronoiGeometry()","category":"page"},{"location":"man/geometry/#HighVoronoi.VoronoiGeometry-Tuple{}","page":"Voronoi: Nodes and Geometry, Integrators","title":"HighVoronoi.VoronoiGeometry","text":"VoronoiGeometry(xs::Points,b::Boundary)\n\nThis creates a Voronoi mesh from the points xs given e.g. as an array of SVector and a boundary b that might be constructed using  the commands in the Boundaries section.\n\nYou have the following optional commands:\n\nsilence: Suppresses output to the command line when true. The latter will speed up the algorithm by a few percent. default is false. \nintegrator: can be either one of the following values:\nVI_GEOMETRY: Only the basic properties of the mesh are provided: the verteces implying a List of neighbors of each node\nVI_MONTECARLO: Volumes, interface areas and integrals are calculated using a montecarlo algorithm.    This particular integrator comes up with the following additional paramters:\nmc_accurate=(int1,int2,int3): Montecarlo integration takes place in int1 directions, over int2    volumetric samples (vor volume integrals only). It reuses the same set of directions int3-times to save memory allocation time.   Standard setting is: (1000,100,20).\nVI_POLYGON: We use the polygon structure of the mesh to calculate the exact values of interface area and volume. The    integral over functions is calculated using the values at the center, the verteces and linear interpolation between.  \nVI_HEURISTIC: When this integrator is chosen, you need to provide a fully computed Geometry including volumes and interface areas.   VI_HEURISTIC will then use this information to derive the integral values.\nVI_HEURISTIC_MC: This combines directly VI_MONTECARLO calculations of volumes and interfaces and calculates integral values    of functions based on those volumes and areas. In particular, it also relies on mc_accurate!\nintegrand: This is a function f(x) depending on one spatial variable x returning a Vector{Float64}.    The integrated values will be provided for each cell and for each pair of neighbors, i.e. for each interface\nperiodic_grid: This will initiate a special internal routine to fastly create a periodic grid. Look up the section in the documentation. \n\nWith density distribution:\n\nVoronoiGeometry(number::Int,b=Boundary();density, kwargs...)\n\nthis call genertates a distribution of approsximately number nodes and generates a VoronoiGeometry. It takes as parameters all of the  above mentioned keywords (though periodic_grid makes no sense) and all keywords valid for a call of VoronoiNodes(number;domain=b,density=density, ....)  \n\nIn future versions, there will be an implementation of the parameter cubic=true, where the grid will be generated based on a distribution of \"cubic\" cells. In the current version there will be a warning that this is not yet implemented.\n\nAdvanced methods\n\nVoronoiGeometry(file::String)\nVoronoiGeometry(VG::VoronoiGeometry)\n\nLoads a Voronoi mesh from the file or copies it from the original data VG. If integrator is not provided, it will use the original integrator stored to the file.  In the second case, if integrand is not provided explicitly, it will use integrand = VG.integrand as standard. Additionally it has the following options:\n\n_myopen=jldopen: the method to use to open the file. See the section on write_jld.\nvertex_storage: Defines the way data is stored internally. standard is the most recent and most efficient method DatabaseVertexStorage(). Other options are the        ReferencedVertexStorage() which is slower but may be useful in low dimensions and the ClassicVertexStorage() which is fast for integration algorithms in        low dimensions and which was the first database structure underlying the computations. This parameter can of course only be set upon the very first creation of        the geometry and cannot be modified afterwards.\nsearch_settings: a NamedTuple mostly to provide (method = ... ,threading = ...) where method chooses the Raycast method and threading provides information        on the multithreading\noffset: See the section on write_jld.\nintegrate=false: This will or will not call the integration method after loading/copying the data. Makes sense for using VI_HEURISTIC together with       volume=true, area=true and providing values for integrand and integrand. If integrand != nothing but bulk==false or interface==false        this parameter will internally be set true.\nvolume=true: Load volume data from file\narea=true: Load interface area data from file\nbulk=false: Load integrated function values on the cell volumes from file. When set true and integrand=f is provided    the method  will compare the dimension of f and of the stored data. \ninterface=false: Load integrated function values on the interfaces. When set true and integrand=f is provided    the method  will compare the dimension of f and of the stored data.\n\n\n\n\n\n","category":"method"},{"location":"man/geometry/#integratoroverview","page":"Voronoi: Nodes and Geometry, Integrators","title":"Integrators (overview)","text":"","category":"section"},{"location":"man/geometry/","page":"Voronoi: Nodes and Geometry, Integrators","title":"Voronoi: Nodes and Geometry, Integrators","text":"As discussed above there is a variety of integrators available to the user, plus some internal integrators that we will not discuss in this manual. The important integrators for the user are:","category":"page"},{"location":"man/geometry/","page":"Voronoi: Nodes and Geometry, Integrators","title":"Voronoi: Nodes and Geometry, Integrators","text":"VI_GEOMETRY: Only the basic properties of the mesh are provided: the verteces and an implicit list of neighbors of each node. This is the fastes way to generate a VoronoiGeometry\nVI_MONTECARLO: Volumes, interface areas and integrals are calculated using a montecarlo algorithm introduced by A. Sikorski in VoronoiGraph.jl and discussed in a forthcoming article by Heida, Sikorski, Weber. This particular integrator comes up with the following additional paramters:\nmc_accurate=(int1,int2,int3): Montecarlo integration takes place in int1 directions, over int2        volumetric samples (vor volume integrals only). It reuses the same set of directions int3-times to save memory allocation time.       Standard setting is: (1000,100,20).\nVI_POLYGON: We use the polygon structure of the mesh to calculate the exact values of interface area and volume. The        integral over functions is calculated using the values at the center, the verteces and linear interpolation between. Also this method is to be discussed in the anounced article by Heida, Sikorski, Weber. \nVI_FAST_POLYGON: Even more precise than VI_POLYGON, very fast (50 secs for 500 nodes in 6D) but using a lot of memory. It is advised to use this integrator if you insists on accuracy over performance and if you have large RAM (advised >=4GB of FREE RAM). On my personal machine with total 16GB RAM VI_FAST_POLYGON is by factor 15 faster than VI_POLYGON for 500 nodes in 6 dimensions and integrating xrightarrow(x_1x_2^2).\nVI_HEURISTIC: When this integrator is chosen, you need to provide a fully computed Geometry including volumes and interface areas.       VI_HEURISTIC will then use this information to derive the integral values.\nVI_HEURISTIC_MC: This combines directly VI_MONTECARLO calculations of volumes and interfaces and calculates integral values        of functions based on those volumes and areas. In particular, it also relies on mc_accurate!","category":"page"},{"location":"man/geometry/","page":"Voronoi: Nodes and Geometry, Integrators","title":"Voronoi: Nodes and Geometry, Integrators","text":"It is important to have in mind that the polygon-integrator will be faster in low dimensions, whereas the Montecarlo integrator will outperform from 5 dimensions and higher. However, when volumes and integrals are to be calculated in high dimensions, the VI_HEURISTIC_MC is highly recommended, as it works with much less function evaluations than the VI_MONTECARLO. ","category":"page"},{"location":"man/geometry/#Storage:-JLD2","page":"Voronoi: Nodes and Geometry, Integrators","title":"Storage: JLD2","text":"","category":"section"},{"location":"man/geometry/","page":"Voronoi: Nodes and Geometry, Integrators","title":"Voronoi: Nodes and Geometry, Integrators","text":"you may use JLD2 to directly write a VoronoiGeometry or VoronoiData object to a file. It will be made sure that storing and reading data will be downward compatible in future. ","category":"page"},{"location":"man/geometry/#Storage:-deprecated-solution","page":"Voronoi: Nodes and Geometry, Integrators","title":"Storage: deprecated solution","text":"","category":"section"},{"location":"man/geometry/","page":"Voronoi: Nodes and Geometry, Integrators","title":"Voronoi: Nodes and Geometry, Integrators","text":"The following solution is still available for grids that have been created with ClassicVertexStorage(). However, it is not advised to use them.","category":"page"},{"location":"man/geometry/","page":"Voronoi: Nodes and Geometry, Integrators","title":"Voronoi: Nodes and Geometry, Integrators","text":"write_jld()","category":"page"},{"location":"man/geometry/#HighVoronoi.write_jld-Tuple{}","page":"Voronoi: Nodes and Geometry, Integrators","title":"HighVoronoi.write_jld","text":"The data can be stored using the write_jld method:\n\nwrite_jld(Geo::VoronoiGeometry,filename,offset=\"\";_myopen=jldopen)\nwrite_jld(Geo::VoronoiGeometry,file,offset=\"\")\n\nstores the complete information of a VoronoiGeometry object to a file. This information can later be retrieved using the VoronoiGeometry(file::String, args...) function.\n\nGeo: The Voronoi geometry object to be stored\nfilename: name of file to store in\nfile: A file given in a format supporting write(file,\"tagname\",content) and read(file,\"tagname\",content) \noffset: If several Geometry objects are to be stored in the same file, this will be the possibility to identify each one by a unique name. In particular, this is the key to store several objects in one single file.\n_myopen: a method that allows the syntax _myopen(filename,\"w\") do myfile ....... end. By default the method uses the JLD2 library as this (at the point of publishing this package) has the least problems with converting internal data structure to an output format.\n\nwarning: Filname extension\nIf you want to use the default method, then the filename should end on .jld. Otherwise there might be confusion by the abstract built in julia loading algorithm.\n\n\n\n\n\n","category":"method"},{"location":"man/geometry/","page":"Voronoi: Nodes and Geometry, Integrators","title":"Voronoi: Nodes and Geometry, Integrators","text":"load_Voronoi_info()","category":"page"},{"location":"man/geometry/#Extraction-of-VoronoiData-data-for-further-processing","page":"Voronoi: Nodes and Geometry, Integrators","title":"Extraction of VoronoiData data for further processing","text":"","category":"section"},{"location":"man/geometry/","page":"Voronoi: Nodes and Geometry, Integrators","title":"Voronoi: Nodes and Geometry, Integrators","text":"VoronoiData","category":"page"},{"location":"man/geometry/#HighVoronoi.VoronoiData","page":"Voronoi: Nodes and Geometry, Integrators","title":"HighVoronoi.VoronoiData","text":"Using the call \n\ndata=VoronoiData(VG)\n\nsome data of the Voronoi geometry VG is extracted and presented to the user in a convenient way that requires no knowledge of the complicated multilevel data structures of VoronoiGeometry. Once applied, the data set contains at least the following informations:\n\nnodes::Vector{T}: The original nodes\nvertices: For each i this is an iterator over the vertices of cell i\nboundary_vertices: This is an iterator of the form edge => (base,direction,node) where edge is a list of generators    of an infinite edge, base the start of the edge, direction the orientation and node is one additional generator that    defines base together with edge.\n\nAdditional Fields in VoronoiData\n\nThe set data contains the following additional information, which is READ_ONLY in the standard setting. The standard read-only datastructures are highly involved as the output values are generated on-the-fly from internal data in order to save memory. See below to extract easier editable data structures\n\nneighbors: For each node nodes[i] the field neighbors[i] contains a sorted list of indeces of all neighboring cells.      Multiple appearence of the same node is possible on a periodic grid. \nvolume: the volume for each node\narea: stores for each neighbor neighbors[i][k] of node i in area[i][k] the area of the interface.\nbulk_integral: the integral over the bulk of each cell. bulk_integral[i] is of type AbstractVector{Float64}\ninterface_integral: same as for area but with the integral values of the interface function. In paricular    interface_integral[i][k] is of type AbstractVector{Float64}\norientations: If the neighbors have been calculated by the integral algorithm, then for each neighbor[i][k] there is the    matched orientation from i to k. This is particularly useful in periodic geometries, where manual calculation of this vector is tricky. \nboundary_nodes: A collection iterating as Tuple(generator_i,collection(boundary_index=>mirrored_generator)). In particular, if the cell of generator i touches    the boundary then boundary_nodes has a key i. The value is a dictionary that has for every boudnary plane 'k' that is touched    the mirrored version of generator i (if onboudary=false) or its projection onto plane k (if onboudary=true).  \noffset: If reduce_to_periodic=false, this field will contain the number of internal nodes. The official nodes start from offset+1.\nreferences: If offset>0 then there exist a vectors references and reference_shifts of length(offset) stating    that node[i]=node[references[i]]+reference_shifts[i] for i in 1:length(offset).\nreference_shifts: See the previous entry\nboundary: If reduce_to_periodic=false this contains the internal boundary that is used to compute the periodic structure.    Otherwise this contains the official boundary of the domain.\ngeometry: For internal use, this is a reference to VG.\n\nwarning: No request implies empty data field\nIf the above data fields where calculated by the integration algorithm, they have no values assigned for 1:offset.  On the other hand, you may check this with isassigned. Also if reduce_to_periodic=false, the values for indices <= offset are not assigned.\n\nNamed Arguments\n\nThe call of VoronoiData(VG) provides the following options:\n\ngetFIELD: replace FIELD with any of the above names except geometry to obtain a hard copy of the respective data that is detached from the internal data structure and can be modified or stored separately. \ncopyall=true: corresponds to setting getFIELD=true  for every FIELD.\nreduce_to_periodic=true: This hides all internal data generated from the periodization. It is highly advised to set this option to true   as the user will then only see the periodic mesh with no information overhead.\nonboundary=false: refer to boundary_nodes above \nsorted=true: During the reduction of the internal pseudo periodic mesh to the fully periodic output, the neighbors (jointly with their respective properties) get sorted by their numbers. This is only possible if getarea,getneighbors and getinterfaceintegral are true. Otherwise it will be ignored\n\n\n\n\n\n","category":"type"},{"location":"man/improving/#toyfile","page":"Improving Voronoi meshes for FV ","title":"Improving Voronoi meshes for FV ","text":"","category":"section"},{"location":"man/improving/","page":"Improving Voronoi meshes for FV ","title":"Improving Voronoi meshes for FV ","text":"It has been shown that finite volume methods for elliptic PDE should be more accurate if for each generator the distance to its vertices is approximately equal. This can be achieved as follows:","category":"page"},{"location":"man/improving/","page":"Improving Voronoi meshes for FV ","title":"Improving Voronoi meshes for FV ","text":"mynodes = VoronoiNodes(rand(2,200))\r\nVG1 = VoronoiGeometry(copy(mynodes),cuboid(2,periodic=[]),integrator=VI_GEOMETRY)\r\ndraw2D(VG1)\r\nVG2 = VoronoiGeometry(copy(mynodes),cuboid(2,periodic=[]),integrator=VI_GEOMETRY,improving=(max_iterations=5,))\r\ndraw2D(VG2)","category":"page"},{"location":"man/improving/","page":"Improving Voronoi meshes for FV ","title":"Improving Voronoi meshes for FV ","text":"The above example generates two Voronoi grids: One where mesh is generated from the given nodes and one using the improving keyword, where the nodes are modified so that the nodes will lie closer to the centers of mass of their respective Voronoi cell. This is an iterative process and takes the following parameters:","category":"page"},{"location":"man/improving/","page":"Improving Voronoi meshes for FV ","title":"Improving Voronoi meshes for FV ","text":"max_iterations::Int = 1: The process will stop after this amount of iterations even if the wanted accuracy is not achieved.\ntolerance::Float64 = 1.0: if the distance between a node and the center of mass D and the minimal distance of the node to the boundary r satisfy D/r < tolerance the node will not be modified.","category":"page"},{"location":"man/improving/","page":"Improving Voronoi meshes for FV ","title":"Improving Voronoi meshes for FV ","text":"The following pictures illustrate the improvement of the mesh for standard setting and 200 Points in mathbb R^2:","category":"page"},{"location":"man/improving/#Original-Mesh","page":"Improving Voronoi meshes for FV ","title":"Original Mesh","text":"","category":"section"},{"location":"man/improving/","page":"Improving Voronoi meshes for FV ","title":"Improving Voronoi meshes for FV ","text":"(Image: original)","category":"page"},{"location":"man/improving/#Modified-Mesh","page":"Improving Voronoi meshes for FV ","title":"Modified Mesh","text":"","category":"section"},{"location":"man/improving/","page":"Improving Voronoi meshes for FV ","title":"Improving Voronoi meshes for FV ","text":"(Image: nodes versus time in 5D)","category":"page"},{"location":"man/refine/#refinementsection","page":"Refinement and Substitution of Subdomains","title":"Refinement and Substitution of Subdomains","text":"","category":"section"},{"location":"man/refine/","page":"Refinement and Substitution of Subdomains","title":"Refinement and Substitution of Subdomains","text":"HighVoronoi.jl allows you to refine a mesh in two different ways: ","category":"page"},{"location":"man/refine/","page":"Refinement and Substitution of Subdomains","title":"Refinement and Substitution of Subdomains","text":"refinement by locally adding addional points \nsubstitution: in a given domain the existing mesh is replaced by another geometry. ","category":"page"},{"location":"man/refine/#Refinement-using-refine!","page":"Refinement and Substitution of Subdomains","title":"Refinement using refine!","text":"","category":"section"},{"location":"man/refine/","page":"Refinement and Substitution of Subdomains","title":"Refinement and Substitution of Subdomains","text":"The intention of refine! is to refine a given mesh in a region where the users wants a more detailed view at a later stage of either the same code or built upon calculated and stored data. It can use its own search_settings that are knwon from VoronoiGeometry(...). In particular, the Voronoi computation can be parallelized. ","category":"page"},{"location":"man/refine/","page":"Refinement and Substitution of Subdomains","title":"Refinement and Substitution of Subdomains","text":"    VG = VoronoiGeometry(VoronoiNodes(rand(5,1000),cuboid(5)))\r\n\r\n    ## Do some fancy stuff with `VG`\r\n    ## ...\r\n    ## Now we want to refine the geometry with additional VoronoiNodes xs\r\n\r\n    refine!(VG,xs,update=true, search_settings=(method=RCNonGeneral,)) # original 'search_settings' of VG like `method`or `threading` can be temporarily overwritten ","category":"page"},{"location":"man/refine/","page":"Refinement and Substitution of Subdomains","title":"Refinement and Substitution of Subdomains","text":"hint: On `update`...\nThe parameter update::Bool tells whether or not the volumes and intgrals of new or modified cells shall be recalculated / updated. Its default value is update=true. One could also use  update=false and call integrate!(VG) instead. This will have (much) higher computational costs.","category":"page"},{"location":"man/refine/#Refinement-using-substitute!","page":"Refinement and Substitution of Subdomains","title":"Refinement using substitute!","text":"","category":"section"},{"location":"man/refine/","page":"Refinement and Substitution of Subdomains","title":"Refinement and Substitution of Subdomains","text":"The intention of substitute! is fast mesh generation in high dimensions, particularly in combo with periodic_grid. In this way the algorithm will have to calculate much less verteces explicitly. As an additional benefit, using periodic_grid we can achieve a grid with rather few neighbors, resulting in a much sparser matrix than with fully random nodes.","category":"page"},{"location":"man/refine/","page":"Refinement and Substitution of Subdomains","title":"Refinement and Substitution of Subdomains","text":"substitute!(VG::VoronoiGeometry,VG2::VoronoiGeometry,indeces)","category":"page"},{"location":"man/refine/#HighVoronoi.substitute!-Tuple{VoronoiGeometry, VoronoiGeometry, Any}","page":"Refinement and Substitution of Subdomains","title":"HighVoronoi.substitute!","text":"substitute!(VG::VoronoiGeometry,VG2::VoronoiGeometry,indeces)\n\nTakes the nodes indeces from VG2 and erases all nodes from VG within the VornoiCells of indeces. Then plugs the nodes  indeces into VG and generates the full mesh for this new setting.\n\n\n\n\n\n","category":"method"},{"location":"man/refine/","page":"Refinement and Substitution of Subdomains","title":"Refinement and Substitution of Subdomains","text":"indeces_in_subset(VG::VoronoiGeometry,B::Boundary)","category":"page"},{"location":"man/refine/#HighVoronoi.indeces_in_subset-Tuple{VoronoiGeometry, Boundary}","page":"Refinement and Substitution of Subdomains","title":"HighVoronoi.indeces_in_subset","text":"indeces_in_subset(VG::VoronoiGeometry,B::Boundary)\n\nreturns all indeces of VG lying within B.\n\n\n\n\n\n","category":"method"},{"location":"man/refine/","page":"Refinement and Substitution of Subdomains","title":"Refinement and Substitution of Subdomains","text":"warning: Domain and Boundary condition matching\nThe domains of the original and the substitute Geometry MUST match. HighVoronoi will not controll this but you may have strange results or even a clash. Furthermore, both domains should have the same periodic boundary conditions. ","category":"page"},{"location":"man/refine/","page":"Refinement and Substitution of Subdomains","title":"Refinement and Substitution of Subdomains","text":"The following code will create a cubic grid with poor resolution in mathbb R^8 and then refine it by a cubic grid with high resolution in the cube (071)^8. Furthermore, the grid will have periodic boundaries in dimensions 1 and 5.","category":"page"},{"location":"man/refine/","page":"Refinement and Substitution of Subdomains","title":"Refinement and Substitution of Subdomains","text":"    VG = VoronoiGeometry(VoronoiNodes(rand(8,1)),periodic_grid = ( dimensions=ones(Float64,dim), \r\n            scale=0.2*ones(Float64,dim), repeat=5*ones(Int64,dim), \r\n            periodic=[1,5], fast=true ))\r\n\r\n    substitute_VG = VoronoiGeometry(VoronoiNodes(rand(8,1)),periodic_grid = ( dimensions=ones(Float64,dim), \r\n            scale=0.05*ones(Float64,dim), repeat=20*ones(Int64,dim), \r\n            periodic=[1,5], fast=true ))\r\n\r\n    ## now pu all that stuff togetehr\r\n\r\n    substitute_indeces = indeces_in_subset(substitute_VG,cuboid(8,periodic=[],dimensions=0.3*ones(Float64,8),offset=0.7*ones(Float64,8)))\r\n    substitute!(VG, substitute_VG, substitute_indeces)","category":"page"},{"location":"man/functions/#createalltypesoffunctions","page":"Functions","title":"Periodic functions","text":"","category":"section"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"To make a function f periodic with respect to a (partially) periodic boundary b::Boundary or geometry VG::VoronoiGeometry use the following","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"f2 = PeriodicFunction(f::Function,b::Boundary)\r\nf2 = PeriodicFunction(f::Function,VG::VoronoiGeometry)","category":"page"},{"location":"man/functions/#Step-functions","page":"Functions","title":"Step functions","text":"","category":"section"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"Use one of the following methods to create a step function on the Voronoi grid:","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"f = StepFunction(VG::VoronoiGeometry, u<:AbstractVector; tree::Union{VoronoiKDTree,KDTree})\r\nf = StepFunction(VG::VoronoiGeometry, u::Function; tree::Union{VoronoiKDTree,KDTree})\r\nf = StepFunction(VG::VoronoiGeometry; tree::Union{VoronoiKDTree,KDTree})\r\nf = StepFunction(nodes::VoronoiNodes, u<:AbstractVector; tree::Union{VoronoiKDTree,KDTree}=KDTree(nodes))","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"This yields a step function f that is constant on every cell of the VoronoiGeometry VG or on the Voronoi tessellation given by nodes. If u is an abstract vector, the value f(x)=u[i] is assigned if - according to tree - the nearest neighbor of x is the i-th node of VG or nodes. If no value for u is provided, StepFunction will retrieved bulk-integral data stored in VG. If VG has no bulk-data, the step-function will return nothing.","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"tree can be a KDTree from NearestNeighbors.jl or a VoronoiKDTree. It is highly recommended to use the last one as it accounts for periodicity.","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"Finally, consider the following advanced code:","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"    # create a composed function for integration\r\n    f = FunctionComposer(reference_argument = [0.0,0.0], super_type = Float64, alpha = x->norm(x)*x, beta = x->sum(abs,x) )\r\n    # create a VoronoiGeometry and integrate :alpha, :beta\r\n    VG = VoronoiGeometry(VoronoiNodes(rand(2,40)), cuboid(2,periodic=[1]), integrator=HighVoronoi.VI_MONTECARLO, integrand=f.functions)\r\n    # make a step function from integrated values:\r\n    f_all = StepFunction(VG)\r\n    # retrieve the alpha and beta- components as a single (real) valued stepfunctions\r\n    alpha_step = x-> HighVoronoi.decompose(f, f_all(x),scalar=true)[:alpha]\r\n    beta_step = x-> HighVoronoi.decompose(f, f_all(x),scalar=true)[:beta]\r\n    # generate some sample output\r\n    println(alpha_step([0.5,0.5]))\r\n    println(beta_step([0.5,0.5]))","category":"page"},{"location":"man/functions/#VoronoiKDTree","page":"Functions","title":"VoronoiKDTree","text":"","category":"section"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"vt = VoronoiKDTree(VG::VoronoiGeometry; restrict_to_periodic=true)","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"This will create a KDTree that accounts for periodicity of VG.  restrict_to_periodic=true implies that the \"official\" nodes are used only. It is highly recommended not to change this option if you are not knowing what you are doing.","category":"page"},{"location":"man/functions/#Diameters-of-cells","page":"Functions","title":"Diameters of cells","text":"","category":"section"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"f = DiameterFunction(VG::VoronoiGeometry; tree = VoronoiKDTree(VG))","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"This yields f(x)=(rR) where r is the inner and R the outer radius of the Voronoi cell that contains x. This is by its nature a step function.","category":"page"},{"location":"man/functions/#Functions-on-interfaces","page":"Functions","title":"Functions on interfaces","text":"","category":"section"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"It can be usefull to consider the integrated values over the interfaces of the Voronoi tessellation as a function. This is achieved by InterfaceFunction:","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"f = InterfaceFunction(VD::VoronoiData,range,symbol=nothing;scalar=true)","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"This takes the VD::VoronoiData and creates a function that locally takes the value VD.interface_integral[i][k] over the respective interface. The value f(x) of the function is chosen according to the two nearest neighbors, hence there is  ambiguity in points with more than 2 nearest neighbors.","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"range: This can be a FunctionComposer-opject, in which case symbol has to be provided. It can also be a:b or [a1,a2,...,aN] to take a subarray of the values. It can also be :all in which case the full vector of values is taken.\nscalar: If true, then vectors with only one index will be returned as scalar values.  ","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"f = InterfaceFunction(VG::VoronoiGeometry,range,symbol=nothing;scalar=true)","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"Calculates the VoronoiData and calls the first instance of the method.","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"f = InterfaceFunction(VG::VoronoiGeometry)","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"Sets range to the full data range. Similar to the above example for StepFunctions one may consider the following setting:","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"    # create a composed function for integration\r\n    f = FunctionComposer(reference_argument = [0.0,0.0], super_type = Float64, alpha = x->norm(x)*x, beta = x->sum(abs,x) )\r\n    # create a VoronoiGeometry and integrate :alpha, :beta\r\n    VG = VoronoiGeometry(VoronoiNodes(rand(2,40)), cuboid(2,periodic=[1]), integrator=HighVoronoi.VI_MONTECARLO, integrand=f.functions)\r\n    # make a step function from integrated values:\r\n    f_all = InterfaceFunction(VG)\r\n    # retrieve the alpha and beta- components as a single (real) valued stepfunctions\r\n    alpha_i = x-> HighVoronoi.decompose(f, f_all(x),scalar=true)[:alpha]\r\n    beta_i = x-> HighVoronoi.decompose(f, f_all(x),scalar=true)[:beta]\r\n    # generate some sample output\r\n    println(alpha_i([0.5,0.5]))\r\n    println(beta_i([0.5,0.5]))","category":"page"},{"location":"man/functions/#Functions-from-Data","page":"Functions","title":"Functions from Data","text":"","category":"section"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"If you want to generate a function from various integrated data in your own way, you can call","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"FunctionFromData(vg::VoronoiGeometry,tree=VoronoiKDTree(vg),composer=nothing; function_generator)","category":"page"},{"location":"man/functions/#HighVoronoi.FunctionFromData","page":"Functions","title":"HighVoronoi.FunctionFromData","text":"FunctionFromData(args...)\n\ncomes in to variations:\n\nFunctionFromData(vg::VoronoiGeometry,tree=VoronoiKDTree(vg),composer=nothing; function_generator)\n\ngenerates a function \n\nx->function_generator( data=VoronoiData(vg), composer=composer, _Cell=nearest_neighbor_of(x) )\n\nfrom vg, tree and a function \n\nfunction_generator(;data ,composer , _Cell )\n\nwhich takes data::VoronoiData generated from vg, composer from above and _Cell::Int for  the number of the current node and returns a Float64 or a Vector{Float64} or anything else  if you do not plan to hand it over to the routines of HighVoronoi.  You can access every entry of VoronoiData to generate the value you want to be associated with the  Voronoi cell belonging to vd.nodes[_Cell].\n\nFunctionFromData(vd::VoronoiData,tree::VoronoiKDTree,composer=nothing; function_generator)\n\nbasically does the same but takes a vd::VoronoiData and tree mandatorily and  passes vd to the function_generator.\n\n\n\n\n\n","category":"function"},{"location":"man/functions/#The-FunctionComposer:-Passing-function-arguments","page":"Functions","title":"The FunctionComposer: Passing function arguments","text":"","category":"section"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"info: Always glue functions with a FunctionComposer\nThe FunctionComposer is internally used to glue together real valued functions. Therefore, if a user wants to glue together functions and afterwards work with \"glued\" information generated from HighVoronoi, using FunctionComposer is the way unify internal and external calculations. ","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"The FunctionComposer is the element implemented in HighVoronoi to concatenate several Float or Vector{Float} valued functions into one single Vector{Float}-valued function using vcat(...). It is built using a call of the following method.","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"FunctionComposer(;reference_argument, super_type, _functions...)","category":"page"},{"location":"man/functions/#HighVoronoi.FunctionComposer-Tuple{}","page":"Functions","title":"HighVoronoi.FunctionComposer","text":"FunctionComposer(;reference_argument, super_type, _functions...)\n\nThe composer takes the following arguments:\n\n_functions: This is a list of named funcions.\nsuper_type: suppose your functions return values of type T and Vector{T} you should set super_type=T\nreference_argument: Your functions take values of type Float and are well defined in 0.0? Then you can put e.g. 0.0 here.    If your function accepts StaticArray{3,Float64} put e.g. SVector{3,Float64}([0.0,1.2,3.4])\n\n\n\n\n\n","category":"method"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"A typical example would be","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"f = FunctionComposer(reference_argument = [0.0,0.0,0.0], super_type = Float64, alpha = x->norm(x)*x, beta = x->sum(abs,x) )","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"or:","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"myfunctions=(alpha = x->norm(x)*x, beta = x->sum(abs,x))\r\nf = FunctionComposer(reference_argument = [0.0,0.0,0.0], super_type = Float64; myfunctions...  )","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"The latter has the advantage that you can define your set of functions once and for all and use it again and again ensuring you always have the same order in the arguments. This brings us to an important point:","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"warning: Don't mess with the order of arguments\nFunctionComposer takes the order of functions as given in the argument. That is if you make function callsf1 = FunctionComposer(reference_argument = [0.0,0.0,0.0], super_type = Float64, alpha = exp, beta = sin  )\r\nf2 = FunctionComposer(reference_argument = [0.0,0.0,0.0], super_type = Float64; beta = sin, alpha = exp  )    the algorithm will create two different functions x->[exp(x),sin(x)] and x->[sin(x),exp(x)] and it will NOT be able to clear up the mess this creates....","category":"page"},{"location":"man/functions/#Retrieving-the-full-(combined)-function","page":"Functions","title":"Retrieving the full (combined) function","text":"","category":"section"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"The full function is stored in the variable FunctionComposer.functions.","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"myfunctions=(alpha = x->norm(x)*x, beta = x->sum(abs,x))\r\nf = FunctionComposer(reference_argument = [0.0,0.0,0.0], super_type = Float64; myfunctions...  )\r\n\r\nmyvalue = f.functions([1.2,3.4,5.6])","category":"page"},{"location":"man/functions/#Decomposing-the-Composer","page":"Functions","title":"Decomposing the Composer","text":"","category":"section"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"To retrieve single information from an array like myvalue in the last example, you can simply use the internal function HighVoronoi.decompose(...):","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"myfunctions=(alpha = x->norm(x)*x, beta = x->sum(abs,x))\r\nf = FunctionComposer(reference_argument = [0.0,0.0,0.0], super_type = Float64; myfunctions...  )\r\n\r\nmyvalue = f.functions([1.2,3.4,5.6])\r\n\r\nvalues = HighVoronoi.decompose(f, myvalue)\r\n\r\nprintln(values[:alpha], values[:beta])","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"If you whish 1d-vectors to be returned as scalars, try out this one:","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"values2 = HighVoronoi.decompose(f, myvalue, scalar=true)\r\n\r\nprintln(values2[:alpha], values2[:beta])","category":"page"},{"location":"man/workflowfv/#workflowfv","page":"Workflow in FV","title":"Workflow in FV","text":"","category":"section"},{"location":"man/workflowfv/","page":"Workflow in FV","title":"Workflow in FV","text":"In order to create a Finite Volume problem you have several options you should think through and decide:","category":"page"},{"location":"man/workflowfv/","page":"Workflow in FV","title":"Workflow in FV","text":"Geometry, i.e. the cells and interfaces on which your finite volume problem is defined can be generated in two ways:\nprior using this guide\non the fly: passing arguments to VoronoiFVProblem in the third step below as if it was a VoronoiGeometry.\nYou may whish to define some step functions or interface function or any type of customized functions from integrated data using this guide\nCreate a VoronoiFVProblem (if not done in first step)\nprovide the VoronoiGeometry\noptionally provide integralfunctions whose values are infered on cells and interfaces using the chosen integration method\noptionally provide discretefunctions whose values are infered by pointwise evaluation\noptionally provide fluxes as a named tuple of description how fluxes should be calculated using this guide\noptionally provide rhs_functions a named tuple of descriptions how to compute a potential right hand side in the FV problem using this guide\noptionally provide bulk_integrals as a way to integrate a function over the tessellation using this guide\noptionally provide flux_integrals as a way to integrate a function over the interfaces of the tessallation using this guide\nYou may whish to define some more step functions or interface function or any type of customized functions from integrated data using this guide and the integrate information in VoronoiFVProblem using this guide\nCall linearVoronoiFVProblem with a given description of fluxes and right hand sides provided by VoronoiFVProblem and your favorite boundary conditions using this guide. (caution: since boundary conditions rely on a given boundary, the periodic boundary conditions are subject of VoronoiGeometry, resp. Boundary, so this has to be implemented in the very first step.)","category":"page"},{"location":"man/toyfvfile/#toyfile","page":"Some code to test and play around","title":"Some code to test and play around","text":"","category":"section"},{"location":"man/toyfvfile/","page":"Some code to test and play around","title":"Some code to test and play around","text":"The following code works as it is. It takes as parameters a function u, a field kappa and the dimension dim. It then calculates -nabla(kappanabla u)=f and creates discrete versions of kappa and f to generate a numerical solution u. Finally it compares the numerical and the exact solution in L^2 and plots the numerical result in case dim==2.","category":"page"},{"location":"man/toyfvfile/","page":"Some code to test and play around","title":"Some code to test and play around","text":"The boundary conditions below are set periodic in dimension 1 , Dirichlet at x_2=1 and Neumann at x_2=0 but you can change this according to your whishes.","category":"page"},{"location":"man/toyfvfile/","page":"Some code to test and play around","title":"Some code to test and play around","text":"The nodes distribution is as standard iid but you can provide a density. The code is implemented to generate 1000 nodes but you can change this as well.","category":"page"},{"location":"man/toyfvfile/","page":"Some code to test and play around","title":"Some code to test and play around","text":"using HighVoronoi\r\nusing SparseArrays\r\nusing IterativeSolvers\r\nusing NearestNeighbors\r\nusing LinearAlgebra\r\nusing StaticArrays\r\n\r\n\r\n##########################################################################################\r\n\r\n## Derivatives\r\n\r\n##########################################################################################\r\n\r\nfunction ∂_k(f,x,k;dim=length(x),vec2=MVector{dim}(zeros(Float64,dim)))\r\n    h = 0.00245\r\n    vec2 .= x\r\n    vec2[k] += h\r\n    f1 = f(vec2)\r\n    vec2[k] += h\r\n    f2 = f(vec2)\r\n    vec2 .= x\r\n    vec2[k] -= h\r\n    f3 = f(vec2)\r\n    vec2[k] -= h\r\n    f4 = f(vec2)\r\n    return ( 8*(f1-f3) + (f4-f2) ) / ( 12*h ) # five-point stencil\r\nend\r\n\r\nfunction ∇(f::Function,dim)\r\n    vec2=MVector{dim}(zeros(Float64,dim))\r\n    return x->map(k->∂_k(f,x,k,dim=dim,vec2=vec2),1:dim)\r\nend\r\n\r\nfunction ∇_buffered(f::Function,dim,vec=MVector{dim}(zeros(Float64,dim)),base=HighVoronoi.empty_local_Base(dim))\r\n    vec = MVector{dim}(zeros(Float64,dim))\r\n    vec2 = MVector{dim}(zeros(Float64,dim))\r\n    return x->map!(k->∂_k(f,x,k,dim=dim,vec2=vec2),vec,1:dim)\r\nend\r\n\r\nfunction ∇cdot(f::Function,dim)\r\n    function sum_partials(f,x,dim,vec2)\r\n        f_sum = 0.0\r\n        for k in 1:dim\r\n            f_sum += ∂_k(y->f(y)[k],x,k,dim=dim,vec2=vec2)\r\n        end\r\n        return f_sum\r\n    end\r\n    vec = MVector{dim}(zeros(Float64,dim))\r\n    return x->sum_partials(f,x,dim,vec)\r\nend\r\n\r\nfunction neumann_bc(flux,domain,x)\r\n    function plane_of_x(domain,x)\r\n        k = 0\r\n        dist = 10.0\r\n        ldp = length(domain.planes)\r\n        for i in 1:ldp\r\n            d = dot(domain.planes[i].base-x,domain.planes[i].normal)\r\n            if d<dist\r\n                k=i\r\n            end\r\n        end\r\n        return domain.planes[k].normal\r\n    end\r\n    normal = plane_of_x(domain,x)\r\n    return dot(normal,flux(x))\r\nend\r\n\r\n\r\n##########################################################################################\r\n\r\n## Solving -∇⋅(κ∇u) = RHS    on  'domain'\r\n## keep track of signs!!!\r\n\r\n##########################################################################################\r\n\r\n# returns all necessary data to perform a numerical calculation to solve \r\n# -∇⋅(κ∇u) = RHS   using HighVoronoi tools\r\n# calculates RHS := -∇⋅(κ∇u) and if needed Neumann condition\r\n# provides u_exact:=u and κ\r\nfunction make_set(u::Function,κ::Function,dim;periodic=[], \r\n                    dirichlet_boundary=collect(1:(2*dim)), \r\n                    neumann_boundary=nothing, density=nothing, \r\n                    number_of_nodes=1000)\r\n    my_domain = cuboid(dim,periodic=periodic)\r\n    ∇u = ∇(u,dim)\r\n    rhs = ∇cdot(x->-1.0*κ(x)*∇u(x),dim)\r\n    flux(x) = -κ(x)*∇u(x)\r\n    neumann_flux(x) = -κ(x)*∇_buff_u(x) # faster but with internal buffer\r\n    if density!=nothing\r\n        return (u_exact = u,  κ=κ, RHS = rhs, \r\n                domain=my_domain, dim=dim,\r\n                dirichlet_boundary=dirichlet_boundary, \r\n                neumann_boundary=neumann_boundary, \r\n                number_of_nodes = number_of_nodes,\r\n                neumann = x->neumann_bc(flux,my_domain,x))\r\n    else\r\n        return (u_exact = u,  κ=κ, RHS = rhs, \r\n                domain=my_domain, dim=dim,\r\n                density=density,\r\n                dirichlet_boundary=dirichlet_boundary, \r\n                neumann_boundary=neumann_boundary, \r\n                number_of_nodes = number_of_nodes,\r\n                neumann = x->neumann_bc(flux,my_domain,x))\r\n    end\r\nend\r\n\r\n\r\nusing Plots\r\n# plotting the results if dimension is 2\r\nfunction plot_2d_surface(nodes, values)\r\n    # The following two lines are necessary in order for the plot to look nicely\r\n    func = StepFunction(nodes,values)\r\n    new_nodes = vcat([VoronoiNode([k/10,j*1.0]) for k in 0:10, j in 0:1], [VoronoiNode([j*1.0,k/10]) for k in 1:9, j in 0:1])\r\n    append!(nodes,new_nodes)\r\n    append!(values,[func(n) for n in new_nodes])\r\n    \r\n    x = [node[1] for node in nodes]\r\n    y = [node[2] for node in nodes]\r\n    \r\n    p = Plots.surface(x, y, values, legend=false)\r\n    xlabel!(\"X\")\r\n    ylabel!(\"Y\")\r\n    zlabel!(\"Values\")\r\n    title!(\"2D Surface Graph\")\r\n    \r\n    display(p)\r\nend\r\n\r\n\r\n# Flux function passed as a parameter to HighVoronoi\r\nfunction SQRA_flux(;para_i,para_j,mass_ij,normal,kwargs...) \r\n    # kwargs... collects all additional parameters which are not used in the current function.\r\n    weight = norm(normal)^(-1) * mass_ij * sqrt(para_i[:κ]*para_j[:κ])\r\n    return weight, weight\r\nend\r\n\r\n# RHS passed to HighVoronoi\r\nmyRHS(;para_i,mass_i,kwargs...) = mass_i * para_i[:f] \r\n\r\n# performs numerical calculations to solve -∇⋅(κ∇u) = RHS\r\nfunction simulation(set)\r\n    # adjust RHS for periodic domain \r\n    new_RHS = HighVoronoi.PeriodicFunction(set.RHS,set.domain)\r\n    set = (neumann = x->0.0, set..., RHS=new_RHS)\r\n    # get nodes\r\n    nodes = nothing\r\n    if isdefined(set,:density)\r\n        nodes = VoronoiNodes( set.number_of_nodes;density=set.density, \r\n                    domain=cuboid(set.dim,periodic=[]), silence=false)\r\n    else\r\n        nodes = VoronoiNodes(rand(set.dim,set.number_of_nodes))\r\n    end\r\n    # Voronoi Geometry and integration. We could also set up VG_κ directly...\r\n    VG_basis = VoronoiGeometry(nodes,set.domain,integrator=HighVoronoi.VI_GEOMETRY)\r\n    VG_κ = VoronoiGeometry(VG_basis, integrator=HighVoronoi.VI_POLYGON, integrand=x->[set.κ(x),set.RHS(x)])\r\n    vd = VoronoiData(VG_κ) # needed for volumes in the final calculations\r\n    # set up fluxes and RHS\r\n    vfvp = VoronoiFVProblem(VG_κ,  \r\n                              integralfunctions = (κ = set.κ, f = set.RHS, ), \r\n                              fluxes = ( j1 = SQRA_flux, ),\r\n                              rhs_functions = (F = myRHS,) )\r\n    # define functions that can be applied as boundary conditions\r\n    harmonic = FVevaluate_boundary(x->0.0) # turn a function into the format HighVoronoi needs\r\n    compatibility = FVevaluate_boundary(x->set.u_exact(x))\r\n    neumann = FVevaluate_boundary(x->set.neumann(x))\r\n    # construct linear system from fluxes, RHS and boundary conditions\r\n    r,c,v,f = linearVoronoiFVProblem(vfvp, flux = :j1, rhs = :F, \r\n            Dirichlet = set.dirichlet_boundary!=nothing ? (set.dirichlet_boundary,compatibility) : nothing, \r\n            Neumann = set.neumann_boundary!=nothing ? (set.neumann_boundary,neumann) : nothing)\r\n    A = sparse(r,c,v) # a sparse matrix with rows `r`, coloumns `c` and values `v`\r\n    # solve linear system using IterativeSolvers-Package\r\n    solution_u = cg(A,f) # conjugate gradients\r\n    # print out approximate L²-error between exact and numerical solutions \r\n    println(\"Approximate L²-error: \",sqrt(sum(map(k->abs2(solution_u[k]-set.u_exact(nodes[k]))*vd.volume[k],1:length(nodes)))))\r\n    return nodes, solution_u  # return nodes and values for plotting...\r\nend\r\n\r\n\r\n###################################################################################\r\n\r\n## Putting together the above pieces\r\n\r\n###################################################################################\r\n\r\n# create parameters\r\nmy_set = make_set(x->sin(x[1]*2*π)^2 * sin(x[2]*2*π)^2, x->1.0, 2, \r\n                periodic=[1], dirichlet_boundary=3, neumann_boundary=4)\r\n                # reminder: periodic=[1] identifies boundary 1 with boundary 2\r\n# perform simulation\r\nnodes, values = simulation(my_set)\r\n# plot results\r\nmy_set.dim==2 && plot_2d_surface(nodes, values)\r\n","category":"page"},{"location":"man/periodic/#periodicgeometrysection","page":"Highspeed periodic geometries","title":"Highspeed periodic geometries","text":"","category":"section"},{"location":"man/periodic/","page":"Highspeed periodic geometries","title":"Highspeed periodic geometries","text":"A fast and efficient way to generate meshes in high dimension are quasi-periodic meshes. That is:","category":"page"},{"location":"man/periodic/","page":"Highspeed periodic geometries","title":"Highspeed periodic geometries","text":"Take N points (x_j)_jin1dotsN within a unit cube 01^dim\nfor i=1dotsdim and natural numbers (n_i)_iin1dotsdim make prod_i n_i \"shifted\" copies of (x_j)_jin1dotsN, which yields a periodic set of points with n_i repetitions of (x_j)_jin1dotsN in direction i.\ncalculated mesh geometry and interfaces areas and volumes with the Polygon-Method\nif desired: calculate the integral  of given functions using the Heuristic method","category":"page"},{"location":"man/periodic/","page":"Highspeed periodic geometries","title":"Highspeed periodic geometries","text":"This is automatised in the following call:","category":"page"},{"location":"man/periodic/","page":"Highspeed periodic geometries","title":"Highspeed periodic geometries","text":"    dim = 3 \r\n    VG = HighVoronoi.VoronoiGeometry( VoronoiNodes(rand(dim,N)), \r\n        periodic_grid = ( dimensions=ones(Float64,dim), \r\n            scale=0.25*ones(Float64,dim), repeat=4*ones(Int64,dim), \r\n            periodic=[], fast=true ) )","category":"page"},{"location":"man/periodic/","page":"Highspeed periodic geometries","title":"Highspeed periodic geometries","text":"Here, VoronoiNodes(rand(dim,N)) corresponds to the above X=(x_j)_jin1dotsN.","category":"page"},{"location":"man/periodic/","page":"Highspeed periodic geometries","title":"Highspeed periodic geometries","text":"A new feature is the field periodic_grid as a keyword that signals to HighVoronoi.jl what we intend to do. periodic_grid is a NamedTuple which can take the following fields:","category":"page"},{"location":"man/periodic/","page":"Highspeed periodic geometries","title":"Highspeed periodic geometries","text":"dimensions: The box that contains the data X. Its default is ones(Float64,dim).\nscale: a diagonal matrix to scale (x_j)_jin1dotsN before repeating. Its default is ones(Float64,dim).\nrepeat: corresponds to (n_i)_iin1dotsdim, i.e. tells how often the data shall be repeated in each dimension. Its default is 2*ones(Int64,dim).\nfast: true uses internal copy-and-paste algorithms to speed up the calculation significantly in high dimensions. Integration of functions  falls back to Heuristic. false uses classical computations. Integration of functions using Polygon and MonteCarlo is then possible. Default: true. Note that fast=true will disable multithreading. It will have to be reactivated in subsequent calls of refine!(...).","category":"page"},{"location":"man/periodic/","page":"Highspeed periodic geometries","title":"Highspeed periodic geometries","text":"The resulting domain will be a cuboid(dim,periodic=periodic,dimensions=(scale.*dimensions.*repeat)) of dimensions: scale.*dimensions.*repeat. The second un-named argument usually indicating the domain becomes meaningless. ","category":"page"},{"location":"man/periodic/","page":"Highspeed periodic geometries","title":"Highspeed periodic geometries","text":"In view of this fact, periodic boundary conditions on the resulting domain are implemented using:","category":"page"},{"location":"man/periodic/","page":"Highspeed periodic geometries","title":"Highspeed periodic geometries","text":"periodic: Tells which dimensions shall have periodic boundary conditions. Default: []","category":"page"},{"location":"man/periodic/#Intention-of-use","page":"Highspeed periodic geometries","title":"Intention of use","text":"","category":"section"},{"location":"man/periodic/","page":"Highspeed periodic geometries","title":"Highspeed periodic geometries","text":"note: Intentions of use\nUsing this feature makes sense only if either n_i1 for some i OR if periodic != []. In particular, periodic=[i] internaly increases n_i by 2.","category":"page"},{"location":"man/periodic/#Gain-in-performance-compared-to-non-periodic-grid","page":"Highspeed periodic geometries","title":"Gain in performance compared to non-periodic grid","text":"","category":"section"},{"location":"man/periodic/","page":"Highspeed periodic geometries","title":"Highspeed periodic geometries","text":"As mentioned above, the algorithm automatically tracks data that can be \"copy-pasted\" and as such can increase performance for (n_i)_i = (22dots2). However, lets assume for simplicitiy that the first k dimensions have n_i3 (actual order of n_i does not matter to the implemented algorithm). We partition the full domain into cubes indexed by (m_i)_iinmathbb N with 1leq m_ileq n_i. One can observe that n_im_igeq3 for ileq k implies that the volume and area data as well as all verteces of cell (m_i)_i can be obtained as a copy of the respective data from cell (m_1dotsm_i-1m_i-1m_i+1dots m_N).      ","category":"page"},{"location":"man/periodic/","page":"Highspeed periodic geometries","title":"Highspeed periodic geometries","text":"The percentage of small cubes that can be copied from previous existing cubes can then be calculated as ","category":"page"},{"location":"man/periodic/","page":"Highspeed periodic geometries","title":"Highspeed periodic geometries","text":"P_0=0qquad P_k = P_k-1*frac3n_k+fracn_k-3n_k","category":"page"},{"location":"man/periodic/","page":"Highspeed periodic geometries","title":"Highspeed periodic geometries","text":"The value P_dim can be calculated using non-exported method HighVoronoi.redundancy, e.g.","category":"page"},{"location":"man/periodic/","page":"Highspeed periodic geometries","title":"Highspeed periodic geometries","text":"HighVoronoi.redundancy([3,5,2,6,8]) # returns 0.8875","category":"page"},{"location":"man/periodic/","page":"Highspeed periodic geometries","title":"Highspeed periodic geometries","text":"note: Example\nAssume repeat = 4*ones(Int64,dim) then the percentage of copied data increases according to:beginarrayrcccc\r\nmathrmdim  2             3  4  5  6  dots  infty\r\n            frac716  frac1732  frac3764  frac177256  frac357512  dots  1\r\nendarrayHowever, since other cells can be partically recycled, numerical experiments show even higher gain in performance.","category":"page"},{"location":"man/periodic/#Memory-usage","page":"Highspeed periodic geometries","title":"Memory usage","text":"","category":"section"},{"location":"man/periodic/","page":"Highspeed periodic geometries","title":"Highspeed periodic geometries","text":"The lower geometric complexity of periodic meshes leads to less memory being used. This can be checked with the command applied to a geometry with nodes in general position and to a periodic geometry with comparable amount of generators.","category":"page"},{"location":"man/periodic/","page":"Highspeed periodic geometries","title":"Highspeed periodic geometries","text":"    size = memory_allocations(vg::VoronoiGeometry;verbose=false)","category":"page"},{"location":"man/periodic/","page":"Highspeed periodic geometries","title":"Highspeed periodic geometries","text":"which returns the memory allocated by vg in Bytes. verbose=true prints to the shell which internal part of the geometry data structure occupies how much memory. ","category":"page"},{"location":"man/periodic/#Advantage-for-numerics-and-some-statistics","page":"Highspeed periodic geometries","title":"Advantage for numerics and some statistics","text":"","category":"section"},{"location":"man/periodic/","page":"Highspeed periodic geometries","title":"Highspeed periodic geometries","text":"Another advantage of periodic meshes with a low number of generating nodes is the following: In a cubic grid every node has 2d neighbors, while in a regular grid the number of neighbors grows super-linear. E.g. in 5 dimensions, tests suggest around 90pm 10 neighbors compared to 10 neighbors in a cubic grid. At the same time, a periodic grid generated from 3 points shows an average neighboring of 20. Thus, matrices generated in this way will be much sparser than matrices for regular grids.","category":"page"},{"location":"man/periodic/","page":"Highspeed periodic geometries","title":"Highspeed periodic geometries","text":"The user can play around a bit with ","category":"page"},{"location":"man/periodic/","page":"Highspeed periodic geometries","title":"Highspeed periodic geometries","text":"HighVoronoi.VoronoiStatistics(dim,samples;periodic=nothing,points=1,my_generator=nothing,geodata=true)","category":"page"},{"location":"man/periodic/","page":"Highspeed periodic geometries","title":"Highspeed periodic geometries","text":"dim::Int: The dimension\nsamples::Int: How many samples shall be considered\nperiodic: If periodic is an integer, it will calculate the statistics for periodic meshes from periodic nodes. Otherwise, it will calculate the statistics for the point closest to the center of a cube, where the cube is filled with points random points. \nmy_generator: if this is a function my_generator(dim,points) which returns some xs::VoronoiNodes, number::Int the algorithm will do the Voronoi statistics for the first number points of xs.\ngeodata: if true calculates volumes and areas. costly in high dimensions.","category":"page"},{"location":"man/periodic/","page":"Highspeed periodic geometries","title":"Highspeed periodic geometries","text":"The VoronoiStatistics returns a named tuple with the following entries:","category":"page"},{"location":"man/periodic/","page":"Highspeed periodic geometries","title":"Highspeed periodic geometries","text":"data_size: Number of sample nodes calculated\nvolume=(V,_v): Average volume V of a cell with standard deviation _v\nverteces=(V,_v): Average number of verteces V of a cell with standard deviation _v\nneighbors=(N,_n): Average number of neighbors N of a cell with standard deviation _n\narea=(A,_a): Average area  A of an interface  with standard deviation _a","category":"page"},{"location":"man/periodic/#Cubic-grids:-Ultra-high-speed-mesh-generation","page":"Highspeed periodic geometries","title":"Cubic grids: Ultra high speed mesh generation","text":"","category":"section"},{"location":"man/periodic/","page":"Highspeed periodic geometries","title":"Highspeed periodic geometries","text":"When the call of VoronoiGeometry looks like the following:","category":"page"},{"location":"man/periodic/","page":"Highspeed periodic geometries","title":"Highspeed periodic geometries","text":"    VG = HighVoronoi.VoronoiGeometry( VoronoiNodes(rand(dim,1)), \r\n        periodic_grid = ( periodic=[], dimensions=ones(Float64,dim), \r\n            scale=0.25*ones(Float64,dim), repeat=4*ones(Int64,dim), \r\n            periodic=[], fast=true ) )","category":"page"},{"location":"man/periodic/","page":"Highspeed periodic geometries","title":"Highspeed periodic geometries","text":"i.e. if only one single node is passed, the resulting grid will be cubic. This apriori knowledge is used by a specialized  internal fast computation algorithm.","category":"page"},{"location":"man/periodic/","page":"Highspeed periodic geometries","title":"Highspeed periodic geometries","text":"hint: Fast generation of complex grids\nThe generation of coarse grids with local refinements in large dimensions can be achieved by calculating one coarse and one fine cubic grid and using substitute ","category":"page"},{"location":"man/boundaries/#allonboundaries","page":"Boundaries","title":"Boundaries","text":"","category":"section"},{"location":"man/boundaries/#The-Boundary-struct","page":"Boundaries","title":"The Boundary struct","text":"","category":"section"},{"location":"man/boundaries/","page":"Boundaries","title":"Boundaries","text":"In what follows we describe how boundaries are implemented in the calculation of Voronoi meshes. Handling boundaries within HighVoronoi is done using the following struct.","category":"page"},{"location":"man/boundaries/","page":"Boundaries","title":"Boundaries","text":"Boundary","category":"page"},{"location":"man/boundaries/#HighVoronoi.Boundary","page":"Boundaries","title":"HighVoronoi.Boundary","text":"Boundary\n\nprovides the data structure for boundaries of VoronoiGeometry. Its most important feature is the vector\n\nplanes::Vector{Plane}\n\nwhich stores every flat part of the boundary as\n\nstruct Plane\n    base::Vector{Float64} # base of the plane\n    normal::Vector{Float64} # outer normal of the domain on this plane\n    BC::Int16 # 0 for Dirichlet, -1 for Neumann and >0 for the index of the other correspondant in case this is supposed to be periodic\nend\n\n\n\n\n\n","category":"type"},{"location":"man/boundaries/#createboundary","page":"Boundaries","title":"Creating Boundaries","text":"","category":"section"},{"location":"man/boundaries/","page":"Boundaries","title":"Boundaries","text":"Apart from cuboids, Boundary should always be generated using the following method:","category":"page"},{"location":"man/boundaries/","page":"Boundaries","title":"Boundaries","text":"Boundary(planes...)","category":"page"},{"location":"man/boundaries/#HighVoronoi.Boundary-Tuple","page":"Boundaries","title":"HighVoronoi.Boundary","text":"Boundary(planes...)\n\nis the constructor for Boundaries. planes... is a list of planes generated by either one of the following functions:\n\nBC_Dirichlet(b,n)\nBC_Neumann(b,n)\n\ngenerating Dirichlet resp. Neumann boundaries with base b and normal n.\n\nBC_Periodic(base1,base2,normal1)\n\ngenerating two periodic boundaries with base1 and normal1  resp. with base2 and normal = -normal1 \n\n\n\n\n\n","category":"method"},{"location":"man/boundaries/#rectangulardomains","page":"Boundaries","title":"Rectangular domains","text":"","category":"section"},{"location":"man/boundaries/","page":"Boundaries","title":"Boundaries","text":"For simplicity of application, the following methods are provided for boundaries of rectangular domains. They return an object of type b::Boundary with the following structure:","category":"page"},{"location":"man/boundaries/","page":"Boundaries","title":"Boundaries","text":"For every iin 1mathrmdim ","category":"page"},{"location":"man/boundaries/","page":"Boundaries","title":"Boundaries","text":"the plane b.plane[2*i-1] has base mathrmoffseti+e_i*mathrmdimensionsi and normal e_i\nthe plane b.plane[2*i] has base mathrmoffseti and normal -e_i","category":"page"},{"location":"man/boundaries/","page":"Boundaries","title":"Boundaries","text":"cuboid(dim;dimensions=ones(Float64,dim),periodic=collect(1:dim),neumann=Int64[],offset=zeros(Float64,dim))","category":"page"},{"location":"man/boundaries/#HighVoronoi.cuboid-Tuple{Any}","page":"Boundaries","title":"HighVoronoi.cuboid","text":"cuboid(dim;dimensions=ones(Float64,dim),periodic=collect(1:dim),neumann=Int64[],offset=zeros(Float64,dim))\n\nor simply cuboid(dim) generates a cube of type Boundary. \n\ndim : This is the dimension of the cuboid\ndimensions : provides the size of the cuboid in each dimension\nperiodic : this is a (sorted!!) list of dimensions in which the cube is assumed to have periodic boundary conditions\nneumann : every dimension k=1...dim which is not periodic my be put here with positive sign for the right hand side or negative sign (i.e. -k) for the left hand side\noffset : shifts the cube in space  \n\nA particular application is the following method provided by HighVoronoi.\n\ncenter_cube(dim,size) = cuboid(dim,dimensions=size*ones(Float64,dim),offset=-0.5*size*ones(Float64,dim))\n\nRelying on cuboid(...) it generates a cube with center 0 and edge length size.\n\n\n\n\n\n","category":"method"},{"location":"man/boundaries/#Warnings","page":"Boundaries","title":"Warnings","text":"","category":"section"},{"location":"man/boundaries/","page":"Boundaries","title":"Boundaries","text":"warning: Using no boundaries in high dimensions\nwhen using no boundary planes the result \"at infinity\" i.e. for farout vertex points can be corrupted for high dimensions. This is because virtually every boundary point (a point with infinite cell) becomes neighbor with almost all other boundary points and the verteces reach out to very very very large coordinates compared to the original nodes coordinates. The Library provides internal algorithms to identify and correct misscalculations but this functionallity is, however, limited to the precission of Float64. We advise to implement a farout boundary (e.g. 1.0E6) compared to a cube of diameter 1.","category":"page"},{"location":"man/boundaries/#Some-more-tools","page":"Boundaries","title":"Some more tools","text":"","category":"section"},{"location":"man/raycast/#Voronoi:-Raycast-methods","page":"Voronoi: Raycast methods","title":"Voronoi: Raycast methods","text":"","category":"section"},{"location":"man/raycast/","page":"Voronoi: Raycast methods","title":"Voronoi: Raycast methods","text":"During the develop of HighVoronoi.jl I developed several Raycast-methods. These methods are central to the Voronoi algorithm.","category":"page"},{"location":"man/raycast/","page":"Voronoi: Raycast methods","title":"Voronoi: Raycast methods","text":"!!! Choice of Raycast Method may be crucial for performance or overall success!     The classical Raycast method method=RCOriginal e.g. is only for generators in general position, but is very good for the far field computation on unbounded domains. On the other hand, as soon as you have a bounded domain, method=RCCombined might be very fast compared to all other methods, while it gets very very slow on unbounded domains in high dimensions. It's a classical tradeof.","category":"page"},{"location":"man/raycast/#classicraycast","page":"Voronoi: Raycast methods","title":"Classical Method","text":"","category":"section"},{"location":"man/raycast/","page":"Voronoi: Raycast methods","title":"Voronoi: Raycast methods","text":"This is the most classical method introduced in PREPRINT. It basically works only on generators in general position (when a vertex is created by exactly d+1 generators) and can be called using method=RCOriginal in the search_settings.","category":"page"},{"location":"man/raycast/#boostedraycast","page":"Voronoi: Raycast methods","title":"Statistically Boosted Method","text":"","category":"section"},{"location":"man/raycast/","page":"Voronoi: Raycast methods","title":"Voronoi: Raycast methods","text":"This method is called with method=RCNonGeneral and speeds up the classical method in the following way: It performs two classical steps as in PREPRINT and then performs an inrange search and finally sorts out all non-generators. This provides a significant boost when the generators are in non-general position (more than d+1 generators for one vertex)","category":"page"},{"location":"man/raycast/#nestedraycast","page":"Voronoi: Raycast methods","title":"Nested Method","text":"","category":"section"},{"location":"man/raycast/","page":"Voronoi: Raycast methods","title":"Voronoi: Raycast methods","text":"This method is called with method=RCCombined and performs a deep hacking of the nearest-neighbor search, i.e. it made it necessary to include a modified version of NearestNeighbors.jl into the source code of HighVoronoi.jl. The result is a nearest neighbor search that basically converges the raycast method within one single search. It is very fast on bounded and periodic domains but may take much longer on unbounded domains at the periphery of the point set.","category":"page"},{"location":"man/raycast/#Suggested-usage","page":"Voronoi: Raycast methods","title":"Suggested usage","text":"","category":"section"},{"location":"man/raycast/","page":"Voronoi: Raycast methods","title":"Voronoi: Raycast methods","text":"It is highly recommended to use method=RCCombined (the standard setting) and switch to method=RCNonGeneral in pathological situation respectively method=RCNonGeneral only if the generators are \"nicely\" distributed.","category":"page"},{"location":"man/sphere/#voronoisphere","page":"Voronoi diagrams on spheres","title":"Voronoi diagrams on spheres","text":"","category":"section"},{"location":"man/sphere/#Simple-example-and-explanation","page":"Voronoi diagrams on spheres","title":"Simple example and explanation","text":"","category":"section"},{"location":"man/sphere/","page":"Voronoi diagrams on spheres","title":"Voronoi diagrams on spheres","text":"You can generate a partition of the full sphere as follows:","category":"page"},{"location":"man/sphere/","page":"Voronoi diagrams on spheres","title":"Voronoi diagrams on spheres","text":"A=randn(3,400)\r\nfor k in 1:400\r\n    A[:,k] .= normalize(A[:,k])\r\nend\r\nvs = VoronoiSphere(VoronoiNodes(A), integrate=true, integrator=VI_FAST_POLYGON)\r\nvd = VoronoiData(vs)\r\nprintln(sum(vd.volume))","category":"page"},{"location":"man/sphere/","page":"Voronoi diagrams on spheres","title":"Voronoi diagrams on spheres","text":"In the above example, the output should be close to 4pi, but will be lower by a systemic error (see following comments for a fix).","category":"page"},{"location":"man/sphere/","page":"Voronoi diagrams on spheres","title":"Voronoi diagrams on spheres","text":"Some comments:","category":"page"},{"location":"man/sphere/","page":"Voronoi diagrams on spheres","title":"Voronoi diagrams on spheres","text":"VI_MONTECARLO may not be very accurate. You either need a high number of rays or you may be better of with VI_FAST_POLYGON and alike\nVoronoiSphere supports all commands of VoronoiGeometry except for the following: periodic_grid, improving\nVoronoiSphere comes with the additional commands:\ntotal_area: provide a Float64 if you know the total area. This is helpful as it will correct the surface integral of functions according to a scaling factor that arises from computed area vs. provided total_area.\ntransformations: provide a list of maps that will copy the given nodes and identify the copies with the originals at the stage of VoronoiData computation. Application: In 4 dimensions, the upper half of the mathbbS^3 with \"periodic boundary conditions\" is equivalent to the SO(3). See the following example.\ncenter: if you know the center of the sphere, you can provide it. Otherwise, HighVoronoi will try to figure out the center from the data.\nsystematic_error=0.0001: This parameter adjusts an unavoidable error at the interface integrals. a value of 0.0001 means a systematic error of 0.01%. If you set it to zero, it will crash.","category":"page"},{"location":"man/sphere/#Advanced-examples","page":"Voronoi diagrams on spheres","title":"Advanced examples","text":"","category":"section"},{"location":"man/sphere/","page":"Voronoi diagrams on spheres","title":"Voronoi diagrams on spheres","text":"The area of the upper half of the sphere using periodic boundary conditions:","category":"page"},{"location":"man/sphere/","page":"Voronoi diagrams on spheres","title":"Voronoi diagrams on spheres","text":"\r\n    A=randn(3,400)\r\n    for k in 1:400\r\n        A[:,k] .= normalize(A[:,k])\r\n        if A[1,k] < 0.0\r\n            A[1,k] = -A[1,k]\r\n        end\r\n    end\r\n    vs = VoronoiSphere(VoronoiNodes(A),transformations=(x->-x,), integrate=true, integrator=VI_FAST_POLYGON)\r\n    vd = VoronoiData(vs)\r\n    println(sum(vd.volume))\r\n","category":"page"},{"location":"man/sphere/","page":"Voronoi diagrams on spheres","title":"Voronoi diagrams on spheres","text":"The area of the upper half of the sphere using a mirror of the original points. In this case, if cell 1 has neighbor 1 ( use vd.neighbors[1] ), this segment will be part of the 2-dimensional boundary of the upper hull.","category":"page"},{"location":"man/sphere/","page":"Voronoi diagrams on spheres","title":"Voronoi diagrams on spheres","text":"    using LinearAlgebra\r\n\r\n    A = randn(3,400)\r\n    for k in 1:400\r\n        A[:,k] .= normalize(A[:,k])\r\n        if A[1,k] < 0.0\r\n            A[1,k] = -A[1,k]\r\n        end\r\n    end\r\n\r\n    function mirror(x)\r\n        return diagm( [-1.0, 1.0, 1.0] ) * x\r\n    end\r\n\r\n    vs = VoronoiSphere(VoronoiNodes(A),transformations=(x->mirror(x),), integrate=true, integrator=VI_FAST_POLYGON)\r\n    vd = VoronoiData(vs)\r\n    println(sum(vd.volume))\r\n","category":"page"},{"location":"showcase/#intentions","page":"Intentions of use (EXAMPLES)","title":"Using the HighVoronoi Library","text":"","category":"section"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"We collect some examples how the package is meant to be applied.","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"tip: SKIP ''Mesh generation'' and study the ''Finite Volume methods'' section first\nIf you are interested in Finite Volume methods but you do not want to go to much into details on mesh generation, you may skipt this first part. However, for setting up several different problems on large dimensions, recycling mesh data and using mesh refinement techniques, it is strongly advised to study the capabilities of the VoronoiGeometry data structure in a second approach.","category":"page"},{"location":"showcase/#Mesh-generation-and-integration","page":"Intentions of use (EXAMPLES)","title":"Mesh generation and integration","text":"","category":"section"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"Mesh generation in form of a VoronoiGeometry relies on the following data: A set of points (VoronoiNodes), a boundary (Boundary, cuboid), the choice of an integrator method and the optional choice of a function to be integrated (integrand = x->...). Points and boundaries can also be retrieved from a formerly calculated VoronoiGeometry.","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"The intentions how this is done are demonstrated in the following examples:","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"Example 1: Basics\nExample 2: Integration on fully periodic grid\nExample 3: Non-periodic bounded domain with data storage\nExample 4: Load and integrate new function\nExample 5: Copy and integrate new function\nExample 6: Mesh-Refinement\nExample 7: Mesh-Refinement with locally new integrand","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"Future extensions imply the fast, efficient generation of large quasi-periodic meshes in high dimensions. These meshes shall then be locally refined according to the user's needs. ","category":"page"},{"location":"showcase/#Mgi1","page":"Intentions of use (EXAMPLES)","title":"Example 1: Basics","text":"","category":"section"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"Generate a 3D mesh of 100 Points with no boundary. Calculates only verteces and neighbors.","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"xs = VoronoiNodes( rand(3,100) )\r\nvg = VoronoiGeometry(xs, integrator=HighVoronoi.VI_GEOMETRY)\r\nvd = VoronoiData(vg, getverteces=true)   \r\n# vd.neighbors contains for each node `i` a list of all neighbors\r\n# vd.verteces contains for each node `i` a list of all verteces that define the cell.","category":"page"},{"location":"showcase/#Mgi2","page":"Intentions of use (EXAMPLES)","title":"Example 2: Integration on fully periodic grid","text":"","category":"section"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"Generate a 5D mesh of 1000 points with periodic boundary conditions on a unit cube (01)^5. It then uses triangulation integration to integrate the function","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"xmapstoleft(beginarraycx  x_1x_2endarrayright)","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"For general polygon domains see here. ","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"xs2 = VoronoiNodes( rand(5,1000) )\r\nvg2 = VoronoiGeometry(xs2, cuboid(5), integrator=HighVoronoi.VI_POLYGON, integrand = x->[norm(x),x[1]*x[2]])\r\nvd2 = VoronoiData(vg2)    ","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"vd2.volume[i] and vd2.bulk_integral[i] contain the volume of cell i and the integral of integrand over cell i\nvd2.neighbors[i] contains an array of all neighbors of i. \nfor each j the field vd2.area[i][j] contains the interface area between i and vd2.neighbors[i][j].\nfor each j the field vd2.interface_integral[i][j] contains the integral of integrand over    the interface area between i and vd2.neighbors[i][j].","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"note: \nIf jnot=k but vd2.neighbors[i][j]==vd2.neighbors[i][k]  this means that i shares two differnt interfaces with n=vd2.neighbors[i][j].  This happens due to periodicity and low number of nodes in relation to the dimension.","category":"page"},{"location":"showcase/#Mgi3","page":"Intentions of use (EXAMPLES)","title":"Example 3: Non-periodic bounded domain with data storage","text":"","category":"section"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"Like Example 2 but we store and load the data:","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"xs3 = VoronoiNodes( rand(5,1000) )\r\nvg3 = VoronoiGeometry(xs3, cuboid(5,periodic=[2]), integrator=HighVoronoi.VI_POLYGON, integrand = x->[norm(x),x[1]*x[2]])\r\nwrite_jld(vg3, \"my5Dexample.jld\")\r\nvg3_reload_vol = VoronoiGeometry(\"my5Dexample.jld\")","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"The mesh vg3 is periodic only in direction of e_2=(01000). The variable vg3_reload_vol now contains a copy of nodes, verteces, volumes and areas in vg3. It contains NOT the integral values.","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"vg3_a = VoronoiGeometry(\"my5Dexample.jld\", bulk=true, interface=true)","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"The variable vg3_a contains also the integrated values. However, the method will prompt a warning because no integrand is provided. Hence try the following:","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"vg3_modified = VoronoiGeometry(\"my5Dexample.jld\", bulk=true, interface=true, integrand = x->[x[5],sqrt(abs(x[3]))])\r\nvg3_full = VoronoiGeometry(\"my5Dexample.jld\", bulk=true, interface=true, integrand = x->[norm(x),x[1]*x[2]])","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"warning: \nThe method VoronoiGeometry(filename) DOES compare the dimensions of the integrand with the stored data. However, it DOES NOT compare wether the original and the newly provided function are the same.","category":"page"},{"location":"showcase/#Mgi4","page":"Intentions of use (EXAMPLES)","title":"Example 4: Load and integrate new function","text":"","category":"section"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"We can also recycle efficiently the stored geometry by using its volumes and interfaces and integrate another function using the VI_HEURISTIC integrator.","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"vg4 = VoronoiGeometry(\"my5Dexample.jld\", integrand = x->[x[1]*x[5],sqrt(abs(x[3])),sum(abs2,x)],integrator=HighVoronoi.VI_HEURISTIC)","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"This will cause a warning stating that the new integrator VI_HEURISTIC does not match the original integrator. Just ignore it. You can also use VI_POLYGON or VI_MONTECARLO but this will take much more time for the integration.","category":"page"},{"location":"showcase/#Mgi5","page":"Intentions of use (EXAMPLES)","title":"Example 5: Copy and integrate new function","text":"","category":"section"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"Similar to the last example, we may also directly copy vg3","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"vg5 = VoronoiGeometry(vg3, integrator=HighVoronoi.VI_HEURISTIC, integrand = x->[sum(abs2,x)])","category":"page"},{"location":"showcase/#Mgi6","page":"Intentions of use (EXAMPLES)","title":"Example 6: Mesh-Refinement","text":"","category":"section"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"Say the user has created or loaded a VoronoiGeometry and wants to add some more points. In our case, we create a partially periodic mesh in 3D with 1000 points in (01)^3 and afterwards add 100 Points in (001)^3 for higher resolution in this region.","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"vg6 = VoronoiGeometry( VoronoiNodes(rand(3,1000)), cuboid(3,periodic=[2]), \r\n                      integrand=x->[sum(abs,x)], integrator=HighVoronoi.VI_POLYGON)\r\nrefine!(vg6, VoronoiNodes(0.1.*rand(3,100)))                      ","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"If, for whatever reason, the user does not want the algorithm to update the volumes, areas, integrals, ... he may add the command update=false.","category":"page"},{"location":"showcase/#Mgi7","page":"Intentions of use (EXAMPLES)","title":"Example 7: Mesh-Refinement with locally new integrand","text":"","category":"section"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"We modify Example 6:","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"vg7 = VoronoiGeometry( VoronoiNodes(rand(3,1000)), cuboid(3,periodic=[2]), \r\n                      integrand=x->[sum(abs,x)], integrator=HighVoronoi.VI_POLYGON)\r\nvg7b = VoronoiGeometry( vg7, bulk=true, interface=true, integrand=x->[sqrt(sum(abs2,x))])\r\nrefine!(vg7b, VoronoiNodes(0.1.*rand(3,100)))                      ","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"Because bulk=true and interface=true, vg7b simply copies all data from vg7, including the integrated values of f(x)=[sum(abs,x)]. However, when the refine! function is called, the local integral on every modified interface and cell will be recalculated using the new function  f2(x)=[sqrt(sum(abs2,x))]. This means in the new cell we completly have integrated values of f2 while on old and non-modified  cells we still have integrated values of f. On cells that have been partially modified, the new integral is an interpolation between the old and the new function.","category":"page"},{"location":"showcase/#Finite-Volume-problems:-Generating-the-matrix-and-the-right-hand-side-from-data","page":"Intentions of use (EXAMPLES)","title":"Finite Volume problems: Generating the matrix and the right hand side from data","text":"","category":"section"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"The most simple way to implement a Finite Volume discretization within HighVoronoi is to provide","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"a list of nodes\na domain\na list of parameter functions to evaluated pointwise or in an averaged sense\na description of the flux in terms of the Voronoi mesh and the pointwise/averaged data\na description of right hand side in terms of the Voronoi mesh and the pointwise/averaged data\na description of the boundary conditions (note that periodic boundary conditions are in fact implemented as a part of the MESH and cannot be modified at this stage)","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"We provide the following two examples covering both intentions of use","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"Example 1: Most simple way from scratch\nExample 2: Relying on preexisting VoronoiGeometry","category":"page"},{"location":"showcase/#FVex1","page":"Intentions of use (EXAMPLES)","title":"Example 1: Most simple way from scratch","text":"","category":"section"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"We create #nop points within (01)^3 and prescribe (01)^3 as our domain for the mesh generation. We define functions kappa(x)=1+x^2 and f(x)=sin(2*pi*x_1). Then we make use of VoronoiFVProblem to set up the discrete equation","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"forall i qquad sum_jsim ip_iju_i-p_jiu_j=F_i","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"where","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"left(p_ijp_jiright)=mathrmmyflux=left(frac1x_i-x_jm_ij*sqrtkappa_ikappa_jfrac1x_i-x_jm_ij*sqrtkappa_ikappa_jright)qquad F_i=m_i*f(x_i)","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"This is a discretization of","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"-nablacdot(kappanabla u)=fqquadmathrmon(01)^3","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"As boundary conditions we implement for J=-kappanabla u and outer normal nu:","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"beginalign*\r\n1  u(x)  =sin(pi x_2)sin(pi x_3)  quadtexton   01times(01)^2\r\n2  u(x)  =0  quadtexton   (01)times01times(01)\r\n3  jcdotnu  =1  quadtexton   (01)^2times01\r\nendalign*","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"Accodring to the internal structure of the cube, BC 1. corresponds to the surface planes [1,2], BC 2. corresponds to the surface planes [3,4] and BC 3. correpsonds to the surface planes [5,6]. More information on boundaries is given here. ","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"using LinearAlgebra\r\nusing SpecialFunctions\r\nusing SparseArrays\r\n\r\nfunction myflux(;para_i,para_j,mass_ij,normal,kwargs...) \r\n    # kwargs... collects all additional parameters which are not used in the current function.\r\n    weight = norm(normal)^(-1) * mass_ij * sqrt(para_i[:kappa]*para_j[:kappa])\r\n    return weight, weight\r\nend\r\n\r\nmyRHS(;para_i,mass_i,kwargs...) = mass_i * para_i[:f] \r\n\r\n\r\nfunction test_FV_3D(nop)\r\n    vfvp = VoronoiFVProblem( VoronoiNodes( rand(3,nop) ), cuboid(3,periodic=[]), \r\n                                discretefunctions = (f=x->sin(2*pi*x[1]),), # evaluate f pointwise\r\n                                integralfunctions = (kappa=x->1.0+norm(x)^2,), # calculate averages of kappa over cells and interfaces\r\n                                fluxes = ( j1 = myflux, ),\r\n                                rhs_functions = (F = myRHS,) )\r\n    # turn functions that depend on x into the required HighVoronoi-format:\r\n    homogeneous = FVevaluate_boundary(x->0.0)\r\n    one = FVevaluate_boundary(x->1.0)\r\n    non_hom = FVevaluate_boundary(x->sin(pi*x[2])*sin(pi*x[3]))\r\n\r\n    r,c,v,f = linearVoronoiFVProblem(   vfvp, flux = :j1, rhs = :F, \r\n                                    Neumann = ([5,6],one), \r\n                                    Dirichlet = (([3,4],homogeneous), ([1,2],non_hom),), )\r\n    A = sparse(r,c,v) # a sparse matrix with rows `r`, coloumns `c` and values `v`\r\n    # solution_u = somelinearsolver(A,f)\r\n\r\nend\r\n\r\ntest_FV_3D(100)","category":"page"},{"location":"showcase/#FVex2","page":"Intentions of use (EXAMPLES)","title":"Example 2: Relying on preexisting VoronoiGeometry","text":"","category":"section"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"We build a 5D-mesh in the unit cube of 5000 points using VoronoiGeometry and store it for later use. Since we have plenty of time, we do it using the exact VI_POLYGON integrator.","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"write_jld( VoronoiGeometry( VoronoiNodes(rand(5,5000)), cuboid(5,periodic=[]), integrator=HighVoronoi.VI_POLYGON ), \"my5Dmesh.jld\" )","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"Next, we want to use this stored grid to immplement the above example in 5D, adding homogeneous Dirichlet conditions in the remaining dimensions. However, we also want :f to be evaluated in an averaged sence, not pointwise. Since we will need their specification in two places, we fix them once and for all:","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"my_functions = (f=x->sin(2*pi*x[1]), kappa=x->1.0+norm(x)^2,)","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"We need to integrate kappa and f the moment we load the geometry from file. To make sure the integrated data will match the needs of the Finite Volume algorithm, we use FunctionComposer:","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"composed_function = FunctionComposer(reference_argument=zeros(Float64,5), super_type=Float64; my_functions...).functions","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"The definitions of myflux and myRHS are independent from the dimension and can just be taken from above.","category":"page"},{"location":"showcase/","page":"Intentions of use (EXAMPLES)","title":"Intentions of use (EXAMPLES)","text":"function test_FV_5D_from_file()_\r\n    my_functions = (f=x->sin(2*pi*x[1]), kappa=x->1.0+norm(x)^2,)\r\n    composed_function = FunctionComposer(   reference_argument=zeros(Float64,5), \r\n                                            super_type=Float64; my_functions...).functions\r\n\r\n    vg = VoronoiGeometry( \"my5Dmesh.jld\",   integrator = HighVoronoi.VI_HEURISTIC, \r\n                                            integrand = composed_function)\r\n\r\n    vfvp = VoronoiFVProblem( vg, integralfunctions = my_functions, \r\n                                 fluxes = ( j1 = myflux, ),\r\n                                 rhs_functions = (F = myRHS,) )\r\n\r\n    homogeneous = FVevaluate_boundary(x->0.0)\r\n    one = FVevaluate_boundary(x->1.0)\r\n    non_hom = FVevaluate_boundary(x->sin(pi*x[2])*sin(pi*x[3]))\r\n\r\n    r,c,v,f = linearVoronoiFVProblem(   vfvp, flux = :j1, rhs = :F, Neumann = ([5,6],one), \r\n                                Dirichlet = (([3,4,7,8,9,10],homogeneous), ([1,2],non_hom),), )\r\n    A = sparse(r,c,v) # a sparse matrix with rows `r`, coloumns `c` and values `v`\r\n    # solution_u = somelinearsolver(A,f)\r\nend","category":"page"},{"location":"man/multithread/#multithreading","page":"Multithreading","title":"Multithreading","text":"","category":"section"},{"location":"man/multithread/","page":"Multithreading","title":"Multithreading","text":"you can use the following keywords either in threading in the search_settings to occasionally use multi threading in Voronoi computations or you can set it for integrate=..... Note that integrate=true is equivalent to integrate=SingleThread()","category":"page"},{"location":"man/multithread/#Periodic-Meshes","page":"Multithreading","title":"Periodic Meshes","text":"","category":"section"},{"location":"man/multithread/","page":"Multithreading","title":"Multithreading","text":"Mutlithreading is currently not available for fast=true generation of periodic meshes!! ","category":"page"},{"location":"man/multithread/#Automatic-Inference-of-Threads","page":"Multithreading","title":"Automatic Inference of Threads","text":"","category":"section"},{"location":"man/multithread/","page":"Multithreading","title":"Multithreading","text":"threading=AutoThread() in the search_settings will automatically infer the maximal number of availabler threads and correspondingly use MultiThread or SingleThread from below.","category":"page"},{"location":"man/multithread/#Single-Threaded-Computations-(Even-if-Julia-is-started-with-more-threads)","page":"Multithreading","title":"Single Threaded Computations (Even if Julia is started with more threads)","text":"","category":"section"},{"location":"man/multithread/","page":"Multithreading","title":"Multithreading","text":"Single threaded calculations can be enforced with threading=SingleThread() in the search_settings. Even if you start Julia with several threads but want to do a single threaded computation, it is strongly advised to use this option as this will call a specialized version of the code.","category":"page"},{"location":"man/multithread/#Multi-Threaded-Computations","page":"Multithreading","title":"Multi Threaded Computations","text":"","category":"section"},{"location":"man/multithread/","page":"Multithreading","title":"Multithreading","text":"Parallelized compuations can be enforced with threading=MultiThread(a,b) in the search_settings. a and b provide parallelization information on an \"outer\" and an \"inner\" parallelization. While the use of a is save, it is currently not adviced to use b>1. If a>Threads.nthreads() it will be internally reduced to the maximally available number of threads. ","category":"page"},{"location":"man/multithread/","page":"Multithreading","title":"Multithreading","text":"Currently, b is implemented as a parameter, because it is technically doable. However, more tests are needed before it can be said if it is advantageous compared to the sole usage of a.","category":"page"},{"location":"man/metapost/#Graphical-Output-in-2D-and-3D","page":"Graphical Output in 2D and 3D","title":"Graphical Output in 2D and 3D","text":"","category":"section"},{"location":"man/metapost/","page":"Graphical Output in 2D and 3D","title":"Graphical Output in 2D and 3D","text":"Graphical output can be produced using the Plots.jl. This is achieved as follows","category":"page"},{"location":"man/metapost/#draw2D","page":"Graphical Output in 2D and 3D","title":"draw2D","text":"","category":"section"},{"location":"man/metapost/","page":"Graphical Output in 2D and 3D","title":"Graphical Output in 2D and 3D","text":"Example:","category":"page"},{"location":"man/metapost/","page":"Graphical Output in 2D and 3D","title":"Graphical Output in 2D and 3D","text":"    VG = VoronoiGeometry(VoronoiNodes(rand(2,5)),cuboid(2,periodic=[]))\r\n\r\n    HighVoronoi.draw2D(VG)","category":"page"},{"location":"man/metapost/","page":"Graphical Output in 2D and 3D","title":"Graphical Output in 2D and 3D","text":"Optionally, the output can be stored in any format supported by Plots:","category":"page"},{"location":"man/metapost/","page":"Graphical Output in 2D and 3D","title":"Graphical Output in 2D and 3D","text":"    HighVoronoi.draw2D(VG,\"nice_plot.png\")","category":"page"},{"location":"man/metapost/","page":"Graphical Output in 2D and 3D","title":"Graphical Output in 2D and 3D","text":"The package provides the following output functions:","category":"page"},{"location":"man/metapost/","page":"Graphical Output in 2D and 3D","title":"Graphical Output in 2D and 3D","text":"draw2D","category":"page"},{"location":"man/metapost/#HighVoronoi.draw2D","page":"Graphical Output in 2D and 3D","title":"HighVoronoi.draw2D","text":"draw2D(VG::VoronoiGeometry, filename=\"\"; board=PlotBoard(), drawNodes=true, drawVerteces=true, drawEdges=true)\n\nGenerates MetaPost of VG output in the file with name filename for a two-dimensional VoronoiGeometry.\n\nboard : The PlotBoard or MetaPostBoard to be used. \ndrawNodes : Set this value to \"false\" in order to not show the nodes in the output  \ndrawVerteces : Set this value to \"false\" in order to not show the verteces in the output  \ndrawEdges : Set this value to \"false\" in order to not show the edges in the output  \n\n\n\n\n\ndraw2D(Integral::Voronoi_Integral, filename::String; domain=nothing, board=PlotBoard(), drawNodes=true, drawVerteces=true, drawEdges=true)\n\nAlmost the same as for a VoronoiGeometry. It has one additional parameter:\n\ndomain: A domain of type Boundary can be passed here. This will be shown in the color specified by domain_color.\n\n\n\n\n\n","category":"function"},{"location":"man/metapost/","page":"Graphical Output in 2D and 3D","title":"Graphical Output in 2D and 3D","text":"You may need the following:","category":"page"},{"location":"man/metapost/","page":"Graphical Output in 2D and 3D","title":"Graphical Output in 2D and 3D","text":"PlotBoard","category":"page"},{"location":"man/metapost/#HighVoronoi.PlotBoard","page":"Graphical Output in 2D and 3D","title":"HighVoronoi.PlotBoard","text":"PlotBoard\n\nProvides a board to display a two-dimensional VoronoiGeometry in the Julia Plots format using draw2D or draw3D.\n\n\n\n\n\n","category":"type"},{"location":"man/metapost/#draw3D","page":"Graphical Output in 2D and 3D","title":"draw3D","text":"","category":"section"},{"location":"man/metapost/","page":"Graphical Output in 2D and 3D","title":"Graphical Output in 2D and 3D","text":"(Image: Sample 3D plot)","category":"page"},{"location":"man/metapost/","page":"Graphical Output in 2D and 3D","title":"Graphical Output in 2D and 3D","text":"The same works with 3 dimensions (you may also pass a customized PlotBoard):","category":"page"},{"location":"man/metapost/","page":"Graphical Output in 2D and 3D","title":"Graphical Output in 2D and 3D","text":"    VG = VoronoiGeometry(VoronoiNodes(rand(3,5)),cuboid(3,periodic=[]))\r\n\r\n    draw3D(VG,\"nice_plot_3D.pdf\")","category":"page"},{"location":"man/metapost/#Using-PlotlyJS","page":"Graphical Output in 2D and 3D","title":"Using PlotlyJS","text":"","category":"section"},{"location":"man/metapost/","page":"Graphical Output in 2D and 3D","title":"Graphical Output in 2D and 3D","text":"    using PlotlyJS\r\n\r\n    plotly()\r\n    VG = VoronoiGeometry(VoronoiNodes(rand(3,5)),cuboid(3,periodic=[]))\r\n\r\n    draw3D(VG)","category":"page"},{"location":"man/metapost/","page":"Graphical Output in 2D and 3D","title":"Graphical Output in 2D and 3D","text":"warning:  \nWhen you use plotly() you will not be able to write the output to a file.","category":"page"},{"location":"man/metapost/#D-Output-using-MetaPost","page":"Graphical Output in 2D and 3D","title":"2D-Output using MetaPost","text":"","category":"section"},{"location":"man/metapost/","page":"Graphical Output in 2D and 3D","title":"Graphical Output in 2D and 3D","text":"Similar to LaTeXX, MetaPost is an elegant way to create eps, pdf etc. from a programming language vector graphic code. If you do not have it installed on your PC, you may use the  MetaPost generator by Troy Henderson: www.tlhiv.org/mppreview/. However, this link sometimes did not work in the past.","category":"page"},{"location":"man/metapost/#The-MeatPostBoard","page":"Graphical Output in 2D and 3D","title":"The MeatPostBoard","text":"","category":"section"},{"location":"man/metapost/","page":"Graphical Output in 2D and 3D","title":"Graphical Output in 2D and 3D","text":"These methods are based on the MetaPostBoard structure:","category":"page"},{"location":"man/metapost/","page":"Graphical Output in 2D and 3D","title":"Graphical Output in 2D and 3D","text":"MetaPostBoard","category":"page"},{"location":"man/metapost/#HighVoronoi.MetaPostBoard","page":"Graphical Output in 2D and 3D","title":"HighVoronoi.MetaPostBoard","text":"MetaPostBoard\n\nProvides a board to display a two-dimensional VoronoiGeometry in MetaPost text format using draw2D.\n\n\n\n\n\n","category":"type"},{"location":"man/metapost/","page":"Graphical Output in 2D and 3D","title":"Graphical Output in 2D and 3D","text":"MetaPostBoard()","category":"page"},{"location":"man/metapost/#HighVoronoi.MetaPostBoard-Tuple{}","page":"Graphical Output in 2D and 3D","title":"HighVoronoi.MetaPostBoard","text":"The constructor\n\nMetaPostBoard()\n\nGenerates a MetapostBoard where the following <:Real-type arguments may be passed (=standard value)\n\nscaling=100: denotes a factor by which every object is magnified (also applies to the coordinates of points)\nnode_size=0.01: nodes are drawn as a cross. This variable is the size of a cross BEFORE scaling\nvertex_size=0.003: same for verteces\n\nAdditionally, the following colors may be passed as a <:String. note that an empty string implies the usage of the MetaPost standard pen color.\n\nnodes_color=\"\": the color at which nodes are draw. Empty string implies standard color (typically black)\nvertex_color=\"red\": color verteces\nedge_color=\"blue\": color of edges\ndomain_color=\"\": color the domain, in case a domain argument is passed to the draw2D-function. Also it displays the domain that was passed to a VoronoiGeometry during instatiation  \nboard::Boundary: provides a board: every node or vertex outside this board is not drawn\n\n\n\n\n\n","category":"method"},{"location":"man/projection/#Volume-Projection-Matrix","page":"Projection operators","title":"Volume Projection Matrix","text":"","category":"section"},{"location":"man/projection/","page":"Projection operators","title":"Projection operators","text":"The idea of \"projection\" stems from finite volume application. Assume the user has solved a FV problem on a coarse geometry VG and wants to project this solution onto the refined geometry VG2 as an initial guess for a solver of the FV problem on VG2. Have a look at the following code.","category":"page"},{"location":"man/projection/","page":"Projection operators","title":"Projection operators","text":"    using SparseArrays\r\n    VG = VoronoiGeometry(VoronoiNodes(rand(2,10)),cuboid(2,periodic = [1]),integrator=HighVoronoi.VI_POLYGON)\r\n    VG2 = refine(VG,VoronoiNodes(0.2*rand(2,4)))\r\n    rows, cols, vals = interactionmatrix(VG2,VG)\r\n    A = sparse(rows,cols,vals)\r\n    println(A*ones(Float64,10)) # this will print out a vector or 14 values `1.0` (mass conservation)","category":"page"},{"location":"man/projection/","page":"Projection operators","title":"Projection operators","text":"Then A is the matrix that projects vectors on VG to vectors on VG2. More precisely, let VG be a partition in cells with masses m_i and let VG2 a partition in cells with masses tilde m_j. Then, if u is the vector of data on VG and tilde u is the data on VG2 with tilde u = A cdot u then","category":"page"},{"location":"man/projection/","page":"Projection operators","title":"Projection operators","text":"sum_j tilde m_j tilde u_j = sum_i m_i u_i","category":"page"},{"location":"man/projection/#Optional-Parameters","page":"Projection operators","title":"Optional Parameters","text":"","category":"section"},{"location":"man/projection/","page":"Projection operators","title":"Projection operators","text":"check_compatibility=true: This enforces that the geometries are verified for their compatibility.\ntolerance = 1.0E-12,: This two points in VG and VG2 have a distance of less than tolerance they are considered identical\nhits_per_cell = 1000: The method is based on a sampling procedure. This parameter controlls how many samples are taken from each cell on average.\nbounding_box=Boundary(): It is mathematicaly not reasonable to apply the method for unbounded domains. However, if you anyway wish to do so, you have to provide a bounded bounding_box.","category":"page"},{"location":"man/projection/#Conditions-on-VG-and-VG2","page":"Projection operators","title":"Conditions on VG and VG2","text":"","category":"section"},{"location":"man/projection/","page":"Projection operators","title":"Projection operators","text":"VG and VG2 may be completely unrelated, the methods works anyway as long as the domains are bounded (or an additional bound is provided) and identical, including periodicity.","category":"page"},{"location":"man/projection/#This-works","page":"Projection operators","title":"This works","text":"","category":"section"},{"location":"man/projection/#Example-1","page":"Projection operators","title":"Example 1","text":"","category":"section"},{"location":"man/projection/","page":"Projection operators","title":"Projection operators","text":"    VG = VoronoiGeometry(VoronoiNodes(rand(2,10)),cuboid(2,periodic = [1]),integrator=HighVoronoi.VI_GEOMETRY)\r\n    VG2 = VoronoiGeometry(VoronoiNodes(rand(2,20)),cuboid(2,periodic = [1]),integrator=HighVoronoi.VI_POLYGON)\r\n    rows, cols, vals = interactionmatrix(VG2,VG)\r\n    rows2, cols2, vals2 = interactionmatrix(VG,VG2) # the inverse projection","category":"page"},{"location":"man/projection/#Example-2","page":"Projection operators","title":"Example 2","text":"","category":"section"},{"location":"man/projection/","page":"Projection operators","title":"Projection operators","text":"    VG = VoronoiGeometry(VoronoiNodes(rand(2,10)),cuboid(2,periodic = []))\r\n    VG2 = VoronoiGeometry(VoronoiNodes(rand(2,20)),cuboid(2,periodic = []))\r\n    rows, cols, vals = interactionmatrix(VG2,VG)\r\n    rows2, cols2, vals2 = interactionmatrix(VG,VG2) # the inverse projection","category":"page"},{"location":"man/projection/#Example-5","page":"Projection operators","title":"Example 5","text":"","category":"section"},{"location":"man/projection/","page":"Projection operators","title":"Projection operators","text":"    VG = VoronoiGeometry(VoronoiNodes(rand(2,10)))\r\n    VG2 = VoronoiGeometry(VoronoiNodes(2*rand(2,20)))\r\n    rows, cols, vals = interactionmatrix(VG2,VG,bounding_box=cuboid(2))","category":"page"},{"location":"man/projection/#This-does-not-works","page":"Projection operators","title":"This does not works","text":"","category":"section"},{"location":"man/projection/#Example-4","page":"Projection operators","title":"Example 4","text":"","category":"section"},{"location":"man/projection/","page":"Projection operators","title":"Projection operators","text":"The following breaks because the periodicities are not compatible","category":"page"},{"location":"man/projection/","page":"Projection operators","title":"Projection operators","text":"    VG = VoronoiGeometry(VoronoiNodes(rand(2,10)),cuboid(2,periodic = [1]),integrator=HighVoronoi.VI_GEOMETRY)\r\n    VG2 = VoronoiGeometry(VoronoiNodes(rand(2,20)),cuboid(2,periodic = []),integrator=HighVoronoi.VI_POLYGON)\r\n    rows, cols, vals = interactionmatrix(VG2,VG)","category":"page"},{"location":"man/projection/#Example-5-2","page":"Projection operators","title":"Example 5","text":"","category":"section"},{"location":"man/projection/","page":"Projection operators","title":"Projection operators","text":"The following breaks because the dimensions of the domain are different.","category":"page"},{"location":"man/projection/","page":"Projection operators","title":"Projection operators","text":"    VG = VoronoiGeometry(VoronoiNodes(rand(2,10)),cuboid(2,periodic = []))\r\n    VG2 = VoronoiGeometry(VoronoiNodes(2*rand(2,20)),cuboid(2,periodic = [],dimensions=2*ones(Float64,dim)))\r\n    rows, cols, vals = interactionmatrix(VG2,VG)","category":"page"},{"location":"man/projection/#Example-6","page":"Projection operators","title":"Example 6","text":"","category":"section"},{"location":"man/projection/","page":"Projection operators","title":"Projection operators","text":"The following breaks because the dimension is unbounded.","category":"page"},{"location":"man/projection/","page":"Projection operators","title":"Projection operators","text":"    VG = VoronoiGeometry(VoronoiNodes(rand(2,10)))\r\n    VG2 = VoronoiGeometry(VoronoiNodes(2*rand(2,20)))\r\n    rows, cols, vals = interactionmatrix(VG2,VG)","category":"page"},{"location":"man/integrals/#evenmoreintegrals","page":"(More) Integrals","title":"(More) Integrals","text":"","category":"section"},{"location":"man/integrals/","page":"(More) Integrals","title":"(More) Integrals","text":"There are two more options that can be passed to VoronoiFVProblem():","category":"page"},{"location":"man/integrals/","page":"(More) Integrals","title":"(More) Integrals","text":"bulk_integrals: A list of functions following the pattern of rhs_functions\nflux_integrals: A list of functions following the pattern of fluxes but returning only one single value instead of two.","category":"page"},{"location":"man/integrals/","page":"(More) Integrals","title":"(More) Integrals","text":"These options are thought to provide the user with the ability to calculate complex integrals even after the VoronoiGeometry has been calculated. The algorithm will sum every member of flux_integrals over all interfaces and sum every member of bulk_integrals over all cells.","category":"page"},{"location":"man/integrals/","page":"(More) Integrals","title":"(More) Integrals","text":"To illustrate this, consider the following example:","category":"page"},{"location":"man/integrals/","page":"(More) Integrals","title":"(More) Integrals","text":"function surface_int(;para_i,para_j,mass_ij,normal,kwargs...) \r\n    # kwargs... collects all additional parameters which are not used in the current function.\r\n    weight = mass_ij * sqrt(para_i[:κ]*para_j[:κ])\r\n    return weight\r\nend\r\n\r\nb_int(;para_i,mass_i,kwargs...) = mass_i * para_i[:f] * para_i[:κ]^2 \r\n\r\nfunction test_integrals()\r\n    nodes = VoronoiNodes(rand(2,40))\r\n    # calculate Voronoi tessellation and integrate κ(x)=sin(pi*x[1]) and f(x)=x[2]^2 over individual cells and interfaces\r\n    VG_basis = VoronoiGeometry(nodes,cuboid(2,periodic=[]),integrator=HighVoronoi.VI_POLYGON,integrand=x->[sin(pi*x[1]),x[2]^2])\r\n\r\n    # set up fluxes and RHS\r\n    vfvp = VoronoiFVProblem(VG_basis,  \r\n                                # note that the exact form of κ and f does not matter since data will be retrieved from VG_basis:\r\n                              integralfunctions = (κ = x->1.0, f = x->1.0, ), \r\n                              flux_integrals = ( fi = surface_int, ),\r\n                              bulk_integrals = (bi = b_int,) )\r\n    # print the integral of sqrt(κ_i*κ_j) over the interfaces\r\n    println( get_Fluxintegral(vfvp,:fi) )\r\n    # print the integral of f*κ^2 over the bulk\r\n    println( get_Bulkintegral(vfvp,:bi))\r\nend\r\n","category":"page"},{"location":"man/advanced/#Advanced-Options-for-controlling-the-Algorithm-and-output","page":"Advanced Options","title":"Advanced Options for controlling the Algorithm and output","text":"","category":"section"},{"location":"man/advanced/#Output-options","page":"Advanced Options","title":"Output options","text":"","category":"section"},{"location":"man/advanced/","page":"Advanced Options","title":"Advanced Options","text":"silence=true: will suppress output by voronoi algorithm and integration, thereby speed up the routine a little bit.\nprintevents=true: callable only in VoronoiGeometry(points,...) this will generate output at the end of the voronoi algorithm with some information on the results and if there where some unexpected events due to non-regular data strucutres.","category":"page"},{"location":"man/advanced/#Controlling-the-Voronoi-Algorithm","page":"Advanced Options","title":"Controlling the Voronoi-Algorithm","text":"","category":"section"},{"location":"man/advanced/","page":"Advanced Options","title":"Advanced Options","text":"The optional argument search_settings::NamedTuple will help to influence the Voronoi routine. However, if you don't know what for sure what you do, you should not touch these. Otherwise don't blame the package if you get strange results or crash the algorithm. Also you should be aware of the fact that parameters once set at generation of a VoronoiGeometry are kept for refining, substituting, .... You can, however, locally modify these parameters with search_settings in refine! or substitute!","category":"page"},{"location":"man/advanced/","page":"Advanced Options","title":"Advanced Options","text":"The following commands are available:","category":"page"},{"location":"man/advanced/","page":"Advanced Options","title":"Advanced Options","text":"variance-tol=1E-20: when the variance of (distance of a vertex to its nodes)^2 is larger than that value, the vertex candidate will be corrected\nbreak_tol=1E-5 : when the afore mentioned variance is even larger than that (actually did not appear in tests on bounded domains so far) this is sign that something goes                terribly wrong. Therefore, the vertex is skipped. cases when this happens is a geometry quasi periodic in at least one dimension and unbounded in the others. Typically happens \"far away, i.e. 1E200\" from the origin.\nb_nodes_tol=1E-10: When a vertex has a  distance smaller than that to the boundary, it is considered a boundary vertex. ","category":"page"},{"location":"man/workflowmesh/#workflowgeometry","page":"Workflow","title":"Workflow","text":"","category":"section"},{"location":"man/workflowmesh/","page":"Workflow","title":"Workflow","text":"In order to create a VoronoiGeometry you have several options you should think through and decide:","category":"page"},{"location":"man/workflowmesh/","page":"Workflow","title":"Workflow","text":"VoronoiNodes, i.e. the generators of your mesh can be:\nperiodic, so you may look here\nnon-periodic\nfully customized by the user, here\ndestributed according to a density, here\nThe domain, i.e. a Boundary object. Those could be\nrectangular\ncustomized, including (partially) unbounded domains\nThe integrator argument. This basically choses between sole geometry calculation and various integration techniques, see here\nThe integrand, which is optionally a function that you whish to calculate the local integrals over cells and interfaces.","category":"page"},{"location":"man/workflowmesh/","page":"Workflow","title":"Workflow","text":"Built on top are methods for refinement and replacement","category":"page"},{"location":"man/finitevolume/#The-Finite-Volume-functionality","page":"Finite Volume Tutorial","title":"The Finite Volume functionality","text":"","category":"section"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"HighVoronois most important feature to the user is the automatic generation of a linear system ","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"mathbb Amathbf u = mathbf b","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"from the PDE-Problem","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"-nablacdotleft(kappanabla u + kappa unabla Vright) = f","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"More abstract, the class VoronoiFVProblem discretizes the problem ","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"nablacdot J(u) = ftagFlux-Form","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"in the bulk (in the domain) where J(u) is a linear differential operator in u and f is a given right hand side. Furthermore, the method can account for periodic, Dirichlet and Neumann boundary conditions, also all at once (on different parts of the boundary).","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"The function linearVoronoiFVProblem then adds particular boundary conditions to the abstract discretization in VoronoiFVProblem and returns a linear equation to be solved.","category":"page"},{"location":"man/finitevolume/#The-VoronoiFVProblem-dataset","page":"Finite Volume Tutorial","title":"The VoronoiFVProblem dataset","text":"","category":"section"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"note: Summary\nThe VoronoiFVProblem is conceptually a black box into which the user throws a list of nodes and a boundary (or a ready-to-use VoronoiGeometry) as well as a description of J and f. Internally, the black box computes the discrete coefficients of J and f and stores them in a way that allows efficient computation of the matrix and right-hand side for given boundary conditions. We advise the user to first jump to the examples for calculations of fluxes below and afterwards study the following abstract description of VoronoiFVProblem.","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"VoronoiFVProblem()","category":"page"},{"location":"man/finitevolume/#HighVoronoi.VoronoiFVProblem-Tuple{}","page":"Finite Volume Tutorial","title":"HighVoronoi.VoronoiFVProblem","text":"VoronoiFVProblem(Geo::VoronoiGeometry; parent = nothing)  # first variant\nVoronoiFVProblem(points, boundary; integrator = VI_POLYGON, kwargs...)      # second variant\n\nGenerates Finite Volume data for fluxes and right hand sides given either a VoronoiGeometry object or a set of points and a boundary,  which will serve to internally create a VoronoiGeometry. Allows for the following parameters:\n\nkwargs... : arguments that are not listed explicitly below will be passed to the VoronoiGeometry. integrand will be overwritten. \nparent: If parent is generated from Geo_p and Geo is a refined version of Geo_p this parameter will initiate the calculation    of an L^1 projection operator between the spaces of piecewise constant functions on the respective Voronoi Tessellations.  \ndiscretefunctions=nothing : A named tuple of form (alpha=x->norm(x),f=x->-x,). Will be evaluated pointwise.\nintegralfunctions=nothing : A named tuple of form (alpha=x->norm(x),f=x->-x,). It will make the algoritm calculate the integrals   over the given functions or it will associate values to the list of functions based on integrated data present in Geo\nfluxes=nothing : this is assumed to be named tuple, e.g. like the following:\n  fluxes = (alpha = f1, beta = f2, eta = f3, zeta = f4, )\nand every of the given fluxes alpha, beta, eta, zeta, has the following structure:   It is one single flux-function  accessing the following named data (see also here in the Documentation):\n  x_i, x_j, para_i, para_j, para_ij, mass_i, mass_j, mass_ij, normal\nand returning two values. Functions f1, f2 ... should hence be defined similar to the  following:\n  function f1(;x_i,x_j,para_ij, kwargs...)\n      # some code\n      return something_i, something_j\n  end\nRefer to the examples in the documentation.\n\nnote: standard settings\nif the array of Neumann-planes is not provided, the standard list given in boundary resp. the boundary in Geo will be used. \n\nrhs_functions=nothing: same as for fluxes. However, functions can only access the variables\n  x_i, mass_i, para_i,\n\n\n\n\n\n","category":"method"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"VoronoiFVProblem","category":"page"},{"location":"man/finitevolume/#HighVoronoi.VoronoiFVProblem","page":"Finite Volume Tutorial","title":"HighVoronoi.VoronoiFVProblem","text":"struct VoronoiFVProblem{...}\n\nafter initialization the struct contains the following information:\n\nGeometry : a VoronoiGeometry containing mesh and integrated information\nCoefficients : Not advised to be accessed by user \nParent : Not advised to be accessed by user\nprojection_down : Not advised to be accessed by user\nprojection_up : Not advised to be accessed by user\nparameters : Not advised to be accessed by user\n\n\n\n\n\n","category":"type"},{"location":"man/finitevolume/#myVoronoiFVProblem","page":"Finite Volume Tutorial","title":"Examples for the VoronoiFVProblem","text":"","category":"section"},{"location":"man/finitevolume/#Content","page":"Finite Volume Tutorial","title":"Content","text":"","category":"section"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"Creating a VoronoiFVProblem\nCalculating fluxes and rigthand side\nCreating a VoronoiFVProblem from a VoronoiGeometry\nInternal storage of data (For very deep coding only)","category":"page"},{"location":"man/finitevolume/#examplecreating","page":"Finite Volume Tutorial","title":"Creating a VoronoiFVProblem and calculating some integrals...","text":"","category":"section"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"We create a first instance of VoronoiFVProblem. The following code calculates a VoronoiGeometry for the given data of random points. It furthermore calculates the integral of integralfunctions and pointwise evaluations of discretefunctions. The latter are not stored but will be internally used for calculations of fluxes or right hand sides (in a later example). To get familiar with the data structure try out the following:","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"using LinearAlgebra\r\n\r\nfunction myrhs(;para_i,mass_i,kwargs...)\r\n    return para_i[:alpha]*mass_i\r\nend\r\n\r\nfunction test_FV(dim,nop)\r\n    data = rand(dim,nop)\r\n    xs = VoronoiNodes(data)\r\n    cube = cuboid(dim,periodic=[1])\r\n    VoronoiFVProblem(xs,cube, discretefunctions = (alpha=x->sum(abs,x),), \r\n                              rhs_functions = (F=myrhs,) )\r\nend\r\n\r\nvfvp = test_FV(2,4)\r\nprintln(vfvp.Coefficients.functions)","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"The algorithm internally calculutes for each of the four random cells the quantity alpha(x_i)*m_i, where m_i is the mass of cell i. The output hence looks like the following:","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"(F = [0.8899968951003052, 1.6176576528551534, 1.2484331005796414, 0.9868594550457225],)","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"At a later stage, we will of course not directly work with vfvp.Coefficients.functions...\nmyrhs could addionally work with x_i, the coordinates of x_i","category":"page"},{"location":"man/finitevolume/#examplefluxes","page":"Finite Volume Tutorial","title":"Calculating fluxes and rigthand side","text":"","category":"section"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"We write isim j if the Voronoi cells of the nodes x_i and x_j are neighbored. Then the discrete version of ","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"nablacdot J(u) = ftagFlux-Form","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"in the node x_i is ","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"sum_jsim i J_ij(u) = F_itagFlux-Form-discrete","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"note: Indeces $i$ and $j$\nIn the text and in the code hereafter i is the current cell and j is either a neighbor or an index of a part of the boundary.","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"More precisely, let f and kappa be scalar functions. If m_i  is the mass of cell i and m_ij is the mass of the interface between cells i and j and f_i=f(x_i) or f_i=m_i^-1int_cell_if and similarly for kappa we find the following possible discretization of Fick's law:","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"J(u)=-kappa nabla u qquadleftrightarrowqquad J_ij(u)=-fracm_ijh_ijsqrtkappa_ikappa_j(u_j-u_i)=+fracm_ijh_ijsqrtkappa_ikappa_j(u_i-u_j)","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"with the right hand side ","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"F_i=m_i f_i","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"We can rewrite J_ij(u) in the following form:","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"J_ij(u)=fracm_ijh_ijsqrtkappa_ikappa_ju_i-fracm_ijh_ijsqrtkappa_ikappa_ju_j=p_ijiu_i - p_ijju_j","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"note: purpose of `VoronoiFVProblem`\nThe purpose of VoronoiFVProblem is to calculate p_iji and p_ijj using fluxes=... as well as F_i using rhs_functions.","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"We implement the above discretization in myflux_1 and an alternative replacing sqrtkappa_ikappa_j by an average over the joint interface of cells ij in myflux_2. Here, alpha is evaluated pointwise in the middle of each cell / interface, while kappa is averaged over cells and interfaces.","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"using LinearAlgebra\r\nusing SpecialFunctions\r\n\r\nfunction myflux_1(;para_i,para_j,mass_ij,normal,kwargs...) \r\n    # kwargs... collects all additional parameters which are not used in the current function.\r\n    weight = norm(normal)^(-1) * mass_ij * sqrt(para_i[:kappa]*para_j[:kappa])\r\n    return weight, weight\r\nend\r\n\r\nfunction myflux_2(;para_ij,mass_ij,normal,kwargs...)\r\n    # kwargs... collects all additional parameters which are not used in the current function.\r\n    weight = norm(normal)^(-1) * mass_ij * para_ij[:kappa]\r\n    return weight, weight\r\nend\r\n\r\nmyRHS(;para_i,mass_i,kwargs...) = mass_i * para_i[:f] \r\n\r\n\r\nfunction test_FV(dim,nop)\r\n    data = rand(dim,nop)\r\n    xs = VoronoiNodes(data)\r\n    cube = cuboid(dim,periodic=[],neumann=[1,-1]) # cube with preset Neumann BC in dimension 1 and Dirichlet BC all other dimensions\r\n    VoronoiFVProblem(xs,cube, discretefunctions = (f=x->sin(2*pi*x[1]),), # evaluate f pointwise\r\n                              integralfunctions = (kappa=x->1.0+norm(x)^2,), # calculate averages of kappa over cells and interfaces\r\n                              fluxes = ( j1 = myflux_1, j2 = myflux_2, ),\r\n                              rhs_functions = (F = myRHS,) )\r\nend\r\n\r\ntest_FV(2,10)","category":"page"},{"location":"man/finitevolume/#FVfromGeo","page":"Finite Volume Tutorial","title":"Creating a VoronoiFVProblem from a VoronoiGeometry","text":"","category":"section"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"It is also possible to write the following less compact code for test_FV(dim,nop). Though it may seem weird to do the extra effort, remember that mesh generation in high dimensions is very time consuming. Hence this approach could be usefull to set up a high dimensional problem from a formerly calculated grid.","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"function test_FV(dim,nop)\r\n    data = rand(dim,nop)\r\n    xs = VoronoiNodes(data)\r\n    cube = cuboid(dim,periodic=[],neumann=[1,-1]) \r\n    vg = VoronoiGeometry(xs, cube, integrator=HighVoronoi.VI_POLYGON, \r\n                                   integrand=x->1.0+norm(x)^2)\r\n    vfvp = VoronoiFVProblem(vg, discretefunctions = (f=x->sin(2*pi*x[1]),), \r\n                              integralfunctions = (kappa=x->0.0,), \r\n                              fluxes = ( j1 = myflux_1, j2 = myflux_2, ),\r\n                              rhs_functions = (F = myRHS,) )\r\nend","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"The instatiation of vg calculates all integrals of x->1.0+norm(x)^2. The instatiation of vfvp cimply uses the values stored in vg and \"rebrands\" them as :kappa.","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"tip: Compatibility of dimension\nThe dimension of integrand in the instatiation of vg can be greater or equal than the summed up dimension of all integralfunctions, but not less!! The definition of :kappa in VoronoiFVProblem(...) in the above example does not matter as all values have been calculated before. We strongly advise to have a look at the \"intentions of use\" section. ","category":"page"},{"location":"man/finitevolume/#examplestoragedata","page":"Finite Volume Tutorial","title":"Internal storage of data","text":"","category":"section"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"In the second example, try out the following code:","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"vfvp = test_FV(2,4)\r\nprintln(vfvp.Coefficients.functions)\r\nprintln(vfvp.Coefficients.fluxes)\r\nprintln(vfvp.Coefficients.rows)\r\nprintln(vfvp.Coefficients.cols)","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"The fields rows and cols of vfvp store the row and coloumn coordinates of potentially non-zero entries of a sparse flux matrix. The arrays stored in fluxes correspondingly store the non-zero values. It is thus possible to directly create SparseMatrix instances from this data. However, this would not yet properly account for boundary conditions. ","category":"page"},{"location":"man/finitevolume/#parameter_names","page":"Finite Volume Tutorial","title":"Full list of LOCAL PARAMETER names","text":"","category":"section"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"Functions like myflux_1 and myflux_2 in this example here are evaluated on interfaces between neighboring cells or on the boundary and can take the following arguments","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"x_i: coordinates of the current node i \nx_j: coordinates of the current neighbor j (in case this is an actually existing cell) or the coordinates of a point on the boundary (if this is part of the boundary, see onboundary)\npara_i and para_j: a named tuple container of all pointwise evaluated (discretefunctions) or averaged (integralfunctions) functions for either cell i and j respectively.\npara_ij: same for the interface\nmass_i and mass_j: if of cell i and j\nmass_ij: the mass of the interface\nnormal: Something like x_j-x_i. However, in case of periodic nodes with cells \"crossing the periodic boundary\", it typically holds x_i+mathrmnormalnot=x_j but (x_i+mathrmnormal) is a periodic shift of x_j. In any case, it is the correct outer normal vector with length of the \"periodized distance\". \nonboundary: is true if and only if x_j is a point on the boudary.   ","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"Righthand side functions (bulk functions) like myRHS are evaluated on nodes have only access to ","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"x_i\npara_i\nmass_i","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"danger: \nIf a function f is not provided to either discretefunctions or integralfunctions the call para_i[:f] and alike will cause an error message.\nEvery name can be used only ONCE. Particularly, a name f CANNOT be used both inside discretefunctions AND integralfunctions.","category":"page"},{"location":"man/finitevolume/#Extracting-the-full-FV-linear-equations-including-BOUNDARY-CONDITIONS","page":"Finite Volume Tutorial","title":"Extracting the full FV linear equations including BOUNDARY CONDITIONS","text":"","category":"section"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"Theoretical background\nlinearVoronoiFVProblem\nNo Dirichlet condition: Ambiguity\nExamples","category":"page"},{"location":"man/finitevolume/#lin_eq_background","page":"Finite Volume Tutorial","title":"Background","text":"","category":"section"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"To understand how boundary conditions are implemented in the HighVoronoi package, multiply equation (Flux-Form) with some function varphi and use integration by parts to obtain ","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"-int_domainJcdotnablavarphi=int_domainfvarphi-int_boundaryvarphiJcdot nu","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"where nu is the outer normal vector. ","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"Furthermore, assume we want to prescribe u=u_0 on some part of the boundary. We can write u=tilde u +u_0 where tilde u has boundary value 0. Then (Flux-Form-discrete) reads","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"sum_jsim i J_ij(tilde u + u_0) = F_i","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"However, since we work in a discrete setting, we can make the following assumptions:","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"note: Assumptions on boundary data\nThe function u_0 is a discrete function taking value 0 on every node inside the domain, but might be non-zero on the boundary. tilde u is a discrete function which is zero on all Dirichlet-parts of the boundary. \nThe function J_0 is a discrete function on the boundary which mimics J_0=Jcdotnu. In particular, we think of J_0(i,j)=m_ij*J_0(x_ij). ","category":"page"},{"location":"man/finitevolume/#linear_vor_prob","page":"Finite Volume Tutorial","title":"linearVoronoiFVProblem","text":"","category":"section"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"linearVoronoiFVProblem(vd::VoronoiFVProblem;flux)","category":"page"},{"location":"man/finitevolume/#HighVoronoi.linearVoronoiFVProblem-Tuple{VoronoiFVProblem}","page":"Finite Volume Tutorial","title":"HighVoronoi.linearVoronoiFVProblem","text":"linearVoronoiFVProblem(vd::VoronoiFVProblem;flux)\n\nTakes a VoronoiFVProblem and a flux::Symbol and creates a linear problem. flux has to refer to a flux created in vd.\n\nOptional arguments\n\nrhs: a Symbol referring to one of the rhs_functions or a vector of Float64 of the same length as the number of nodes.    If not provided, the system assumes rhs=zeros(Float64,number_of_nodes).\nNeumann: Can be provided in the forms \n(Int,Function,Int[.],Function,(Int[.],Function),...). Every Function depends on (;kwargs...) \nand represents J*ν on a single boundary plane Int or multiple planes Int[.].\nFunction then it takes the Neumann boundaries given by the definition of the boundary of the domain, unless nothing is reinterpreted as Dirichlet boundary.\nDirichlet: Can be provided in the form (Int,Function,Int[.],Function,(Int[.],Function),...). Every Function depends on (;kwargs...)    and represents u_0 on a single boundary plane Int or multiple planes Int[.].\n\nnote: `FVevaluate_boundary`\nUse FVevaluate_boundary(f) if you simply want f to be evaluated pointwise at the boundary nodes.\n\nnote: Standard boundary conditions and consistency\nThe algorithm will take zero Neumann  resp. zero Dirichlet as standard in case no other information is provided by the user. However, it is the  users responsibility to make sure there are no double specifications given in Neumann and Dirichlet.\n\nReturn values\n\nrows, cols, vals, rhs = linearVoronoiFVProblem(vd::VoronoiFVProblem;flux,kwargs...)\n\nrows, cols, vals are the row and coloumn indeces of values. Create e.g. A=sparse(rows,cols,vals) and sovle A*u=rhs\n\n\n\n\n\n","category":"method"},{"location":"man/finitevolume/#no_dirichlet","page":"Finite Volume Tutorial","title":"No Dirichlet condition: Ambiguity","text":"","category":"section"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"In case the boundary conditions consist only of periodic and/or Neumann conditions, the solution is unique only up to a constant. This is taken into account by providing linearVoronoiFVProblem with the parameter","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"enforcement_node=1: This picks out a node where the solution is forced to be 0. If the user wants another condition, such as average value 0, this can be achieved after solving the linear problem, as the library provides enough tools to calculate the respective integrals in the aftermath.  ","category":"page"},{"location":"man/finitevolume/#lin_vor_prob_ex","page":"Finite Volume Tutorial","title":"Examples","text":"","category":"section"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"Let us look at the following example:","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"    using SparseArrays\r\n\r\n    myrhs(;para_i,mass_i,kwargs...) = mass_i*para_i[:alpha]\r\n\r\n    function myflux_2(;para_ij,mass_ij,normal,kwargs...)\r\n        weight = norm(normal)^(-1) * mass_ij * para_ij[:alpha]\r\n        return weight, weight\r\n    end\r\n\r\n    xs = VoronoiNodes(rand(2,6))\r\n    cube = cuboid(2,periodic=[1])\r\n    vfvp = VoronoiFVProblem(xs, cube, discretefunctions = (alpha=x->sum(abs,x),), \r\n                                      rhs_functions=(F=myrhs,), \r\n                                      fluxes=(j1=myflux_2,) )\r\n    har = FVevaluate_boundary(x->0.0) # turn a function into the format HighVoronoi needs\r\n    one = FVevaluate_boundary(x->1.0)\r\n    r,c,v,f = linearVoronoiFVProblem(vfvp, flux = :j1, Neumann = (3,har), Dirichlet = (4,one))\r\n    A = sparse(r,c,v) # a sparse matrix with rows `r`, coloumns `c` and values `v`\r\n    # solution_u = somelinearsolver(A,f)","category":"page"},{"location":"man/finitevolume/","page":"Finite Volume Tutorial","title":"Finite Volume Tutorial","text":"As we see, the output of the algorithm is a matrix A and a right hand side f which can be plugged into a linear solver method from some suitable package.","category":"page"},{"location":"man/finitevolumeexample/#QuickFV","page":"Finite Volume Examples","title":"Quick Introduction to Finite Volume Problems","text":"","category":"section"},{"location":"man/finitevolumeexample/","page":"Finite Volume Examples","title":"Finite Volume Examples","text":"In what follows we give a short introduction on how to use the Finite Volume functionality of HighVoronoi.jl in 2d.","category":"page"},{"location":"man/finitevolumeexample/#Setting-up-a-FV-Problem","page":"Finite Volume Examples","title":"Setting up a FV Problem","text":"","category":"section"},{"location":"man/finitevolumeexample/#parameters","page":"Finite Volume Examples","title":"parameters","text":"","category":"section"},{"location":"man/finitevolumeexample/","page":"Finite Volume Examples","title":"Finite Volume Examples","text":"Since we want to reuse our code below, we define a set of parameters of the following form that will be passed to the FV code:","category":"page"},{"location":"man/finitevolumeexample/","page":"Finite Volume Examples","title":"Finite Volume Examples","text":"set = ( # only dirichlet boundary\r\n    u_exact = u,# expected exact solution\r\n    κ = k,# parameter field\r\n    RHS = rhs, # expected -[∇⋅(κ∇u)](x),\r\n    domain = d, # of form cuboid(2,periodic=[???]),\r\n    dirichlet_boundary = db, # indeces of Dirichlet boundaries of `domain` \r\n    neumann_boundary = nb, # indeces of Neumann boundaries of `domain`\r\n    neumann = n, # The Neumann condition for -(κ∇u)⋅ν = n on the neumann boundary\r\n)","category":"page"},{"location":"man/finitevolumeexample/","page":"Finite Volume Examples","title":"Finite Volume Examples","text":"a simple example is the following one:","category":"page"},{"location":"man/finitevolumeexample/","page":"Finite Volume Examples","title":"Finite Volume Examples","text":"set1 = ( # only dirichlet boundary\r\n    u_exact = x->sin(x[1]*π) * sin(x[2]*π)+1,\r\n    κ = x->1.0,\r\n    RHS = x->2*π^2 * sin(x[1]*π) * sin(x[2]*π),\r\n    domain = cuboid(dimension,periodic=[]), # no periodic boundaries\r\n    dirichlet_boundary = collect(1:4), # all four boundaries are Dirichlet\r\n    neumann_boundary = nothing # no Neumann condition\r\n)","category":"page"},{"location":"man/finitevolumeexample/#simulation-code","page":"Finite Volume Examples","title":"simulation code","text":"","category":"section"},{"location":"man/finitevolumeexample/","page":"Finite Volume Examples","title":"Finite Volume Examples","text":"The numerical calculations are done by the following code. It does the following:","category":"page"},{"location":"man/finitevolumeexample/","page":"Finite Volume Examples","title":"Finite Volume Examples","text":"generate the Voronoi geometry\nintegrate kappa and RHS over cells and interfaces and calculates the interface areas and cell volumes\nit uses the subsequently defined SQRA_flux and myRHS do set up the structure of the flux j=-kappanabla u and the right hand side from RHS.\nit defines the dirichlet boundary condition compatibility from the expected exact solution\nit defines the Neumann boundary condition neumann\nit calculates the matrix A and the right hand side f that describe the problem -nablacdot(kappanabla u)=RHS as a finite dimensional linear problem\nit uses the IterativeSolvers library to solve A*solution_u = f\nit calculates the L^2-error between the exact and the numerical solution\nit returns the nodes and values of the discrete solution.","category":"page"},{"location":"man/finitevolumeexample/","page":"Finite Volume Examples","title":"Finite Volume Examples","text":"function SQRA_flux(;para_i,para_j,mass_ij,normal,kwargs...) \r\n    # kwargs... collects all additional parameters which are not used in the current function.\r\n    weight = norm(normal)^(-1) * mass_ij * sqrt(para_i[:κ]*para_j[:κ])\r\n    return weight, weight\r\nend\r\n\r\nmyRHS(;para_i,mass_i,kwargs...) = mass_i * para_i[:f] \r\n\r\nfunction simulation(set)\r\n    # account for periodicity in the right hand side\r\n    new_RHS = HighVoronoi.PeriodicFunction(set.RHS,set.domain)\r\n    # modify original parameter set \r\n        # replace RHS by periodic version,\r\n        # set density distribution of points to x->1.0 in case nothing else is provided by user\r\n        # set neumann condition to zero if nothing else is provided by user \r\n    set = (density=x->1.0, neumann = x->0.0, dirichlet_boundary=nothing, neumann_boundary=nothing, set..., RHS=new_RHS)\r\n    # generate approximately 400 points distributed according to set.density\r\n    nodes = VoronoiNodes(1000;density=set.density,domain=cuboid(2,periodic=[]))\r\n    # calculate Voronoi tessellation\r\n    VG_basis = VoronoiGeometry(nodes,set.domain,integrator=HighVoronoi.VI_GEOMETRY)\r\n    # integrate parameters\r\n    VG_κ = VoronoiGeometry(VG_basis, integrator=HighVoronoi.VI_POLYGON, integrand=x->[set.κ(x),set.RHS(x)])\r\n    #retrieve total volume of domain to verify volume integration works properly\r\n    vd = VoronoiData(VG_κ)\r\n    println(\"vol: $(sum(vd.volume))\")\r\n\r\n    # set up fluxes and RHS\r\n    vfvp = VoronoiFVProblem(VG_κ,  \r\n                              integralfunctions = (κ = set.κ, f = set.RHS, ), \r\n                              fluxes = ( j1 = SQRA_flux, ),\r\n                              rhs_functions = (F = myRHS,) )\r\n    # define functions that can be applied as boundary conditions\r\n    compatibility = FVevaluate_boundary(x->set.u_exact(x))\r\n    neumann = FVevaluate_boundary(x->set.neumann(x))\r\n    # construct linear system from fluxes, RHS and boundary conditions\r\n    r,c,v,f = linearVoronoiFVProblem(vfvp, flux = :j1, rhs = :F, \r\n            Dirichlet = set.dirichlet_boundary!=nothing ? (set.dirichlet_boundary,compatibility) : nothing, \r\n            Neumann = set.neumann_boundary!=nothing ? (set.neumann_boundary,neumann) : nothing)\r\n    A = sparse(r,c,v) # a sparse matrix with rows `r`, coloumns `c` and values `v`\r\n    # solve linear system using IterativeSolvers-Package\r\n    solution_u = cg(A,f) # conjugate gradients\r\n    # print out approximate L²-error between exact and numerical solutions \r\n    println(\"Approximate L²-error: \",sqrt(sum(map(k->abs2(solution_u[k]-set.u_exact(nodes[k]))*VG_κ.Integrator.Integral.volumes[k],1:length(nodes)))))\r\n    \r\n    return nodes, solution_u  # return nodes and values for plotting...\r\n\r\nend\r\n\r\n\r\nnodes, values = simulation(set1)\r\n","category":"page"},{"location":"man/finitevolumeexample/#Plotting-the-Result","page":"Finite Volume Examples","title":"Plotting the Result","text":"","category":"section"},{"location":"man/finitevolumeexample/","page":"Finite Volume Examples","title":"Finite Volume Examples","text":"We may use the data obtained above for a plot of values against nodes:","category":"page"},{"location":"man/finitevolumeexample/","page":"Finite Volume Examples","title":"Finite Volume Examples","text":"using Plots\r\n\r\nfunction plot_2d_surface(nodes, values)\r\n    # The following two lines are necessary in order for the plot to look nicely\r\n    func = StepFunction(nodes,values) # some minor HighVoronoi tool\r\n    new_nodes = vcat([VoronoiNode([k/10,j*1.0]) for k in 0:10, j in 0:1], [VoronoiNode([j*1.0,k/10]) for k in 1:9, j in 0:1])\r\n    append!(nodes,new_nodes)\r\n    append!(values,[func(n) for n in new_nodes])\r\n    \r\n    x = [node[1] for node in nodes]\r\n    y = [node[2] for node in nodes]\r\n    \r\n    p = surface(x, y, values, legend=false)\r\n    xlabel!(\"X\")\r\n    ylabel!(\"Y\")\r\n    zlabel!(\"Values\")\r\n    title!(\"2D Surface Graph\")\r\n    \r\n    display(p)\r\nend\r\n\r\nplot_2d_surface(nodes, values)\r\n","category":"page"},{"location":"man/finitevolumeexample/#Other-Simulation-Examples","page":"Finite Volume Examples","title":"Other Simulation Examples","text":"","category":"section"},{"location":"man/finitevolumeexample/","page":"Finite Volume Examples","title":"Finite Volume Examples","text":"Instead of set1 from above, try out the following examples.","category":"page"},{"location":"man/finitevolumeexample/","page":"Finite Volume Examples","title":"Finite Volume Examples","text":"warning: Mind the regularity\nIf you want to verify the algorithm with known examples, keep in mind that the expected solution should be C^2 accross the periodic boundary or you may find unexpected behavior...","category":"page"},{"location":"man/finitevolumeexample/","page":"Finite Volume Examples","title":"Finite Volume Examples","text":"set2 = ( # dirichlet boundary and periodic in 1st dim\r\n    u_exact = x->sin(x[1]*2*π) * sin(x[2]*π),\r\n    κ = x->1.0,\r\n    RHS = x->5*π^2 * sin(x[1]*2*π) * sin(x[2]*π),\r\n    domain = cuboid(dimension,periodic=[1]), # periodic in x[1]\r\n    dirichlet_boundary = collect(3:4),\r\n    neumann_boundary = nothing, # no neumann\r\n    neumann = x-> π* sin(x[2]*π)# 0#-π*cos(x[1]*π) * sin(x[2]*π)\r\n)\r\n\r\nset3 = ( # only dirichlet boundary\r\n    u_exact = x->x[1]^2,\r\n    κ = x->1.0,\r\n    RHS = x->-2,\r\n    domain = cuboid(dimension,periodic=[]),\r\n    dirichlet_boundary = collect(1:4),\r\n    neumann_boundary = nothing,\r\n    neumann = x->0.0\r\n)\r\n\r\nset4 = ( # Neumann on 1 and Dirichlet on 2-4 boundary\r\n    u_exact = x->x[1]^2,\r\n    κ = x->1.0,\r\n    RHS = x->-2.0,\r\n    domain = cuboid(dimension,periodic=[]),\r\n    dirichlet_boundary = collect(2:4),\r\n    neumann_boundary = 1,\r\n    neumann = x->-2.0\r\n)\r\n\r\nset5 = ( # periodic in x[1] and dirichlet in x[2] boundary\r\n    u_exact = x->sin(x[1]*π)^2 * sin(2*x[2]*π),\r\n    κ = x->1.0,\r\n    RHS = x->2*π^2 * (1-2*cos(2*π*x[1]))*sin(2*π*x[2]),\r\n    domain = cuboid(dimension,periodic=[1]),\r\n    dirichlet_boundary = collect(3:4),\r\n)\r\n\r\nset6 = ( # only dirichlet boundary\r\n    u_exact = x->sin(x[1]*2*π)^2 * sin(2*x[2]*π),\r\n    κ = x->1.0,\r\n    RHS = x->π^2 * (1-5*cos(4*π*x[1]))*sin(2*π*x[2]),\r\n    domain = cuboid(dimension,periodic=[]),\r\n    dirichlet_boundary = collect(1:4)\r\n)\r\n","category":"page"},{"location":"man/errors/#Known-sources-of-errors","page":"Sources of errors and loss in performance","title":"Known sources of errors","text":"","category":"section"},{"location":"man/errors/","page":"Sources of errors and loss in performance","title":"Sources of errors and loss in performance","text":"We summarize the major sources of errors so the user is aware of them:","category":"page"},{"location":"man/errors/","page":"Sources of errors and loss in performance","title":"Sources of errors and loss in performance","text":"inserting points into the grid that are outside of the prescribed domain. This will cause in the best case weird verteces that do not exist or - in most cases - it will crash the algorithm. However, since the algorithm allows for unbounded domains, this is easy to prevent.\nThe calculation of verteces and volumes is precise and reproduceable for regular grids. However, for nodes in non-general position, VI_POLYGON volume calculations tend to have a worst case error in the range of 2.0% in 5D and 6D and this value may increase in higher dimensions. You can test this on a unit cube to get an idea for a specific dimension. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = HighVoronoi","category":"page"},{"location":"#HighVoronoi-1.4.0:-N\\log-N-complexity-Parallel-Computed-Voronoi-Grids-in-\\mathbb{R}d-and-on-\\mathbb{S}d","page":"Home","title":"HighVoronoi 1.4.0: Nlog N complexity Parallel Computed Voronoi Grids in mathbbR^d and on mathbbS^d","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for HighVoronoi. Voronoi mesh generation in arbitrary dimensions + Finite Volume setup, also for vertices with d+k, k1 generators.","category":"page"},{"location":"","page":"Home","title":"Home","text":"QUICK START on VORONOI generation: Click here / The ABSTRACT WORKFLOW is here \nQUICK START on FINITE VOLUME methods: Click here / The ABSTRACT WORKFLOW is here  \nToy file for testing numerical solver","category":"page"},{"location":"#News-to-version-1.4.0:","page":"Home","title":"News to version 1.4.0:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Parallelized computation of convex hulls based on the raycast algorithm (no volumes / integrals)\nParallelized computation of Voronoi diagrams on spheres, including volumes and integrals (spheres are the only non-euclidian geometry where the raycast algorithm can be applied)","category":"page"},{"location":"#News-to-version-1.3.0:","page":"Home","title":"News to version 1.3.0:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Parallelized compuation of Voronoi Diagrams, volumes and integrals\nComprimated internal database with accellerated access, free choice of database\nImproved, accellerated Raycast routine (heart of Voronoi computations), free choice of Raycast method\nStorage is directly possible via JLD2.\nsubstitute is currently disabled as it has to be rewritten for new database structure.","category":"page"},{"location":"#News-to-version-1.2.0:","page":"Home","title":"News to version 1.2.0:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"further improved algorithms for faster calculation of all features\nVI_POLYGON has been modified. I uses more memory but is more than twice as fast in higher dimensions.\nA new Integrator has been implemented: VI_FAST_POLYGON, see here. Even more precise than VI_POLYGON and much faster (factor 15-20 to for 500 nodes in 6D) but using a lot of memory. Competitive with VI_MONTECARLO with mc_accurate=(10_000,2,2) in 6D (recall that a cell has on average 9_000 vertices in 6D).\nBug fixes for unbounded domains in the far field.","category":"page"},{"location":"#News-to-version-1.1.0:","page":"Home","title":"News to version 1.1.0:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"improved algorithms for faster calculation of all features\n3D output\nautmaticaly improving geometric quality of meshes if wanted by user: Nodes will be locally modified until voronoi nodes almost coincide with center of gravity of cells.","category":"page"},{"location":"#Preprints","page":"Home","title":"Preprints","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There is a recent PREPRINT where I outline the algorithm and provide a mathematical proof that it works. ","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Functionality-of-the-HighVoronoi-Package","page":"Home","title":"Functionality of the HighVoronoi Package","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HighVoronoi is intended as an effective Voronoi mesh generator in any ARBITRARY DIMENSION greater or equal to 2. It can work on polygonal domains and also on (partially or fully) periodic domains. It also provides methods to implement Finite Volume problems on these high dimensional meshes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The underlying Raycast-Method as well as the Monte-Carlo integration method were reimplemented from the VoronoiGraph package by Alexander Sikorski in the version of June 2022. In the course, the code was fully restructured and in wide parts rewritten to adapt it to mesh-refinement and to verteces that are formed by more than d+1 cells, e.g. cubic grids (with 2^d cells generating each vertex). Furthermore, boundaries, periodic grids and internal correction algorithms are implemented to stabilize the algorithm and to increase numerical accuracy.","category":"page"},{"location":"#Performance-and-advantages-over-the-classical-algorithms","page":"Home","title":"Performance and advantages over the classical algorithms","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The classical approach is to use quickhull in d+1 dimensions to get the Delaunay grid and calculate the Voronoigrid from there. Starting with n nodes that will have K verteces in total, the amount of calculations is at leas n^2 for the quickhull algorithm (with a lot of linear equations to be solved) and afterwards solving of K linear equations. In general, it is not fully understood how Quickhull scales with time, but it seems to be polynomial, see http://www.qhull.org/html/qh-code.htm#performance","category":"page"},{"location":"","page":"Home","title":"Home","text":"Compared to that, the computational cost of the HighVoronoi algorithm scales with K*ln n on regular grids and comes with almost no linear equations to be solved, except for the few occasions (like 0.01%) when a vertex needs to be corrected to compensate for accumulated machine inaccuracy. A paper on the underlying Raycast-Algorithm is in preparation.","category":"page"},{"location":"#Performance-in-4D","page":"Home","title":"Performance in 4D","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: nodes versus time in 4D)","category":"page"},{"location":"#Performance-in-5D","page":"Home","title":"Performance in 5D","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: nodes versus time in 5D)","category":"page"},{"location":"#Code-for-performance-check","page":"Home","title":"Code for performance check","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To verify the claimed scaling, one may use the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":" nodeslist = [200,500,1000,1500,2000,3000,4000,6000,8000,10000,12500,15000,17500,20000,22500,25000,27500,30000]\r\n dim = 5\r\n # look up statistics.jl in the src/ folder to see how collect_statistics and statistic_samples work \r\n A = HighVoronoi.collect_statistics(HighVoronoi.statistic_samples(dim,nodeslist,4),txt=\"results$(dim)D-30000-new.txt\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"The above calculates for each number of nodes n in nodeslist in dimension dim    a Voronoi grid in the unit cube. It does this 4 times and returns averaged information about:","category":"page"},{"location":"","page":"Home","title":"Home","text":"A[1,entry] = number of nodes\nA[2,entry] = dim\nA[3,entry] = average time for one calculation\nA[4,entry] = number of vertices\nA[5,entry] = number of vertices at the boundary of the unit cube\nA[6,entry] = number of raycasts\nA[7,entry] = average number of nn-searches per raycast","category":"page"},{"location":"","page":"Home","title":"Home","text":"The code below plots sample results from a 4D or a 5D simulation:","category":"page"},{"location":"","page":"Home","title":"Home","text":" # 4D: \r\n A = [200.0 500.0 1000.0 1500.0 2000.0 3000.0 4000.0 6000.0 8000.0 10000.0 12500.0 15000.0 17500.0 20000.0 22500.0 25000.0 27500.0 30000.0; 4.0 4.0 4.0 4.0 4.0 4.0 4.0 4.0 4.0 4.0 4.0 4.0 4.0 4.0 4.0 4.0 4.0 4.0; 0.050457975 0.131645475 0.295149075 0.47852225 0.6634493 1.166146925 1.5823699 2.430149 3.32245565 4.32058905 5.644007625 6.986462575 8.052074575 9.1541459 10.400109675 11.842956775 12.998982725 14.368660125; 4026.0 11125.5 23466.5 36429.5 49401.0 76030.0 103180.0 158009.5 213505.0 268840.75 339912.0 411174.0 482256.0 553107.5 625884.5 697474.5 769424.0 841395.0; 1633.75 3630.25 6507.25 9074.5 11473.75 15744.0 20051.75 27695.25 34437.25 41655.25 49458.0 56950.75 64301.75 71822.25 78083.25 85112.25 91864.0 98515.75; 4017.75 11104.25 23427.0 36371.25 49328.0 75921.5 103041.5 157807.75 213230.5 268510.5 339506.0 410691.0 481688.0 552451.5 625152.0 696653.25 768551.25 840449.0; 2.611411859871819 2.6134813247180135 2.605658001451317 2.6184486373165616 2.6229018001946156 2.6242599263713178 2.6269051789812843 2.621926046090892 2.626835748169235 2.627970786989708 2.628140592507938 2.6301477266363276 2.631068762352394 2.6324491833219748 2.6321470618345617 2.633201309259664 2.6337345752804384 2.6314196340289535]\r\n \r\n # 5D: \r\n #A = [200.0 500.0 1000.0 1500.0 2000.0 3000.0 4000.0 6000.0 8000.0 10000.0 12500.0 15000.0 17500.0 20000.0 22500.0 25000.0 27500.0 30000.0; 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0; 0.211763325 0.653174575 1.577807425 2.689303325 3.98041055 6.6097507 9.7188122 15.90510205 24.3054906 33.8117523 42.40471245 53.050212825 65.127449625 76.881652375 88.523779375 100.420322575 116.35595995 130.32798235; 15143.0 43881.0 98554.25 157179.25 215857.75 340909.25 468655.0 730134.0 1.0014475e6 1.2742545e6 1.6244175e6 1.97465225e6 2.324588e6 2.68794375e6 3.04505275e6 3.40743625e6 3.776617e6 4.1409315e6; 7809.75 19189.75 37197.0 53944.75 70912.5 101793.5 132341.75 190513.75 244890.5 299057.25 361937.25 425335.5 487805.25 545611.75 606317.75 664678.5 720208.75 776399.25; 15137.0 43869.75 98534.0 157151.0 215819.75 340856.5 468575.5 730022.75 1.00130575e6 1.27407825e6 1.6242075e6 1.97439425e6 2.32430825e6 2.68760575e6 3.0446865e6 3.40703625e6 3.77616375e6 4.140452e6; 2.5825130474995044 2.5891018298485857 2.593754440091745 2.598367175519087 2.6079552496933203 2.608840523798138 2.6137458104403666 2.6110275330460593 2.612983846342638 2.6159984679119983 2.6151359970939674 2.617593851886471 2.6170647761543675 2.616155661967906 2.6180548473545633 2.6180065592199084 2.6191039782106906 2.619351220591375]\r\n\r\n# This can be plotted using the following\r\nusing Plots\r\nusing DataFitting\r\nusing SpecialFunctions\r\n\r\noutput_round(x) = round(x, digits = 3 - floor(Int64,log10(abs(x))))\r\n\r\nf(x, p1, p2, p3 ) = @. (p1  +  p2 * x  +  p3 * x * log(x)   )\r\n\r\nparams = [1.0,1.0,1.0]\r\n\r\ndom = Domain(A[1,:])\r\ndata = Measures(A[3,:],1.0)\r\n\r\nmodel1 = Model(:comp1 => FuncWrap(f, params...))\r\nprepare!(model1, dom, :comp1)\r\nresult1 = fit!(model1, data)\r\n\r\nplot(A[1,:], A[3,:], color=:blue, label=\"nodes vs time\")\r\nmy_p1 = result1.param[:comp1__p1].val\r\nmy_p2 = result1.param[:comp1__p2].val\r\nmy_p3 = result1.param[:comp1__p3].val\r\nplot!(x->my_p1  +  my_p2 * x  +  my_p3 * x * log(x), color=:red, label=\"f(x)=$(output_round(my_p1))  +  $(output_round(my_p2)) * x  +  $(output_round(my_p3)) * x * log(x)\")\r\n\r\nsavefig(\"plot.pdf\")\r\n","category":"page"},{"location":"#The-HighVoronoi-package-provides","page":"Home","title":"The HighVoronoi package provides","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"a series of data sets that allow to set up a Voronoi mesh in arbitrary dimension on a convex domain with plane boundaries or even without boundaries.\nworks for nodes in general and non-general position. In particular, verices may be generated by more than d+1 generating nodes.\n2 different methods to calculate the volumes and interface areas of cells: An exact triangulation method and a Montecarlo method\n3 different methods to integrate functions:\ntwo on the fly for both triangulation and Montecarlo\none heuristic method based on given volume and surface data\nRefinement of Voronoi tessellations: Add points to your grid and the algorithm will locally recalculate the mesh, including integration of volume, area and functions.\nFast calculation of periodic grids using the periodic_grid keyword.\nSet up the linear equation for a finite volume Voronoi discretization of a given elliptic PDE with Neumann, Dirichlet or periodic boundary conditions\nother functionalities like 2D data export in Metapost, storing and loading data.","category":"page"},{"location":"#Important-data-structures-and-methods","page":"Home","title":"Important data structures and methods","text":"","category":"section"},{"location":"#Data-structures","page":"Home","title":"Data structures","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"VoronoiGeometry: Creating, loading, updating, refining and managing the mesh\nVoronoiNodes: Nodes for mesh generation\nBoundary: Boundary of the mesh\nVoronoiData: Providing the data of the mesh for further use outside of HighVoronoi.jl\nVoronoiFVProblem: Calculating internal data for setting up linear matrix equations for Finite Volume discretizations on a VoronoiGeometry\nStepFunction: Generates a piecewise constant function\nInterfaceFunction: Generates a function living on interfaces.\nFunctionComposer: Glues together several functions and returns a new vector valued function.","category":"page"},{"location":"#Methods","page":"Home","title":"Methods","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"write_jld: Store a VoronoiGeometry\nrefine!: refine a VoronoiGeometry by new nodes\nsubstitute!: refine a VoronoiGeometry by erasing the points in a given subdomain and replacing them by a finer precalculated grid. Automatically fills out all the gaps.\ninteractionmatrix: constructs a projectoin from a function on one geometry to a function on a second geometry.\nlinearVoronoiFVProblem: Extract the Matrix and right-hand-side from a given VoronoiFVProblem and for given boundary conditions.","category":"page"},{"location":"#To-be-implemented-in-a-forthcoming-version","page":"Home","title":"To be implemented in a forthcoming version","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"refine a VoronoiFVProblem. Project a given \"rough\" FV solution of a linearVoronoiFVProblem onto the refined solution space. ","category":"page"}]
}
